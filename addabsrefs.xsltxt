stylesheet 1.0;

// XSLTXT (https://xsltxt.dev.java.net/) stylesheet adding 
// absolute names to Mizar constructors and references.
// This means that the "aid" (article name) and the "absnr"
// (serial number in its article) attributes are added,
// and the "kind" attribute is added if not present.

// To produce standard XSLT from this do e.g.: 
// java -jar xsltxt.jar toXSL addabsrefs.xsltxt > addabsrefs.xsl

// Then e.g.: xalan -XSL addabsrefs.xsl <ordinal2.xml >ordinal2.xml1
//        or: xsltproc addabsrefs.xsl ordinal2.xml >ordinal2.xml1

// TODO: 
//       article numbering in Ref?
//       absolute definiens numbers for thesisExpansions?
//       add @nr to canceled
//       Constructor should know its serial number! - needed in defs

// NOTES: constructor disambiguation is done using the absolute numbers
//        (attribute 'nr' and 'aid' of the Constructor element.
//        This info for Constructors not defined in the article is
//        taken from the .atr file (see variable $constrs)

output method=xml;

// keys for fast constructor and reference lookup
key "M" [Constructor[@kind='M']] `@relnr` ;
key "L" [Constructor[@kind='L']] `@relnr` ;
key "V" [Constructor[@kind='V']] `@relnr` ;
key "R" [Constructor[@kind='R']] `@relnr` ;
key "K" [Constructor[@kind='K']] `@relnr` ;
key "U" [Constructor[@kind='U']] `@relnr` ;
key "G" [Constructor[@kind='G']] `@relnr` ;

key "T" [/Theorems/Theorem[@kind='T']] `concat(@articlenr,':',@nr)`;
key "D" [/Theorems/Theorem[@kind='D']] `concat(@articlenr,':',@nr)`;
key "S" [/Schemes/Scheme] `concat(@articlenr,':',@nr)`;

$lcletters= { "abcdefghijklmnopqrstuvwxyz"; }
$ucletters= { "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; } 

// name of current article (upper case)
#aname= { `string(/*/@aid)`; }

// name of current article (lower case)
#anamelc= { `translate($aname, $ucletters, $lcletters)`; }

// .atr file with imported constructors
#constrs=  { `concat($anamelc, '.atr')`; }

// .dco file with exported constructors
#dcoconstrs=  { `concat($anamelc, '.dco')`; }

// .eth file with imported theorems
#thms=  { `concat($anamelc, '.eth')`; }

// .esh file with imported schemes
#schms=  { `concat($anamelc, '.esh')`; }

// tpl [Const](#s) {  <Const { copy-of `@*`; @plevel=$s; }}

tpl [Pred](#i,#s) { 
  if [@kind='P'] {  copy { apply [@*](#s=$s); apply(#s=$s); } }
  else { <Pred {  
   abs(#k=`@kind`, #nr=`@nr`); apply(#s=$s); }}}

tpl [Func](#s) { 
  if [@kind='F']  {  copy { apply [@*](#s=$s); apply(#s=$s); } }
  else { <Func {  
   abs(#k=`@kind`, #nr=`@nr`); apply(#s=$s); }}}

// Adjective
tpl [Adjective](#s) { <Adjective 
    { copy-of `@*`; abs(#k="V", #nr=`@nr`); apply(#s=$s); }}

// Types
tpl [Typ](#s) { 
   <Typ {
   if [@kind="M"] { abs(#k="M", #nr=`@nr`); }
   else { if [@kind="G"] { abs(#k="L", #nr=`@nr`); }
     else { `@kind`; }}
   apply(#s=$s);}
}

tpl [From](#s){ <From { copy-of `@*`;
             getschref(#anr=`@articlenr`, #nr=`@nr`);
             apply(#s=$s); }}

tpl [Ref](#s) { if [not(@articlenr)] { copy { apply [@*](#s=$s); apply(#s=$s); } }
            else { <Ref {  copy-of `@*`;
    getref(#k=`@kind`, #anr=`@articlenr`, #nr=`@nr`);} }}

// add absolute numbers to these (they are kind-dependent)
tpl [Theorem|Constructor|Pattern](#s) { $n=`name()`; <$n { copy-of `@*`;
             $k=`@kind`; @aid=$aname;
             @nr=`1 + count(preceding::*[(name()=$n) and (@kind=$k)])`;
	     if [@redefnr > 0] { abs(#k=$k,#nr=`@redefnr`,#r="1"); } 
             apply(#s=$s); }}

tpl [Scheme|Definiens|RCluster|CCluster|FCluster](#s){ 
             $n=`name()`; <$n { copy-of `@*`; @aid=$aname;
             @nr=`1 + count(preceding::*[(name()=$n)])`;
             apply(#s=$s); }}

tpl [Field](#s) { <Field 
    { copy-of `@*`; abs(#k="U", #nr=`@nr`); 
      @arity= arity(#k="U", #nr=`@nr`);  apply(#s=$s); }}


tpl arity(#k,#nr) {
    if [key($k,$nr)] { for-each [key($k,$nr)] { `count(ArgTypes/Typ)`;}}
   else { 
     for-each [document($constrs,/)] { 
       if [key($k,$nr)] { for-each [key($k,$nr)] { `count(ArgTypes/Typ)`;}}
       else { 
         for-each [document($dcoconstrs,/)] { 
	   for-each [key($k,$nr)] { `count(ArgTypes/Typ)`;}}}}}}


// tpl [Field] { <Field 
//     { copy-of `@*`; abs(#k="U", #nr=`@nr`); 
//       $typs = widening(typ(U),typ(L),typ(U));
//       for-each [$typs] {
//           repl_loc_args(#w=
      
// apply; }}

// // find widening path from $f to $t
// tpl widening(#f,#t,#path) {
//     if [absname($f) = absname($t)] { $path } else {
//     for-each [$f/Typ] {
//       $p1 = { `.`; $path; }
//       widening(#f=`.`,#t=$t,#path=$p1) }}}


// tpl repl_path(#f,#t,#a) { 
//     if [$f=$t] { $a; } else {
//     if [$f/@nr < $t/@nr] {
//     for-each [$f/Typ] {
//       $p1 = { <Path { $f $path } }
//       widening(#f=`.`,#t=$t,#path=$p1) }}}

// // replace Loci vars in $w with respective terms from $a 
// tpl repl_loc_args(#w,#a) { for-each [$w] { $n=`name()`; 
//     if [($n = "Locus") and (count($a) >= @nr)] { 
//       $nr=`@nr`; `$a[position() = $nr]`; }
//     else { <$n { copy-of `@*`; for-each [*] { repl_loc_args(#w=`.`,#a) } }}}}


// // replace Locus var nr $f with term $t in $w
// tpl repl_loci(#w,#f,#t) { $n=`name()`; 
//     if [($n = "Locus") and (@nr = $f)] { $t; } else { <$n { 
//     copy-of `@*`; for-each [*] { repl_loci(#w=`.`,#f=$f,#t=$t) } }}}


// add the constructor href, $r tells if it is from redefinition
tpl absref(#elems,#r) { for-each [$elems] { 
    if [$r=1] { @redefaid=`@aid`; @absredefnr=`@nr`; }
    else { @kind=`@kind`; // @kind=mkind(#kind=`@kind`); 
           @nr=`@relnr`; @aid=`@aid`; @absnr=`@nr`; }} }

tpl abs(#k,#nr,#r) { 
   if [key($k,$nr)] { absref(#elems=`key($k,$nr)`,#r=$r); }
   else { 
     for-each [document($constrs,/)] { 
       if [key($k,$nr)] { absref(#elems=`key($k,$nr)`,#r=$r); }  
       else { 
         for-each [document($dcoconstrs,/)] { 
           absref(#elems=`key($k,$nr)`,#r=$r); } } } } }



// theorem, definition and scheme references
// add the reference's href, $c tells if it is from current article
tpl mkref(#aid,#nr,#k,#c) { 
      @kind=`$k`; // @kind=refkind(#kind=$k);
      @aid=`@aid`; @absnr=`@nr`; }

tpl getschref(#anr,#nr) {
    if [$anr>0] { for-each [document($schms,/)] {
	for-each [key('S',concat($anr,':',$nr))] { 
           mkref(#aid=`@aid`, #nr=$nr, #k="S"); }}}
    else { mkref(#aid=$aname,#nr=$nr,#k="S",#c="1"); }}

tpl getref(#k,#anr,#nr) {
    if [$anr>0] { for-each [document($thms,/)] {
	for-each [key($k,concat($anr,':',$nr))] { 
           mkref(#aid=`@aid`, #nr=$nr, #k=$k); }}}
    else { mkref(#aid=$aname,#nr=$nr,#k=$k,#c="1"); }}

// translate constructor kinds to their mizar/mmlquery names
tpl mkind(#kind) {
   choose { 
      when [$kind = 'M'] { "mode";}
      when [$kind = 'V'] { "attr";}
      when [$kind = 'R'] { "pred";}
      when [$kind = 'K'] { "func";}
      when [$kind = 'G'] { "aggr";}
      when [$kind = 'L'] { "struct";}
      when [$kind = 'U'] { "sel";}
 }}

// translate reference kinds to their mizar/mmlquery names
tpl refkind(#kind) {
  choose { 
      when [$kind = 'T'] { "th";}
      when [$kind = 'D'] { "def";}
      when [$kind = 'S'] { "sch";}
  }}

// add plevel explicitly to items and propositions
tpl [Conclusion | Assume | Take | Thesis | BlockThesis | 
    Case | Suppose | PerCases | SchemeFuncDecl | SchemePredDecl |
   JustifiedTheorem | DefTheorem | UnknownCorrCond | Coherence | 
   Compatibility | Consistency | Existence | Uniqueness | 
   Correctness | JustifiedProperty](#s) {
  copy { copy-of `@*`; @plevel=$s;  apply(#s=$s);}}

// numbering of private funcs and defs
// scheme funcs and preds are numbered by the standard @nr attribute and plevel
// adds the @plevel and @pfuncnr and @pprednr attributes
tpl [DefFunc](#s) { $c =`1 + count(preceding-sibling::DefFunc)`; 
    copy { copy-of `@*`; @plevel=$s; @pfuncnr=$c; apply(#s=$s);}}

tpl [DefPred](#s) { $c =`1 + count(preceding-sibling::DefPred)`; 
    copy { copy-of `@*`; @plevel=$s; @pprednr=$c; apply(#s=$s);}}


// numbering of constants
// adds the @plevel and @constnr attributes
tpl [Let | Given | TakeAsVar | Consider | Set | Reconsider](#s) {
    $c = prevconsts(#el=`.`); copy { copy-of `@*`; @plevel=$s;  
    @constnr=`1 + $c`; apply(#s=$s);}}

tpl prevconsts(#el) { for-each [$el] {
    `count(preceding-sibling::Reconsider/*[(name() = "Var") or 
    (name() = "LocusVar") or (name() = "Const") or (name() = "InfConst") 
    or (name() = "Num") or (name() = "Func") or (name() = "PrivFunc") 
    or (name() = "Fraenkel") or (name() = "QuaTrm") or (name() = "It") 
    or (name() = "ErrorTrm")]) +
     count(preceding-sibling::*[(name() = "Let") or (name() = "TakeAsVar") 
     or (name() = "Given") or (name() = "Consider") or (name() = "Set")]/Typ)`; }}

// serial numbering of embedded propositions
// adds the @plevel and @propnr  attributes
tpl [Assume/Proposition | Given/Proposition | Consider/Proposition |
     Reconsider/Proposition | Conclusion/Proposition | PerCases/Proposition |
     Case/Proposition | Suppose/Proposition | Conclusion/IterEquality |
    JustifiedTheorem/Proposition | DefTheorem/Proposition | 
    UnknownCorrCond/Proposition | Coherence/Proposition | 
    Compatibility/Proposition | Consistency/Proposition | 
    Existence/Proposition | Uniqueness/Proposition | 
    Correctness/Proposition | JustifiedProperty/Proposition](#s) {
    $s0 =  prevprops(#el=`..`); 
    $s1 =  `1 + $s0 + count(preceding-sibling::Proposition)`; //in this item
    copy { copy-of `@*`; @plevel=$s; @propnr=$s1; apply(#s=$s); }}

tpl [Conclusion/Now](#s) {
    $p0 =  prevprops(#el=`..`); $p1 = `1 + $p0`;
    $s0 =  prevblocks(#el=`.`); $s1 = `1 + $s0`;
    $s2 = { if [$s] { `concat($s,"_",$s1)`; } else { $s1; } }
    copy { copy-of `@*`; @plevel=$s; @newlevel=$s2; @propnr=$p1;
	   apply(#s=$s2); }}

// lemmas - both proof items and propositions
tpl [ IterEquality | Proposition](#s) {
    $s0 =  prevprops(#el=`.`); $s1 = `1 + $s0`;
    copy { copy-of `@*`; @plevel=$s;  @propnr=$s1; apply(#s=$s); }}

tpl [ Now ] { $p0 =  prevprops(#el=`.`); $p1 = `1 + $p0`;
    $s0 =  prevblocks(#el=`.`); $s1 = `1 + $s0`;
    $s2 = { if [$s] { `concat($s,"_",$s1)`; } else { $s1; } }
    copy { copy-of `@*`; @plevel=$s; @newlevel=$s2; @propnr=$p1; 
	   apply(#s=$s2); }}

tpl prevprops(#el) { for-each [$el] {
    `count(preceding-sibling::*[(name() = "Assume") or (name() = "Given") 
	or (name() = "Consider") or (name() = "Reconsider") 
	or (name() = "Conclusion") or (name() = "PerCases") 
	or (name() = "JustifiedTheorem") or (name() = "DefTheorem") 
	or (name() = "Case") or (name() = "Suppose") 
	or (name() = "UnknownCorrCond") or (name() = "Coherence") 
	or (name() = "Compatibility") or (name() = "Consistency") 
	or (name() = "Existence") or (name() = "Uniqueness")
	or (name() = "Correctness") or (name() = "JustifiedProperty")]/*[(name() = "Now") 
	or (name() = "Proposition") or (name() = "IterEquality")]) +
     count(preceding-sibling::*[(name() = "Now") or (name() = "Proposition") 
	or (name() = "IterEquality")])`; }}

// raise level - Now is handled separately
// adds the @plevel and @newlevel attributes.
// Each Definition and Registration inside such blocks create
// their own block to properly number correctness conditions. 
tpl [Proof|CaseBlock|SupposeBlock|PerCasesReasoning|DefinitionBlock|RegistrationBlock|NotationBlock|SchemeBlock|Definition|Registration](#s)
{ $s0 =  prevblocks(#el=`.`); $s1 = `1 + $s0`;
  $s2 = { if [$s] { `concat($s,"_",$s1)`; } else { $s1; } }
  copy { copy-of `@*`; @plevel=$s; @newlevel=$s2; apply(#s=$s2); }}

tpl [*](#s) { copy { apply [@*](#s=$s); apply(#s=$s); } }
tpl [@*] { copy-of `.`; }

// count previous blocks on the same level
tpl prevblocks(#el) { for-each [$el] {
    if [parent::*[(name() = "Conclusion") or (name() = "JustifiedTheorem")
       or (name() = "UnknownCorrCond") or (name() = "Coherence") 
       or (name() = "Compatibility") or (name() = "Consistency") 
       or (name() = "Existence") or (name() = "Uniqueness")
       or (name() = "Correctness") or (name() = "JustifiedProperty")]] { 
    for-each [parent::*] {
	`count(preceding-sibling::*[(name() = "Proof") or (name() = "Now") 
	or (name() = "CaseBlock") or (name() = "SupposeBlock") or 
	(name() = "PerCasesReasoning") or (name() = "Definition") or
	(name() = "Registration") or
	(name() = "DefinitionBlock") or (name() = "RegistrationBlock") or 
	(name() = "NotationBlock") or (name() = "SchemeBlock")]) +
	count(preceding-sibling::*[(name() = "Conclusion") 
	 or (name() = "JustifiedTheorem") or (name() = "UnknownCorrCond") 
	 or (name() = "Coherence") or (name() = "Compatibility") 
	 or (name() = "Consistency") or (name() = "Existence") 
	 or (name() = "Uniqueness") or (name() = "Correctness")
	 or (name() = "JustifiedProperty")]/*[(name() = "Proof") or 
	 (name() = "Now")])`; }}
    else  {
	`count(preceding-sibling::*[(name() = "Proof") or (name() = "Now") 
	or (name() = "CaseBlock") or (name() = "SupposeBlock") or 
	(name() = "PerCasesReasoning") or (name() = "Definition") or
	(name() = "Registration") or
	(name() = "DefinitionBlock") or (name() = "RegistrationBlock") or 
	(name() = "NotationBlock") or (name() = "SchemeBlock")]) +
         count(preceding-sibling::*[(name() = "Conclusion") 
	 or (name() = "JustifiedTheorem") or (name() = "UnknownCorrCond") 
	 or (name() = "Coherence") or (name() = "Compatibility") 
	 or (name() = "Consistency") or (name() = "Existence") 
	 or (name() = "Uniqueness") or (name() = "Correctness")
	 or (name() = "JustifiedProperty")]/*[(name() = "Proof") or (name() = "Now")])`;
}}}


stylesheet 1.0;

// XSLTXT (https://xsltxt.dev.java.net/) stylesheet adding 
// absolute names to Mizar constructors and references.
// This means that the "aid" (article name) and the "absnr"
// (serial number in its article) attributes are added,
// and the "kind" attribute is added if not present.

// To produce standard XSLT from this do e.g.: 
// java -jar xsltxt.jar toXSL addabsrefs.xsltxt > addabsrefs.xsl

// Then e.g.: xalan -XSL addabsrefs.xsl <ordinal2.xml >ordinal2.xml1
//        or: xsltproc addabsrefs.xsl ordinal2.xml >ordinal2.xml1

// TODO: 
//       article numbering in Ref?
//       absolute definiens numbers for thesisExpansions?
//       add @nr to canceled
//       Constructor should know its serial number! - needed in defs

// NOTES: constructor disambiguation is done using the absolute numbers
//        (attribute 'nr' and 'aid' of the Constructor element.
//        This info for Constructors not defined in the article is
//        taken from the .atr file (see variable $constrs)

output method=xml;

// keys for fast constructor and reference lookup
key "M" [Constructor[@kind='M']] `@relnr` ;
key "L" [Constructor[@kind='L']] `@relnr` ;
key "V" [Constructor[@kind='V']] `@relnr` ;
key "R" [Constructor[@kind='R']] `@relnr` ;
key "K" [Constructor[@kind='K']] `@relnr` ;
key "U" [Constructor[@kind='U']] `@relnr` ;
key "G" [Constructor[@kind='G']] `@relnr` ;

key "T" [/Theorems/Theorem[@kind='T']] `concat(@articlenr,':',@nr)`;
key "D" [/Theorems/Theorem[@kind='D']] `concat(@articlenr,':',@nr)`;
key "S" [/Schemes/Scheme] `concat(@articlenr,':',@nr)`;

$lcletters= { "abcdefghijklmnopqrstuvwxyz"; }
$ucletters= { "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; } 

// name of current article (upper case)
#aname= { `string(/*/@aid)`; }

// name of current article (lower case)
#anamelc= { `translate($aname, $ucletters, $lcletters)`; }

// .atr file with imported constructors
#constrs=  { `concat($anamelc, '.atr')`; }

// .dco file with exported constructors
#dcoconstrs=  { `concat($anamelc, '.dco')`; }

// .eth file with imported theorems
#thms=  { `concat($anamelc, '.eth')`; }

// .esh file with imported schemes
#schms=  { `concat($anamelc, '.esh')`; }


tpl [Pred](#i) { 
  if [@kind='P'] {  copy-of `.`; }
  else { <Pred {  
   abs(#k=`@kind`, #nr=`@nr`); apply; }}}

tpl [Func] { 
  if [@kind='F']  {  copy-of `.`; }
  else { <Func {  
   abs(#k=`@kind`, #nr=`@nr`); apply; }}}

// Adjective
tpl [Adjective] { <Adjective 
    { copy-of `@*`; abs(#k="V", #nr=`@nr`); apply; }}

// Types
tpl [Typ] { 
   <Typ {
   if [@kind="M"] { abs(#k="M", #nr=`@nr`); }
   else { if [@kind="G"] { abs(#k="L", #nr=`@nr`); }
     else { `@kind`; }}
   apply;}
}

tpl [From] { <From { copy-of `@*`;
             getschref(#anr=`@articlenr`, #nr=`@nr`);
             apply; }}

tpl [Ref] { if [not(@articlenr)] { copy-of `.`; }
            else { <Ref {  copy-of `@*`;
    getref(#k=`@kind`, #anr=`@articlenr`, #nr=`@nr`);} }}

// add absolute numbers to these (they are kind-dependent)
tpl [Theorem|Constructor|Pattern] { $n=`name()`; <$n { copy-of `@*`;
             $k=`@kind`; @aid=$aname;
             @nr=`1 + count(preceding::*[(name()=$n) and (@kind=$k)])`;
	     if [@redefnr > 0] { abs(#k=$k,#nr=`@redefnr`,#r="1"); } 
             apply; }}

tpl [Scheme|Definiens|RCluster|CCluster|FCluster] { 
             $n=`name()`; <$n { copy-of `@*`; @aid=$aname;
             @nr=`1 + count(preceding::*[(name()=$n)])`;
             apply; }}

tpl [Field] { <Field 
    { copy-of `@*`; abs(#k="U", #nr=`@nr`); apply; }}

// add the constructor href, $r tells if it is from redefinition
tpl absref(#elems,#r) { for-each [$elems] { 
    if [$r=1] { @redefaid=`@aid`; @absredefnr=`@nr`; }
    else { @kind=`@kind`; // @kind=mkind(#kind=`@kind`); 
           @nr=`@relnr`; @aid=`@aid`; @absnr=`@nr`; }} }

tpl abs(#k,#nr,#r) { 
   if [key($k,$nr)] { absref(#elems=`key($k,$nr)`,#r=$r); }
   else { 
     for-each [document($constrs,/)] { 
       if [key($k,$nr)] { absref(#elems=`key($k,$nr)`,#r=$r); }  
       else { 
         for-each [document($dcoconstrs,/)] { 
           absref(#elems=`key($k,$nr)`,#r=$r); } } } } }



// theorem, definition and scheme references
// add the reference's href, $c tells if it is from current article
tpl mkref(#aid,#nr,#k,#c) { 
      @kind=`$k`; // @kind=refkind(#kind=$k);
      @aid=`@aid`; @absnr=`@nr`; }

tpl getschref(#anr,#nr) {
    if [$anr>0] { for-each [document($schms,/)] {
	for-each [key('S',concat($anr,':',$nr))] { 
           mkref(#aid=`@aid`, #nr=$nr, #k="S"); }}}
    else { mkref(#aid=$aname,#nr=$nr,#k="S",#c="1"); }}

tpl getref(#k,#anr,#nr) {
    if [$anr>0] { for-each [document($thms,/)] {
	for-each [key($k,concat($anr,':',$nr))] { 
           mkref(#aid=`@aid`, #nr=$nr, #k=$k); }}}
    else { mkref(#aid=$aname,#nr=$nr,#k=$k,#c="1"); }}

// translate constructor kinds to their mizar/mmlquery names
tpl mkind(#kind) {
   choose { 
      when [$kind = 'M'] { "mode";}
      when [$kind = 'V'] { "attr";}
      when [$kind = 'R'] { "pred";}
      when [$kind = 'K'] { "func";}
      when [$kind = 'G'] { "aggr";}
      when [$kind = 'L'] { "struct";}
      when [$kind = 'U'] { "sel";}
 }}

// translate reference kinds to their mizar/mmlquery names
tpl refkind(#kind) {
  choose { 
      when [$kind = 'T'] { "th";}
      when [$kind = 'D'] { "def";}
      when [$kind = 'S'] { "sch";}
  }}

tpl [*] { copy { apply [@*]; apply; } }
tpl [@*] { copy-of `.`; }



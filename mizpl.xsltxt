stylesheet "1.0" 
extension-element-prefixes = "exsl exsl-str xt";
xmlns exsl "http://exslt.org/common"; 
xmlns exsl-str "http://exslt.org/strings";
xmlns xt "http://www.jclark.com/xt";

// XSLTXT (https://xsltxt.dev.java.net/) stylesheet taking 
// Mizar XML terms, formulas and types to Prolog TSTP-like format.

// To produce standard XSLT from this do e.g.: 
// java -jar xsltxt.jar toXSL mizpl.xsltxt >mizpl.xsl

// ##NOTE: TPTP types 'theorem' and 'definition' are wider
//   than in Mizar. Mizar 'property' is also exported as
//   TPTP 'theorem', and there are various Mizar items
//   exported as TPTP 'definition'. Use the 'mptp_info' slot
//   to determine the Mizar item kind.

output method=text;

strip-space "*";

// this needs to be set to 1 for processing MML files
#mml = { "0"; }
// nr. of clusters in Typ
// this is set to 1 for processing MML files
#cluster_nr = { if [$mml = "0"] { "2"; } else { "1"; }}
// symbols, take care, the spaces are sometimes (e.g. for '~')
// needed for correct Prolog parsing
#not_s = { "~ "; }
#non_s = { "~ "; }
#and_s = { " & "; }
#imp_s = { " => "; }
#equiv_s = { " <=> "; }
#or_s = { " | "; }
#srt_s = { "sort"; }
#frank_s = { "all"; }
#eq_s = { " = "; }

// this will ensure failure of Prolog parsing
#fail = { "zzz k l-**)))))))"; }

$lcletters= { "abcdefghijklmnopqrstuvwxyz"; }
$ucletters= { "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; } 

tpl lc(#s) { `translate($s, $ucletters, $lcletters)`; }
tpl uc(#s) { `translate($s, $lcletters, $ucletters)`; }

// this is for lookup of selectors for Abstractness property
key "G" [Constructor[@kind='G']] `@nr` ;

// lookup for local constants
key "C" [Let|Given|TakeAsVar|Consider|Set|Reconsider] `@plevel` ;

// lookup for propositions
key "E" [Proposition|IterEquality|Now] `concat(@nr,":",@plevel)` ;

// lookup for scheme functors and predicates
key "f" [SchemeFuncDecl] `concat(@nr,":",@plevel)` ;
key "p" [SchemePredDecl] `concat(@nr,":",@plevel)` ;

// lookup for private functors and predicates
key "pf" [DefFunc] `concat(@nr,":",@plevel)` ;
key "pp" [DefPred] `concat(@nr,":",@plevel)` ;

// name of current article (upper case)
#aname= { `string(/*/@aid)`; }

// name of current article (lower case)
#anamelc= { lc(#s=$aname); }

// Formulas

// #i is nr of the bound variable, 1 by default 
// empty list can be after ':' for type 'set'
tpl [For](#i,#pl,#k) { 
  $j = { if [$i>0] { `$i + 1`;} else { "1"; } }
  "!["; pvar(#nr=$j); ": "; apply[Typ[1]](#i=$j,#pl=$pl); "]: "; 
  apply[*[2]](#i=$j,#pl=$pl); }

// need to put brackets around PrivPred here - may contain For
tpl [Not](#i,#pl) { $not_s; 
    if [For|PrivPred] { "("; apply[*[1]](#i=$i,#pl=$pl); ")"; } 
    else { apply[*[1]](#i=$i,#pl=$pl); }}
tpl [And](#i,#pl) { "( "; 
    ilist(#separ=$and_s, #elems=`*`, #i=$i,#pl=$pl); " )"; }
// here we differ from Mizar and ILF - all 'V' are turned into 'sort'
// ##GRM: Sch_Pred : "p" Number "_" Scheme_Name
tpl [Pred](#i,#pl) { 
      if [@kind='V']  { 
         $srt_s; "("; 
         apply[*[position() = last()]](#i=$i,#pl=$pl); ","; absc(#el=`.`); 
         if [count(*)>1] { "("; 
	    ilist(#separ=",", #elems=`*[position() < last()]`, #i=$i,#pl=$pl); 
            ")"; }
         ")"; }
      else { 
	 if [(@kind='R') and (@absnr=1) and (@aid="HIDDEN")] {
	    "( "; apply[*[1]](#i=$i,#pl=$pl); $eq_s; 
	    apply[*[2]](#i=$i,#pl=$pl); " )"; }
	 else {
          if [@kind='P'] { abs_fp(#k="p",#el=`.`); }
	  else { absc(#el=`.`); }
          if [count(*)>0] { "("; 
	     ilist(#separ=",", #elems=`*`, #i=$i,#pl=$pl); ")"; }
	 } }}

tpl [PrivPred](#i,#pl) { apply[*[position() = last()]](#i=$i,#pl=$pl); }
// empty list can be here - then it can be replaced by 'true'
tpl [Is](#i,#pl) { $srt_s; "("; apply[*[1]](#i=$i,#pl=$pl); ","; 
		   apply[*[2]](#i=$i,#pl=$pl); ")"; }
tpl [Verum](#i,#pl) { "$true"; }
tpl [ErrorFrm](#i,#pl) { "errorfrm"; }

// Terms
// #p is the parenthesis count
tpl [Var](#i,#pl) { pvar(#nr=`@nr`); } 
tpl [LocusVar](#i,#pl) { ploci(#nr=`@nr`); } 
tpl [FreeVar](#i,#pl) { $fail; }
tpl [Const](#i,#pl) { pconst(#nr=`@nr`,#pl=$pl); }
tpl [InfConst](#i,#pl) { $fail; }
tpl [Num](#i,#pl) {  `@nr`; }
// ##GRM: Sch_Func : "f" Number "_" Scheme_Name
tpl [Func](#i,#pl) { 
    if [@kind='F'] { abs_fp(#k="f",#el=`.`); }
    else { absc(#el=`.`); }
    if [count(*)>0] { "("; ilist(#separ=",", #elems=`*`, #i=$i,#pl=$pl); ")"; } }

tpl [PrivFunc](#i,#pl) { apply[*[position() = 1]](#i=$i,#pl=$pl); }
tpl [ErrorTrm](#i,#pl) { "errortrm"; }
tpl [Fraenkel](#i,#pl) { 
     $j = { if [$i>0] { $i;} else { "0"; } }
     $frank_s; "(["; 
     for-each [Typ] { 
       $k = `$j + position()`;
       pvar(#nr=$k); ": "; apply[.](#i=$k,#pl=$pl); 
       if [not(position()=last())] { ","; } }
     "],";
     $l = `$j + count(Typ)`;
     apply[*[position() = last() - 1]](#i=$l,#pl=$pl); ","; 
     apply[*[position() = last()]](#i=$l,#pl=$pl); ")";
}

// Types - the list of attributes and radix type in square brackets
// m1_hidden is not printed; we expect 'L' instead of 'G'
tpl [Typ](#i,#pl) { 
      if [@kind='errortyp'] { "errortyp"; }
      else { if [(@kind="M") or (@kind="L")] {
        $radix = { if [(@aid = "HIDDEN") and (@kind="M") and (@nr="1")]
                         { "0"; } else { "1"; } }
        $adjectives = { `count(*[1]/*)`; }
        if [($adjectives + $radix) = 0] { "$true"; }
        else {
          if [($adjectives + $radix) > 1] { "( "; }
          if [$adjectives > 0] {
             apply[*[1]](#i=$i,#pl=$pl); 
             if [$radix > 0] { $and_s; } }
          if [($radix > 0)] { 
             absc(#el=`.`);
             if [count(*) > $cluster_nr ] { 
               "(";
               ilist(#separ=",", #elems=`*[position() > $cluster_nr]`, 
	             #i=$i, #pl=$pl); 
               ")"; } }
          if [($adjectives + $radix) > 1] { " )"; }
         }
      }
      else { $fail; } }
}

tpl [Cluster](#i,#pl) { ilist(#separ=$and_s, #elems=`*`, #i=$i,#pl=$pl); }
tpl [Adjective](#i,#pl) { if [@value="false"] { $non_s; } absc(#el=`.`);
    if [count(*)>0] { "("; ilist(#separ=",", #elems=`*`, #i=$i, #pl=$pl); 
		      ")"; } }

tpl addp(#pl) { if [string-length($pl)>0] { "_"; $pl; }}

// concat number and level
tpl propname(#n,#pl) { "e"; $n; addp(#pl=$pl); }
tpl abspropname(#n,#pl) { propname(#n=$n,#pl=$pl); "__"; $anamelc; }
tpl lemmaname(#n) { "l"; $n; "_"; $anamelc; } 
tpl plname(#n,#pl) {
    if [string-length($pl)>0] { propname(#n=$n, #pl=$pl); }
    else { lemmaname(#n=$n); } }

// SchemePremises implies SchemeThesis
// the proof might rather be 'implication intro'
tpl [SchemeBlock] { 
    $sname = `concat('s',@schemenr,'_',$anamelc)`;
    "fof("; $sname; ",theorem,"; "(";
    if [SchemePremises/Proposition] { "( "; 
       ilist( #separ=$and_s, #elems=`SchemePremises/Proposition/*`,
	      #pl=`@newlevel`); " ) "; $imp_s; }
    apply[Proposition/*](#pl=`@newlevel`); ")";
    ",file("; $anamelc; ","; $sname; "),[mptp_info("; 
    `@schemenr`; ",[],"; "scheme,position("; `@line`; ","; 
    `@col`; "),["; `@schemenr`; "])"; 
    // only Proof and SkippedProof
    try_inference( #el=`*[position() = (last() - 1)]`,#pl=`@newlevel`); 
    "]).\n"; }

tpl [JustifiedTheorem/Proposition] { "fof("; absr(#el=`..`); ",theorem,";
    apply(#pl=`@plevel`);
    ",file("; $anamelc; ","; absr(#el=`..`); "),[mptp_info("; 
    `../@nr`; ",[],"; "theorem,position("; `@line`; ","; 
    `@col`; "),["; if [@nr] { `@nr`;} else { "0";} "])"; 
    try_inference(#el=`../*[2]`,#pl=`@plevel`, #prnr=`@propnr`);
    "]).\n"; }

tpl [Theorem] { "fof("; absr(#el=`.`); ",";
    $kword = { if [@kind="T"] { "theorem"; } else {
       if [@kind="D"] { "definition"; } else { $fail; } } }
    $kword; ",";
    apply; ",file("; lc(#s=`@aid`); ",";
    absr(#el=`.`); "),[mptp_info("; `@nr`; ",[],"; $kword; 
    ",position(0,0),[0])]).\n"; }

// ##GRM: Mptp_Info : "mptp_info(" 
//           Item_Number "," Level "," Item_Kind ","
//           Position "," "[" Item_Arguments "]" ")" .
tpl [DefTheorem/Proposition] { "fof("; absr(#el=`..`); ",definition,";
    apply(#pl=`@plevel`);
    ",file("; $anamelc; ","; absr(#el=`..`); "),[mptp_info("; 
    `../@nr`; ",[],"; "definition,position("; `@line`; ","; 
    `@col`; "),["; if [@nr] { `@nr`;} else { "0";} "]"; ")]).\n"; }

tpl [Proposition] { 
    $pname = plname(#n=`@propnr`, #pl=`@plevel`);
    "fof(";  $pname; ","; 
    if [following-sibling::*[1][name() = "By" or name() = "From" or
      name() = "Proof"]] { "lemma-derived,"; } else { "unknown,"; }
    apply(#pl=`@plevel`); ",file("; $anamelc; 
    ","; $pname; "),[mptp_info("; `@propnr`; ",["; 
    `translate(@plevel,"_",",")`; "],proposition,position("; `@line`; ","; 
    `@col`; "),["; if [@nr] { `@nr`;} else { "0";} "])";
    try_inference(#el=`following-sibling::*[1]`,#pl=`@plevel`,#prnr=`@propnr`);
    "]).\n"; }

tpl [Now] { $pname = plname(#n=`@propnr`, #pl=`@plevel`);
    "fof(";  $pname; ","; "lemma-derived,";
    apply[BlockThesis/*](#pl=`@plevel`); ",file("; $anamelc; 
    ","; $pname; "),[mptp_info("; `@propnr`; ",["; 
    `translate(@plevel,"_",",")`; "],proposition,position("; `@line`; ","; 
    `@col`; "),["; if [@nr] { `@nr`;} else { "0";} "]),"; 
     proofinfer(#el=`.`,#pl=`@plevel`,#prnr=`@propnr`);
     "]).\n"; }

tpl [IterEquality] { $pname = plname(#n=`@propnr`, #pl=`@plevel`);
    "fof(";  $pname; ","; "lemma-derived,";
    "( "; apply[*[1]](#pl=`@plevel`); $eq_s; 
    apply[IterStep[position() = last()]/*[1]](#pl=`@plevel`); " )";
    ",file("; $anamelc; 
    ","; $pname; "),[mptp_info("; `@propnr`; ",["; 
    `translate(@plevel,"_",",")`; "],proposition,position("; `@line`; ","; 
    `@col`; "),["; if [@nr] { `@nr`;} else { "0";} "]),"; 
     proofinfer(#el=`.`,#pl=`@plevel`,#prnr=`@propnr`);
     "]).\n"; 
     apply[IterStep]; }

tpl [IterStep] { $pname = plname(#n=`@propnr`, #pl=`@plevel`);
    "fof(";  $pname; ","; "lemma-derived,"; "( "; 
    if [name(preceding-sibling::*[1])="IterStep"] {
       apply[preceding-sibling::*[1]/*[1]](#pl=`@plevel`); }
    else { apply[preceding-sibling::*[1]](#pl=`@plevel`); } 
    $eq_s; apply[*[1]](#pl=`@plevel`); " )";
    ",file("; $anamelc; 
    ","; $pname; "),[mptp_info("; `@propnr`; ",["; 
    `translate(@plevel,"_",",")`; "],proposition,position("; `*[2]/@line`; ",";
    `*[2]/@col`; "),["; if [@nr] { `@nr`;} else { "0";} "])"; 
     try_inference(#el=`*[2]`,#pl=`@plevel`,#prnr=`@propnr`);
     "]).\n"; }

tpl try_inference(#el,#pl,#prnr) { for-each [$el] {
    if [name() = "By"] { ",";
       byinfer(#el=`.`,#pl=$pl,#prnr=$prnr); }
    else { if [name() = "From"] { ",";
       frominfer(#el=`.`,#pl=$pl,#prnr=$prnr); }
    else { if [name() = "Proof"] { ",";
       proofinfer(#el=`.`,#pl=$pl,#prnr=$prnr); }
    else { if [name() = "SkippedProof"] { ",";
       skippedinfer(#el=`.`,#pl=$pl,#prnr=$prnr); }
}}}}}


tpl skippedinfer(#el,#pl,#prnr) { "inference(mizar_skipped_proof,[],[])"; }

// assumes By
tpl byinfer(#el,#pl,#prnr) { for-each [$el] {
    "inference(mizar_by,[],["; refs(#el=`.`,#pl=$pl,#prnr=$prnr); "])"; }}

// handles Refs for From, (possibly linked) By and ThesisExpansions
tpl refs(#el,#pl,#prnr) { for-each [$el] {
    if [@linked] { 
       if [name(..)="IterStep"] {
	  plname(#n=`../../@propnr - 1`,#pl=`../../@plevel`); } 
       else { if [$prnr>1] {
	  plname(#n=`$prnr - 1`,#pl=$pl); } else { $fail; } }
      if [Ref] { ","; } }
    else { if [name()="From"] { 
	 sch_instname(#el=`.`, #pl=$pl, #prnr=$prnr); 
	 if [Ref] { ","; } } }
    for-each [Ref] { refname(#el=`.`,#pl=$pl); 
	if [not(position()=last())] { ","; } }
}}


tpl [FuncInstance](#pl) { $k = `@kind`;
    sch_fpname(#k="f",#nr=`@instnr`,#schnr=`@instschemenr`, #aid=`@instaid`); 
    "/";
    // instantiated to other functor
    if [$k] { choose { 
       when [$k="K"] { absc(#el=`.`); }
       when [$k="F"] { abs_fp(#k="f",#el=`.`); }
       when [$k="H"] { "("; priv_def(#k="pf",#nr=`@nr`,#pl=$pl); ")";}
       otherwise { $fail; }
    }}
    // instantiated to term
    else { if [*[1]] { "([] : "; apply[*[1]](#pl=$pl); ")"; } else { $fail; } } }

tpl [PredInstance](#pl) { $k = `@kind`;
    sch_fpname(#k="p",#nr=`@instnr`,#schnr=`@instschemenr`, #aid=`@instaid`); 
    "/";
    choose { 
	     when [$k="R"] { absc(#el=`.`); }
	     when [$k="P"] { abs_fp(#k="p",#el=`.`); }
	     when [$k="S"] { "("; priv_def(#k="pp",#nr=`@nr`,#pl=$pl); ")";}
	     otherwise { $fail; }
    }}

tpl [SchemeInstantiation](#pl) { "[";
    for-each [FuncInstance | PredInstance] { apply[.](#pl=$pl); 
	     if [not(position()=last())] { ","; } }
    "]"; }

// assumes From, introduces a unique name for this scheme instance
// ##GRM: Scheme_Inference : 
//          "inference(mizar_from,[scheme_instance(" 
//          Scheme_Instance_Name "," Scheme_Name "," Proposition_Name
//          "," Aid "," Scheme_Instantiation ")],[" 
//          Scheme_Instance_Name [ "," References ] "])" .   
tpl frominfer(#el,#pl,#prnr) { for-each [$el] {
    "inference(mizar_from,[scheme_instance("; 
    sch_instname(#el=`.`, #pl=$pl, #prnr=$prnr); ",";
    absr(#el=`.`); ","; plname(#n=$prnr,#pl=$pl); ","; $anamelc; ",";
    apply[SchemeInstantiation](#pl=$pl); ")],[";
    refs(#el=`.`,#pl=$pl,#prnr=$prnr); "])";
}}


// ###TODO: finish the description!! 
// assumes Proof, Now or IterEquality,
// ##GRM: Proof_Inference : 
//          "inference(mizar_proof,[proof_level(" Level ")], 
//          [ References ] ")" .   
tpl proofinfer(#el,#pl,#prnr) { for-each [$el] {
    "inference(mizar_proof,[proof_level(["; 
    if [not(@newlevel)] { $fail; } else {`translate(@newlevel,"_",",")`; }
     "])],["; 
    for-each [.//By[((name(preceding-sibling::*[1])="Proposition") 
	              or (name(..)="IterStep"))
	            and ((@linked="true") or (count(Ref)>0))] 
	     | .//From[((name(preceding-sibling::*[1])="Proposition") 
	                 or (name(..)="IterStep"))]
             | .//ThesisExpansions[count(Ref)>0]] { 
      if [name()="ThesisExpansions"] { refs( #el=`.`); }
      else { if [name(..)="IterStep"] {  
	     refs( #el=`.`,#pl=`../@plevel`,#prnr=`../@propnr`); }
        else {
	      refs( #el=`.`,#pl=`preceding-sibling::*[1]/@plevel`,
		    #prnr=`preceding-sibling::*[1]/@propnr`); }}
      if [not(position()=last())] { ","; } }
    "])";
}}


// create name and info for a scheme instance
tpl sch_instname(#el,#pl,#prnr) { for-each [$el] { absr(#el=`.`); 
    "__"; abspropname(#n=$prnr,#pl=$pl); }}

// uncomment apply[Proposition] if not used explicit descent
tpl [Let|Given|TakeAsVar|Consider|Set] { $cnr = `@constnr`; $pl=`@plevel`; 
    $rnm = lc(#s=`name()`);
    for-each [Typ] {
      $nr = `$cnr + position() - 1`; $nm =  { "c"; $nr; addp(#pl=$pl); }
      $levl = { ",["; `translate($pl,"_",",")`; "],";}
      "fof(dt_";  $nm; ",sort,"; $srt_s; "("; $nm; ",";
      apply[.](#pl=$pl); ")"; ",file("; $anamelc; ","; $nm;
      "),[mptp_info("; $nr; $levl; "constant,position(0,0),["; $rnm; 
      ",type])]).\n"; 
      if [($rnm = "takeasvar") or ($rnm = "set")] {
	 "fof(de_";  $nm; ",definition,"; "( "; $nm; $eq_s; 
	 apply[../*[not(name() = "Typ")]](#pl=$pl); " )";
	 ",file("; $anamelc; ","; $nm; "),[mptp_info("; $nr; $levl;
	 "constant,position(0,0),["; $rnm; ",equality])]).\n"; } 
    }
//    apply[Proposition];
}

tpl [Reconsider] { $cnr = `@constnr`; $pl=`@plevel`; 
    for-each [Var|LocusVar|Const|InfConst|Num|Func|PrivFunc|Fraenkel|
	      QuaTrm|It|ErrorTrm] {
      $nr = `$cnr + position() - 1`; $nm =  { "c"; $nr; addp(#pl=$pl); }
      $levl = { ",["; `translate($pl,"_",",")`; "],";}
      "fof(dt_";  $nm; ",sort,"; $srt_s; "("; $nm; ",";
      apply[../Typ](#pl=$pl); ")"; ",file("; $anamelc; ","; $nm;
      "),[mptp_info("; $nr; $levl; 
      "constant,position(0,0),[reconsider,type])]).\n";
      "fof(de_";  $nm; ",definition,"; "( "; $nm; $eq_s; 
      apply[.](#pl=$pl); " )"; ",file("; $anamelc; ","; $nm; "),[mptp_info("; 
      $nr; $levl; "constant,position(0,0),[reconsider,equality])]).\n";
}}

// The argument types of scheme functors are forgotten by Mizar
// so we do not use them either and use $true
tpl [SchemeFuncDecl] { $pl=`@plevel`; 
    $nm =  { "f"; `@nr`; addp(#pl=$pl); }
    $levl = { ",["; `translate($pl,"_",",")`; "],";}
    $l = `count(ArgTypes/Typ)`;
    "fof(dt_";  $nm; ",sort,"; 
    if [$l > 0] { 
       "!["; for-each [ArgTypes/Typ] { 
		      ploci(#nr=`position()`); " : $true"; 
		      if [not(position()=last())] { ","; } }
       "]: "; }
    $srt_s; "("; $nm;
    if [$l > 0] { "("; arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
    ","; apply[Typ](#pl=$pl); ")";
    ",file("; $anamelc; ","; $nm; "),[mptp_info("; `@nr`; $levl;
    "functor,position(0,0),[scheme,type])]).\n"; }


// "M" | "L" | "V" | "R" | "K" | "U" | "G"
tpl [Constructor] { 
    $lkind = { lc(#s=`@kind`); } 
// the type hierarchy formula for "M" | "L" | "K" | "U" | "G"
    if [(@kind='M') or (@kind='L') or (@kind='K') or 
        (@kind='U') or (@kind='G')] {
      "fof(dt_";  absc1(#el=`.`); ",sort,";
      apply[ArgTypes];
      $l = `1 + count(ArgTypes/Typ)`;
      if [(@kind='M') or (@kind='L')] {
        "!["; ploci(#nr=$l); " : "; "$true"; "]: ("; 
        $srt_s; "("; ploci(#nr=$l); ","; absc1(#el=`.`); 
        if [$l > 1] { "("; 
           arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
        ")"; $imp_s;
        if [count(Typ) = 0] { $srt_s; "("; ploci(#nr=$l); ",$true)"; }

        if [count(Typ) > 1] { "("; }
        for-each [Typ] {
           $srt_s; "("; ploci(#nr=$l); ","; apply[.]; ")";
           if [not(position()=last())] { $and_s; }
        }
        if [count(Typ) > 1] { ")"; }
        ")";
      }  else  { 
      if [(@kind='K') or (@kind='U') or (@kind='G')] {
        $srt_s; "("; absc1(#el=`.`);
        if [$l > 1] { "("; 
           arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
	",";
        apply[Typ]; ")";
      } }
      ",file("; lc(#s=`@aid`); ",";
      absc1(#el=`.`); "),[mptp_info("; `@nr`; ",[],"; $lkind; 
      ",position(0,0),[ctype])]).\n"; }
    apply[Properties](#el=`.`);
    if [@kind='G'] { free_prop(#el=`.`); }
    if [(@kind='M') or (@kind='L')] {	 existence(#el=`.`); }
    if [@redefnr > 0] { redefinition(#el=`.`); }
}

tpl existence(#el) { for-each [$el] {
      $lkind = { lc(#s=`@kind`); } 
      "fof(existence_"; absc1(#el=`.`); ",lemma-derived,";
      apply[ArgTypes]; 
      $l = `1 + count(ArgTypes/Typ)`;
      "? ["; ploci(#nr=$l); " : "; "$true"; "]: "; 
      $srt_s; "("; ploci(#nr=$l); ","; absc1(#el=`.`); 
      if [$l > 1] { "("; 
           arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
      ")";
      ",file("; lc(#s=`@aid`); ",";
      absc1(#el=`.`); "),[mptp_info("; `@nr`; ",[],"; $lkind; 
      ",position(0,0),[existence])]).\n"; 
}}


// ##GRM: Redef_Info : "redefinition(" Redefined_Constr_Nr "," 
//           Redefined_Constr_Kind "," Redefined_Constr_Aid "," 
//           Redefined_Constr_Name ")" .
tpl redefinition(#el) { 
    $lkind = { lc(#s=`$el/@kind`); }
    $redaid = { lc(#s=`$el/@redefaid`); }
    $absn = absc1(#el=$el); $n = `$el/@nr`;
    $f = { lc(#s=`$el/@aid`); }
    $s = `@superfluous`;
    for-each [$el] {
      "fof(redefinition_"; $absn; ",definition,";
      apply[ArgTypes]; 
      $l0 = `count(ArgTypes/Typ)`;
      if [(@kind = 'K') or (@kind = 'R')] { 
        "( "; absc1(#el=`.`); 
	if [$l0 > 0] { "("; arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
	if [@kind = 'K'] { $eq_s; } else { $equiv_s; }
        absredef(#el=`.`); 
	if [$l0 > $s] { "("; 
           arglist(#separ=",",#elems=`ArgTypes/Typ[position() > $s]`,#s=$s); 
	   ")";
	} ")";
      } else {
      if [(@kind = 'V') or (@kind = 'M')] {
	 $l = { if [@kind = 'V'] { $l0; } else { `$l0 + 1`; } }
	 if [@kind = 'M'] { "!["; ploci(#nr=`$l`); ": "; 
	 // This is too strong, the original type can hardly get
	 // the redefinition's result type
	 // apply[Typ]; 
	 "$true"; "]: "; }
	 "( "; $srt_s; "("; ploci(#nr=$l); ","; absc1(#el=`.`);
	 if [$l>1] { 
            "("; arglist(#separ=",",#elems=`ArgTypes/Typ[position() < $l]`);
            ")"; 
	 }
	 ")"; $equiv_s; $srt_s; "("; ploci(#nr=$l); ","; 
	 absredef(#el=`.`); 
	 if [($l - $s) > 1] { "("; 
	    arglist(#separ=",",#elems=`ArgTypes/Typ[(position() > $s) 
                                  and (position() < $l)]`, #s=$s); ")"; 
	 } "))"; 
      }}
      ",file("; $f; ","; $absn; "),[mptp_info("; $n; ",[],"; $lkind; 
      ",position(0,0),[redefinition("; `@absredefnr`; ","; $lkind; 
      ","; $redaid; ","; absredef(#el=`.`); ")])]).\n"; }
}

// free property - this is rather definition than theorem
// g(x1,x2) = g(x3,x4) implies (x1 = x2 and x3 = x4)
tpl free_prop(#el) { 
    $lkind = { lc(#s=`$el/@kind`); }
    $absn = absc1(#el=$el); $n = `$el/@nr`;
    $f = { lc(#s=`$el/@aid`); }
    for-each [$el] {
      "fof(free_"; $absn; ",definition,";
      apply[ArgTypes]; 
      $s=`count(ArgTypes/Typ)`;
      "!["; for-each [ArgTypes/Typ] { 
          ploci(#nr=`position() + $s`); " : $true"; 
          if [not(position()=last())] { ","; } }
       "]: ";
      "(( "; absc1(#el=`.`); "("; 
      arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; $eq_s; 
      absc1(#el=`.`); "("; 
      arglist(#separ=",",#elems=`ArgTypes/Typ`,#s=$s); "))"; $imp_s; "( ";
      for-each [ArgTypes/Typ] { 
	  $p=`position()`;
	  "( "; ploci(#nr=$p); $eq_s;  ploci(#nr=`$p+$s`); ")";
	  if [not($p=last())] { $and_s; }
      }
      "))";
      ",file("; $f; ","; $absn; "),[mptp_info("; $n; ",[],"; 
      $lkind; ",position(0,0),[property(free)])]).\n"; }
}

tpl [Properties](#el) { 
    $a1 = `@propertyarg1`; $a2=`@propertyarg2`;
    $lkind = { lc(#s=`$el/@kind`); }
    $absn = absc1(#el=$el); $n = `$el/@nr`;
    $f = { lc(#s=`$el/@aid`); }
    for-each [*] {
      $nm = { lc(#s=`name()`); }
      "fof(";  $nm; "_"; $absn; ",theorem,";
      apply[.](#el=$el,#arg1=$a1,#arg2=$a2);
      ",file("; $f; ","; $absn; "),[mptp_info("; $n; ",[],"; 
      $lkind; ",position(0,0),[property("; $nm; ")])]).\n"; }
}


tpl [UnexpectedProp](#el,#arg1,#arg2) { "$true"; } 

tpl symmetry(#el,#arg1,#arg2,#anti) { for-each [$el] {
    apply[ArgTypes]; "( "; absc1(#el=`.`); "("; 
    arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; $imp_s;
    if [$anti=1] { $not_s; } absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,#lim=`count(ArgTypes/Typ)`); 
    "))"; }}

tpl [Symmetry](#el,#arg1,#arg2) { symmetry(#el=$el,#arg1=$arg1,#arg2=$arg2); } 
tpl [Antisymmetry](#el,#arg1,#arg2) { 
    symmetry(#el=$el,#arg1=$arg1,#arg2=$arg2,#anti="1"); } 

tpl reflexivity(#el,#arg1,#arg2,#anti) { for-each [$el] {
    apply[ArgTypes]; 
    if [$anti=1] { $not_s; } absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,
                 #lim=`count(ArgTypes/Typ)`,#same="1"); ")"; } }

tpl [Reflexivity](#el,#arg1,#arg2) { 
    reflexivity(#el=$el,#arg1=$arg1,#arg2=$arg2); }
tpl [Irreflexivity](#el,#arg1,#arg2) { 
    reflexivity(#el=$el,#arg1=$arg1,#arg2=$arg2,#anti="1"); }

tpl [Connectedness](#el,#arg1,#arg2) { for-each [$el] {
    apply[ArgTypes]; "( "; absc1(#el=`.`); "("; 
    arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; $or_s;
    absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,#lim=`count(ArgTypes/Typ)`); 
    "))"; }}

tpl [Commutativity](#el,#arg1,#arg2) { for-each [$el] {
    apply[ArgTypes]; "( "; absc1(#el=`.`); "("; 
    arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; $eq_s;
    absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,#lim=`count(ArgTypes/Typ)`); 
    "))"; }}

tpl [Idempotence](#el,#arg1,#arg2) { for-each [$el] {
    apply[ArgTypes]; 
    "("; absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,
                 #lim=`count(ArgTypes/Typ)`,#same="1"); ")"; $eq_s; 
    ploci(#nr=$arg1); ")";
 } }

tpl [Involutiveness](#el,#arg1,#arg2) { for-each [$el] {
    apply[ArgTypes]; 
    "("; absc1(#el=`.`); "(";
    $trm = { absc1(#el=`.`); "("; 
             arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
    argsinsert(#nr="1",#nr1=$arg1,#arg=$trm,#lim=`count(ArgTypes/Typ)`);
    ")"; $eq_s; ploci(#nr=$arg1); ")"; }}

tpl [Projectivity](#el,#arg1,#arg2) { for-each [$el] {
    apply[ArgTypes]; 
    "("; absc1(#el=`.`); "(";
    $trm = { absc1(#el=`.`); "("; 
             arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
    argsinsert(#nr="1",#nr1=$arg1,#arg=$trm,#lim=`count(ArgTypes/Typ)`);
    ")"; $eq_s; $trm; ")"; }}

// This needs fixing for structures "over" - then the
// functor has more args than just the fields!
tpl [Abstractness](#el,#arg1,#arg2) { for-each [$el] {
    apply[ArgTypes];
    $l = `count(ArgTypes/Typ)`;
    $lasttyp = `ArgTypes/Typ[position() = last()]`;
    "(";  $srt_s; "("; ploci(#nr=$l); ","; absc1(#el=`.`);
    if [$l > 1] { 
     "("; arglist(#separ=",",#elems=`ArgTypes/Typ[position() < last()]`); ")";
    }
    ")"; $imp_s; "("; ploci(#nr=$l); $eq_s;
    if [key('G',$lasttyp/@absnr)] {  
       for-each [key('G',$lasttyp/@absnr)] {  
         absc1(#el=`.`); "("; 
	 // print the "over" args first
	 if [$l > 1] { ft_list(#f="1",#t=`$l - 1`,#sep=",",#l="1"); ","; }
	 for-each [Fields/Field] {
	     absc(#el=`.`); "("; 
	     // the selector might have been defined earlier, without some
	     // hidden args - $f is the difference in arities
	     $f=`1 + $l - @arity`;
	     ft_list(#f=$f,#t=$l,#sep=",",#l="1"); ")";
	     if [not(position()=last())] { ","; }
	 } ")"; }}
     else { $fail; }
     "))";
}}





// tpl [Abstractness](#el,#arg1,#arg2) { for-each [$el] {
//     apply[ArgTypes];
//     $l = `count(ArgTypes/Typ)`;
//     $lasttyp = `ArgTypes/Typ[position() = last()]`;
//     "(";  $srt_s; "("; ploci(#nr=$l); ","; absc1(#el=`.`);
//     if [$l > 1] { 
//      "("; arglist(#separ=",",#elems=`ArgTypes/Typ[position() < last()]`); ")";
//     }
//     ")"; $imp_s; "("; ploci(#nr=$l); $eq_s;
//     if [key('L',$lasttyp/@absnr)] {  
//        for-each [key('L',$lasttyp/@absnr)] {  
//          "g"; `@nr`; "_"; lc(#s=`@aid`);
// 	 "("; 

//     absref(#elems=`key($k,$nr)`,#r=$r); }

 
//     "("; 

// $srt_s; "("; 
//          apply[*[position() = last()]](#i=$i,#pl=$pl); ","; absc(#el=`.`); 
//          if [count(*)>1] { 
//             "("; ilist(#separ=",", #elems=`*[position() < last()]`, #i=$i,#pl=$pl); 
//             ")"; }
//          ")"; }



tpl [CCluster] { if [ErrorCluster] { } else {
    "fof("; absk(#el=`.`,#kind="cc"); ",sort,";
    $l = `1 + count(ArgTypes/Typ)`;
    apply[ArgTypes];
    "!["; ploci(#nr=$l); " : "; apply[Typ]; "]: ("; 
    $ante = { `count(*[2]/*)`; }
    $succ = { `count(*[4]/*)`; }
    $srt_s; "("; ploci(#nr=$l); ",";
    if [$ante = 0] { "$true"; } else {
    if [$ante = 1] { apply[*[2]]; } 
    else { "( "; apply[*[2]]; " )"; } }
    ")"; $imp_s; $srt_s; "("; ploci(#nr=$l); ",";
    if [$succ = 0] { "$true"; } else {
    if [$succ = 1] { apply[*[4]]; } 
    else { "( "; apply[*[4]]; " )"; } }
    "))"; ",file("; lc(#s=`@aid`); ",";
    absk(#el=`.`,#kind="cc"); "),[mptp_info("; `@nr`; 
    ",[],ccluster,position(0,0),["; 
    if [$mml="0"] { 
       "proof_level(["; `translate(../@newlevel,"_",",")`; "])"; }
    "])]).\n"; } }

tpl [FCluster] { if [ErrorCluster] { } else {
    "fof("; absk(#el=`.`,#kind="fc"); ",sort,";
    apply[ArgTypes];
    $succ = { `count(Cluster/*)`; }
    $srt_s; "("; apply[*[2]];  ",";
    if [$succ = 0] { "$true"; } else {
    if [$succ = 1] { apply[Cluster]; } 
    else { "( "; apply[Cluster]; " )"; } }
    ")"; ",file("; lc(#s=`@aid`); ",";
    absk(#el=`.`,#kind="fc"); "),[mptp_info("; `@nr`; 
    ",[],fcluster,position(0,0),[";
    if [$mml="0"] { 
       "proof_level(["; `translate(../@newlevel,"_",",")`; "])"; }
    "])]).\n"; } }

tpl [RCluster] { if [ErrorCluster] { } else {
    "fof("; absk(#el=`.`,#kind="rc"); ",sort,";
    $l = `1 + count(ArgTypes/Typ)`;
    apply[ArgTypes];
    "?["; ploci(#nr=$l); " : "; apply[Typ]; "]: "; 
    $succ = { `count(Cluster/*)`; }
    $srt_s; "("; ploci(#nr=$l); ",";
    if [$succ = 0] { "$true"; } else {
    if [$succ = 1] { apply[Cluster]; } 
    else { "( "; apply[Cluster]; " )"; } }
    ")"; ",file("; lc(#s=`@aid`); ",";
    absk(#el=`.`,#kind="rc"); "),[mptp_info("; `@nr`; 
    ",[],rcluster,position(0,0),[";
    if [$mml="0"] { 
       "proof_level(["; `translate(../@newlevel,"_",",")`; "])"; }
    "])]).\n"; } }


tpl [ArgTypes] { if [Typ] {
       "!["; for-each [Typ] { 
          ploci(#nr=`position()`); " : "; apply[.]; 
          if [not(position()=last())] { ","; } }
       "]: "; } }

tpl pvar(#nr) { "B"; $nr; }
tpl pconst(#nr,#pl) { "c"; absconst(#nr=$nr,#pl=$pl); }
tpl ploci(#nr) { "A"; $nr; }
tpl plab(#nr) { <i { <font { @color=$labcolor; "E"; `@nr`; } } }

// absolute constructor names (use $fail for debugging absnrs)
tpl absc(#el) { for-each [$el] {
    if [@absnr and @aid] { lc(#s=`concat(@kind,@absnr,'_',@aid)`); }
    else { lc(#s=`@kind`); `@nr`;  $fail; } } }

// absolute redefinition names (use $fail for debugging absnrs)
tpl absredef(#el) { for-each [$el] {
    if [@redefaid and @absredefnr] {
       lc(#s=`concat(@kind,@absredefnr,'_',@redefaid)`); }
    else { lc(#s=`@kind`); `@redefnr`;  $fail; } } }

tpl absc1(#el) { for-each [$el] {
    if [@aid and @nr] { lc(#s=`concat(@kind,@nr,'_',@aid)`); }
    else { lc(#s=`@kind`); `@nr`;  $fail; } } }

// absolute reference names (use $fail for debugging absnrs)
// also used for From to get the scheme name
tpl absr(#el) { for-each [$el] {
    if [@nr and @aid and @kind] { lc(#s=`concat(@kind,@nr,'_',@aid)`); }
    else { lc(#s=`@kind`); `@nr`;  $fail; } } }

// absolute cluster and scheme names
tpl absk(#el,#kind) { for-each [$el] {
    if [@nr and @aid] { lc(#s=`concat($kind,@nr,'_',@aid)`); }
    else { lc(#s=$kind); `@nr`;  $fail;} } }



// List utilities

tpl list(#separ,#elems) { 
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { $separ; } }
}

// List utility with additional arg
tpl ilist(#separ,#elems,#i,#pl) { 
 for-each [$elems] {
  apply[.](#i=$i,#pl=$pl); if [not(position()=last())] { $separ; } }
}

// argument list
tpl arglist(#separ,#elems,#s) { 
 for-each [$elems] {
  if [$s > 0] { ploci(#nr=`position() + $s`);} else {ploci(#nr=`position()`);} 
  if [not(position()=last())] { $separ; } }
}

// add numbers starting at #j+1 between #sep1 and #sep2 - now with constants
tpl jlist(#j,#sep1,#sep2,#elems) { 
for-each [$elems] {
  apply[.]; if [not(position()=last())] 
  {  $sep1; pconst(#nr=`$j+position()`); $sep2; } }}

// from-to list of variables starting numbering at $f ending at $t
// $l ouiputs loci vars
tpl ft_list(#f,#t,#sep,#l) {
  if [$f = $t] {  if [$l=1] { ploci(#nr=$f); } else { pvar(#nr=$f); } }
  else { if [$f < $t] { 
       if [$l=1] { ploci(#nr=$f); } else { pvar(#nr=$f); } $sep; 
            ft_list(#f=`$f+1`,#t=$t,#sep=$sep,#l=$l); } }}

// $same is used for reflexivity
tpl switchedargs(#nr,#nr1,#nr2,#lim,#same) {
    if [$nr = $nr2] { ploci(#nr=$nr1); } else {
    if [$nr = $nr1] { 
     if [$same=1] { ploci(#nr=$nr1); } else {  ploci(#nr=$nr2); } } 
    else { ploci(#nr=$nr); }}
    if [$nr < $lim] { ","; 
     switchedargs(#nr=`$nr+1`,#nr1=$nr1,#nr2=$nr2,#lim=$lim,#same=$same); } }

// $same is used for reflexivity
tpl argsinsert(#nr,#nr1,#arg,#lim) {
    if [$nr = $nr1] { $arg; } else { ploci(#nr=$nr); }
    if [$nr < $lim] { ","; 
     argsinsert(#nr=`$nr+1`,#nr1=$nr1,#arg=$arg,#lim=$lim); } } 

// find the constant with #nr on level #pl or higher,
// rpint @constnr "_" $pl
tpl absconst(#nr,#pl) {
    if [key("C",$pl)[@nr=$nr]] { `key("C",$pl)[@nr=$nr]/@constnr`; 
				 addp(#pl=$pl); }
    else { if [key("C",$pl)[@nr < $nr]] { 
      for-each [key("C",$pl)[@nr < $nr]] { if [position() = last()] {
         $n1 = getcnr(#el=`.`); $lastnr = `@nr + $n1 - 1`;
      if [$lastnr >= $nr] { `@constnr + ($nr - @nr)`; addp(#pl=$pl); }
	 else { $fail;}}}}
    else { if [string-length($pl)>0] { 
	 $ss = `exsl-str:tokenize($pl,'_')[position() < last()]`; 
	 $pl1= mjoin(#el=$ss,#s="_");
//	 "bb"; $pl1; "bb";
	 absconst(#nr=$nr,#pl=$pl1); } else { $fail;}}
 }}

tpl mjoin(#el,#s) {
 for-each [$el] { `string(.)`; if [not(position()=last())] { $s; } }}

// count local constants introduced in the current element -
// this asssumes Let | Given | TakeAsVar | Consider | Set | Reconsider
tpl getcnr(#el) { for-each [$el] {
    if [(name() = "Reconsider")] { `count(Var|LocusVar|Const|InfConst|
		  Num|Func|PrivFunc|Fraenkel|QuaTrm|It|ErrorTrm)`; }
    else { `count(Typ)`; } }}


tpl refname(#el,#pl) { for-each [$el] {
    if [(@kind = "T") or (@kind = "D")] { absr(#el=$el); }
    else { privname(#nr=`@nr`,#pl=$pl); } }}

tpl top_propname(#el) { for-each [$el/..] {
    if [(name() = "DefTheorem") or (name() = "JustifiedTheorem")] 
       { absr(#el=`.`); }
    else { $k1 = `concat($el/@nr,":")`;
	 lemmaname(#n=`key("E",$k1)/@propnr`); } } }

// name of private reference - name of the proposition
tpl privname(#nr,#pl) {
      $k1 = `concat($nr,":",$pl)`;
      if [key("E",$k1)] { 
	 if [not(string-length($pl)>0)] { top_propname(#el=`key("E",$k1)`); }
	 else { propname(#n=`key("E",$k1)/@propnr`,#pl=$pl); } }
      else { if [string-length($pl)>0] { 
	 $ss = `exsl-str:tokenize($pl,'_')[position() < last()]`; 
	 $pl1= mjoin(#el=$ss,#s="_");
	 privname(#nr=$nr,#pl=$pl1); } else { $fail;}}
 }

// name of scheme functor (#k='f') or predicate (#k='p')
tpl sch_fpname(#k,#nr,#schnr,#aid) {
    if [$k and $nr and $aid and $schnr] {
       lc(#s=`concat($k,$nr,'_s',$schnr,'_',$aid)`); }
    else { lc(#s=$k); `@nr`;  $fail; }
}

// name of scheme functor (#k='f') or predicate (#k='p')
tpl abs_fp(#k,#el) { for-each [$el] { 
    sch_fpname(#k=$k,#nr=`@nr`,#schnr=`@schemenr`,#aid=`@aid`); }}

// definition of private functor (#k='pf') or predicate (#k='pp'); 
// either a term with LocusVars or a formula with LocusVars
// the list of arguments is printed first, to know their order
tpl priv_def(#k,#nr,#pl) {
      $k1 = `concat($nr,":",$pl)`;
      if [key($k,$k1)] { 
	 for-each [key($k,$k1)] { 
		  "["; arglist(#separ=",",#elems=`ArgTypes/Typ`); "] : ";
		  apply[*[position() = 2]](#pl=`@plevel`); }}
      else { if [string-length($pl)>0] { 
	 $ss = `exsl-str:tokenize($pl,'_')[position() < last()]`; 
	 $pl1= mjoin(#el=$ss,#s="_");
	 priv_def(#k=$k,#nr=$nr,#pl=$pl1); } else { $fail;}}
 }




tpl [/] { if [$mml="0"] { apply[//Proposition|//Now|//IterEquality|
	     //Let|//Given|//TakeAsVar|//Consider|//Set|
	     //Reconsider|//SchemeFuncDecl|//SchemeBlock|
	     //CCluster|//FCluster|//RCluster]; }
	  else { apply; } }







 

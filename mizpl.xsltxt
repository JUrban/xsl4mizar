stylesheet "1.0" 
extension-element-prefixes = "exsl exsl-str xt";
xmlns exsl "http://exslt.org/common"; 
xmlns exsl-str "http://exslt.org/strings";
xmlns xt "http://www.jclark.com/xt";

// XSLTXT (https://xsltxt.dev.java.net/) stylesheet taking 
// Mizar XML terms, formulas and types to Prolog TSTP-like format.

// To produce standard XSLT from this do e.g.: 
// java -jar xsltxt.jar toXSL mizpl.xsltxt >mizpl.xsl

output method=text;

strip-space "*";
// nr. of clusters in Typ
// this needs to be set to 1 for processing MML files
#cluster_nr = { "2"; }
// symbols, take care, the spaces are sometimes (e.g. for '~')
// needed for correct Prolog parsing
#not_s = { "~ "; }
#non_s = { "~ "; }
#and_s = { " & "; }
#imp_s = { " => "; }
#equiv_s = { " <=> "; }
#or_s = { " | "; }
#srt_s = { "sort"; }
#frank_s = { "all"; }
#eq_s = { " = "; }

// this will ensure failure of Prolog parsing
#fail = { "zzz k l-**)))))))"; }

$lcletters= { "abcdefghijklmnopqrstuvwxyz"; }
$ucletters= { "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; } 

// this is for lookup of selectors for Abstractness property
key "L" [Constructor[@kind='L']] `@nr` ;

key "C" [Let|Given|TakeAsVar|Consider|Set|Reconsider] `@plevel` ;

// name of current article (upper case)
#aname= { `string(/*/@aid)`; }

// name of current article (lower case)
#anamelc= { `translate($aname, $ucletters, $lcletters)`; }


// Formulas

// #i is nr of the bound variable, 1 by default 
// empty list can be after ':' for type 'set'
tpl [For](#i,#pl,#k) { 
  $j = { if [$i>0] { `$i + 1`;} else { "1"; } }
  "!["; pvar(#nr=$j); ": "; apply[*[1]](#i=$j,#pl=$pl); "]: "; 
  apply[*[2]](#i=$j,#pl=$pl); }

tpl [Not](#i,#pl) { $not_s; 
    if [For] { "("; apply[*[1]](#i=$i,#pl=$pl); ")"; } 
    else { apply[*[1]](#i=$i,#pl=$pl); }}
tpl [And](#i,#pl) { "( "; 
    ilist(#separ=$and_s, #elems=`*`, #i=$i,#pl=$pl); " )"; }
// here we differ from Mizar and ILF - all 'V' are turned into 'sort'
tpl [Pred](#i,#pl) { 
      if [@kind='V']  { 
         $srt_s; "("; 
         apply[*[position() = last()]](#i=$i,#pl=$pl); ","; absc(#el=`.`); 
         if [count(*)>1] { "("; 
	    ilist(#separ=",", #elems=`*[position() < last()]`, #i=$i,#pl=$pl); 
            ")"; }
         ")"; }
      else { 
	 if [(@kind='R') and (@absnr=1) and (@aid="HIDDEN")] {
	    "( "; apply[*[1]](#i=$i,#pl=$pl); $eq_s; 
	    apply[*[2]](#i=$i,#pl=$pl); " )"; }
	 else {
          if [@kind='P'] { "p"; `@nr`; } else { absc(#el=`.`); }
          if [count(*)>0] { "("; 
	     ilist(#separ=",", #elems=`*`, #i=$i,#pl=$pl); ")"; }
	 } }}

tpl [PrivPred](#i,#pl) { apply[*[position() = last()]](#i=$i,#pl=$pl); }
// empty list can be here - then it can be replaced by 'true'
tpl [Is](#i,#pl) { $srt_s; "("; apply[*[1]](#i=$i,#pl=$pl); ","; 
		   apply[*[2]](#i=$i,#pl=$pl); ")"; }
tpl [Verum](#i,#pl) { "$true"; }
tpl [ErrorFrm](#i,#pl) { "errorfrm"; }

// Terms
// #p is the parenthesis count
tpl [Var](#i,#pl) { pvar(#nr=`@nr`); } 
tpl [LocusVar](#i,#pl) { ploci(#nr=`@nr`); } 
tpl [FreeVar](#i,#pl) { $fail; }
tpl [Const](#i,#pl) { pconst(#nr=`@nr`,#pl=$pl); }
tpl [InfConst](#i,#pl) { $fail; }
tpl [Num](#i,#pl) {  `@nr`; }
tpl [Func](#i,#pl) { 
    if [@kind='F'] { "f"; `@nr`; }  else { absc(#el=`.`); }
    if [count(*)>0] { "("; ilist(#separ=",", #elems=`*`, #i=$i,#pl=$pl); ")"; } }

tpl [PrivFunc](#i,#pl) { apply[*[position() = 1]](#i=$i,#pl=$pl); }
tpl [ErrorTrm](#i,#pl) { "errortrm"; }
tpl [Fraenkel](#i,#pl) { 
     $j = { if [$i>0] { $i;} else { "0"; } }
     $frank_s; "(["; 
     for-each [Typ] { 
       $k = `$j + position()`;
       pvar(#nr=$k); ": "; apply[.](#i=$k,#pl=$pl); 
       if [not(position()=last())] { ","; } }
     "],";
     $l = `$j + count(Typ)`;
     apply[*[position() = last() - 1]](#i=$l,#pl=$pl); ","; 
     apply[*[position() = last()]](#i=$l,#pl=$pl); ")";
}

// Types - the list of attributes and radix type in square brackets
// m1_hidden is not printed; we expect 'L' instead of 'G'
tpl [Typ](#i,#pl) { 
      if [@kind='errortyp'] { "errortyp"; }
      else { if [(@kind="M") or (@kind="L")] {
        $radix = { if [(@aid = "HIDDEN") and (@kind="M") and (@nr="1")]
                         { "0"; } else { "1"; } }
        $adjectives = { `count(*[1]/*)`; }
        if [($adjectives + $radix) = 0] { "$true"; }
        else {
          if [($adjectives + $radix) > 1] { "( "; }
          if [$adjectives > 0] {
             apply[*[1]](#i=$i,#pl=$pl); 
             if [$radix > 0] { $and_s; } }
          if [($radix > 0)] { 
             absc(#el=`.`);
             if [count(*) > $cluster_nr ] { 
               "(";
               ilist(#separ=",", #elems=`*[position() > $cluster_nr]`, 
	             #i=$i, #pl=$pl); 
               ")"; } }
          if [($adjectives + $radix) > 1] { " )"; }
         }
      }
      else { $fail; } }
}

tpl [Cluster](#i,#pl) { ilist(#separ=$and_s, #elems=`*`, #i=$i,#pl=$pl); }
tpl [Adjective](#i,#pl) { if [@value="false"] { $non_s; } absc(#el=`.`);
    if [count(*)>0] { "("; ilist(#separ=",", #elems=`*`, #i=$i, #pl=$pl); 
		      ")"; } }

tpl [Proposition] { $pname = `concat("p", @propnr, "_", @plevel)`;
    "fof(";  $pname; ","; apply(#pl=`@plevel`); ",file("; $anamelc; 
    ","; $pname; "),mptp_info("; `@propnr`; ",["; 
    `translate(@plevel,"_",",")`; "],proposition("; `@line`; ","; 
    `@col`; ","; if [@nr] { `@nr`;} else { "0";} "))).\n"; }


tpl [Theorem] { "fof("; absr(#el=`.`); ",";
    $kword = { if [@kind="T"] { "theorem"; } else {
       if [@kind="D"] { "definition"; } else { $fail; } } }
    $kword; ",";
    apply; ",file("; `translate(@aid,$ucletters,$lcletters)`; ",";
    absr(#el=`.`); "),mptp_info("; `@nr`; ","; $kword; ")).\n"; }

// "M" | "L" | "V" | "R" | "K" | "U" | "G"
tpl [Constructor] { 
    $lkind = `translate(@kind,$ucletters,$lcletters)`;
// the type hierarchy formula for "M" | "L" | "K" | "U" | "G"
    if [(@kind='M') or (@kind='L') or (@kind='K') or 
        (@kind='U') or (@kind='G')] {
      "fof(dt_";  absc1(#el=`.`); ",sort,";
      apply[ArgTypes];
      $l = `1 + count(ArgTypes/Typ)`;
      if [(@kind='M') or (@kind='L')] {
        "!["; ploci(#nr=$l); " : "; "$true"; "]: ("; 
        $srt_s; "("; ploci(#nr=$l); ","; absc1(#el=`.`); 
        if [$l > 1] { "("; 
           arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
        ")"; $imp_s;
        if [count(Typ) = 0] { $srt_s; "("; ploci(#nr=$l); ",$true)"; }
        if [count(Typ) > 1] { "("; }
        for-each [Typ] {
           $srt_s; "("; ploci(#nr=$l); ","; apply[.]; ")";
           if [not(position()=last())] { $and_s; }
        }
        if [count(Typ) > 1] { ")"; }
        ")";
      }  else  { 
      if [(@kind='K') or (@kind='U') or (@kind='G')] {
        $srt_s; "("; absc1(#el=`.`);
        if [$l > 1] { "("; 
           arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
	",";
        apply[Typ]; ")";
      } }
      ",file("; `translate(@aid,$ucletters,$lcletters)`; ",";
      absc1(#el=`.`); "),mptp_info("; `@nr`; ","; $lkind; ",ctype)).\n"; }
    apply[Properties](#el=`.`);
    if [@kind='G'] { free_prop(#el=`.`); }
    if [@redefnr > 0] { redefinition(#el=`.`); }
}

tpl redefinition(#el) { 
    $lkind = `translate($el/@kind,$ucletters,$lcletters)`;
    $redaid = `translate($el/@redefaid,$ucletters,$lcletters)`;
    $absn = absc1(#el=$el); $n = `$el/@nr`;
    $f = `translate($el/@aid,$ucletters,$lcletters)`;
    $s = `@superfluous`;
    for-each [$el] {
      "fof(redefinition_"; $absn; ",definition,";
      apply[ArgTypes]; 
      $l0 = `count(ArgTypes/Typ)`;
      if [(@kind = 'K') or (@kind = 'R')] { 
        "( "; absc1(#el=`.`); 
	if [$l0 > 0] { "("; arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
	if [@kind = 'K'] { $eq_s; } else { $equiv_s; }
        absredef(#el=`.`); 
	if [$l0 > $s] { "("; 
           arglist(#separ=",",#elems=`ArgTypes/Typ[position() > $s]`,#s=$s); 
	   ")";
	} ")";
      } else {
      if [(@kind = 'V') or (@kind = 'M')] {
	 $l = { if [@kind = 'V'] { $l0; } else { `$l0 + 1`; } }
	 if [@kind = 'M'] { "!["; ploci(#nr=`$l`); ": "; apply[Typ]; "]: "; }
	 "( "; $srt_s; "("; ploci(#nr=$l); ","; absc1(#el=`.`);
	 if [$l>1] { 
            "("; arglist(#separ=",",#elems=`ArgTypes/Typ[position() < $l]`);
            ")"; 
	 }
	 ")"; $equiv_s; $srt_s; "("; ploci(#nr=$l); ","; 
	 absredef(#el=`.`); 
	 if [($l - $s) > 1] { "("; 
	    arglist(#separ=",",#elems=`ArgTypes/Typ[(position() > $s) 
                                  and (position() < $l)]`, #s=$s); ")"; 
	 } "))"; 
      }}
      ",file("; $f; ","; $absn; "),mptp_info("; $n; ","; $lkind; 
      ",redefinition("; `@absredefnr`; ","; $lkind; ","; $redaid;
      ","; absredef(#el=`.`); "))).\n"; }
}

// free property - this is rather definition than theorem
// g(x1,x2) = g(x3,x4) implies (x1 = x2 and x3 = x4)
tpl free_prop(#el) { 
    $lkind = `translate($el/@kind,$ucletters,$lcletters)`;
    $absn = absc1(#el=$el); $n = `$el/@nr`;
    $f = `translate($el/@aid,$ucletters,$lcletters)`;
    for-each [$el] {
      "fof(free_"; $absn; ",definition,";
      apply[ArgTypes]; 
      $s=`count(ArgTypes/Typ)`;
      "!["; for-each [ArgTypes/Typ] { 
          ploci(#nr=`position() + $s`); " : $true"; 
          if [not(position()=last())] { ","; } }
       "]: ";
      "(( "; absc1(#el=`.`); "("; 
      arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; $eq_s; 
      absc1(#el=`.`); "("; 
      arglist(#separ=",",#elems=`ArgTypes/Typ`,#s=$s); "))"; $imp_s; "( ";
      for-each [ArgTypes/Typ] { 
	  $p=`position()`;
	  "( "; ploci(#nr=$p); $eq_s;  ploci(#nr=`$p+$s`); ")";
	  if [not($p=last())] { $and_s; }
      }
      "))";
      ",file("; $f; ","; $absn; "),mptp_info("; $n; ","; 
      $lkind; ",property(free))).\n"; }
}

tpl [Properties](#el) { 
    $a1 = `@propertyarg1`; $a2=`@propertyarg2`;
    $lkind = `translate($el/@kind,$ucletters,$lcletters)`;
    $absn = absc1(#el=$el); $n = `$el/@nr`;
    $f = `translate($el/@aid,$ucletters,$lcletters)`;
    for-each [*] {
      $nm = `translate(name(),$ucletters,$lcletters)`;
      "fof(";  $nm; "_"; $absn; ",theorem,";
      apply[.](#el=$el,#arg1=$a1,#arg2=$a2);
      ",file("; $f; ","; $absn; "),mptp_info("; $n; ","; 
      $lkind; ",property("; $nm; "))).\n"; }
}


tpl [UnexpectedProp](#el,#arg1,#arg2) { "$true"; } 

tpl symmetry(#el,#arg1,#arg2,#anti) { for-each [$el] {
    apply[ArgTypes]; "( "; absc1(#el=`.`); "("; 
    arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; $imp_s;
    if [$anti=1] { $not_s; } absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,#lim=`count(ArgTypes/Typ)`); 
    "))"; }}

tpl [Symmetry](#el,#arg1,#arg2) { symmetry(#el=$el,#arg1=$arg1,#arg2=$arg2); } 
tpl [Antisymmetry](#el,#arg1,#arg2) { 
    symmetry(#el=$el,#arg1=$arg1,#arg2=$arg2,#anti="1"); } 

tpl reflexivity(#el,#arg1,#arg2,#anti) { for-each [$el] {
    apply[ArgTypes]; 
    if [$anti=1] { $not_s; } absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,
                 #lim=`count(ArgTypes/Typ)`,#same="1"); ")"; } }

tpl [Reflexivity](#el,#arg1,#arg2) { 
    reflexivity(#el=$el,#arg1=$arg1,#arg2=$arg2); }
tpl [Irreflexivity](#el,#arg1,#arg2) { 
    reflexivity(#el=$el,#arg1=$arg1,#arg2=$arg2,#anti="1"); }

tpl [Connectedness](#el,#arg1,#arg2) { for-each [$el] {
    apply[ArgTypes]; "( "; absc1(#el=`.`); "("; 
    arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; $or_s;
    absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,#lim=`count(ArgTypes/Typ)`); 
    "))"; }}

tpl [Commutativity](#el,#arg1,#arg2) { for-each [$el] {
    apply[ArgTypes]; "( "; absc1(#el=`.`); "("; 
    arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; $eq_s;
    absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,#lim=`count(ArgTypes/Typ)`); 
    "))"; }}

tpl [Idempotence](#el,#arg1,#arg2) { for-each [$el] {
    apply[ArgTypes]; 
    "("; absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,
                 #lim=`count(ArgTypes/Typ)`,#same="1"); ")"; $eq_s; 
    ploci(#nr=$arg1); ")";
 } }

tpl [Involutiveness](#el,#arg1,#arg2) { for-each [$el] {
    apply[ArgTypes]; 
    "("; absc1(#el=`.`); "(";
    $trm = { absc1(#el=`.`); "("; 
             arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
    argsinsert(#nr="1",#nr1=$arg1,#arg=$trm,#lim=`count(ArgTypes/Typ)`);
    ")"; $eq_s; ploci(#nr=$arg1); ")"; }}

tpl [Projectivity](#el,#arg1,#arg2) { for-each [$el] {
    apply[ArgTypes]; 
    "("; absc1(#el=`.`); "(";
    $trm = { absc1(#el=`.`); "("; 
             arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
    argsinsert(#nr="1",#nr1=$arg1,#arg=$trm,#lim=`count(ArgTypes/Typ)`);
    ")"; $eq_s; $trm; ")"; }}


tpl [Abstractness](#el,#arg1,#arg2) { for-each [$el] {
    apply[ArgTypes];
    $l = `count(ArgTypes/Typ)`;
    $lasttyp = `ArgTypes/Typ[position() = last()]`;
    "(";  $srt_s; "("; ploci(#nr=$l); ","; absc1(#el=`.`);
    if [$l > 1] { 
     "("; arglist(#separ=",",#elems=`ArgTypes/Typ[position() < last()]`); ")";
    }
    ")"; $imp_s; "("; ploci(#nr=$l); $eq_s;
    if [key('L',$lasttyp/@absnr)] {  
       for-each [key('L',$lasttyp/@absnr)] {  
         "g"; `@nr`; "_"; `translate(@aid,$ucletters,$lcletters)`; 
	 "("; 
	 for-each [Fields/Field] {
	     absc(#el=`.`); "("; $f=`1 + $l - @arity`;
	     ft_list(#f=$f,#t=$l,#sep=",",#l="1"); ")";
	     if [not(position()=last())] { ","; }
	 } ")"; }}
     else { $fail; }
     "))";
}}





// tpl [Abstractness](#el,#arg1,#arg2) { for-each [$el] {
//     apply[ArgTypes];
//     $l = `count(ArgTypes/Typ)`;
//     $lasttyp = `ArgTypes/Typ[position() = last()]`;
//     "(";  $srt_s; "("; ploci(#nr=$l); ","; absc1(#el=`.`);
//     if [$l > 1] { 
//      "("; arglist(#separ=",",#elems=`ArgTypes/Typ[position() < last()]`); ")";
//     }
//     ")"; $imp_s; "("; ploci(#nr=$l); $eq_s;
//     if [key('L',$lasttyp/@absnr)] {  
//        for-each [key('L',$lasttyp/@absnr)] {  
//          "g"; `@nr`; "_"; `translate(@aid,$ucletters,$lcletters)`; 
// 	 "("; 

//     absref(#elems=`key($k,$nr)`,#r=$r); }

 
//     "("; 

// $srt_s; "("; 
//          apply[*[position() = last()]](#i=$i,#pl=$pl); ","; absc(#el=`.`); 
//          if [count(*)>1] { 
//             "("; ilist(#separ=",", #elems=`*[position() < last()]`, #i=$i,#pl=$pl); 
//             ")"; }
//          ")"; }



tpl [CCluster] { if [ErrorCluster] { } else {
    "fof("; absk(#el=`.`,#kind="cc"); ",sort,";
    $l = `1 + count(ArgTypes/Typ)`;
    apply[ArgTypes];
    "!["; ploci(#nr=$l); " : "; apply[Typ]; "]: ("; 
    $ante = { `count(*[2]/*)`; }
    $succ = { `count(*[4]/*)`; }
    $srt_s; "("; ploci(#nr=$l); ",";
    if [$ante = 0] { "$true"; } else {
    if [$ante = 1] { apply[*[2]]; } 
    else { "( "; apply[*[2]]; " )"; } }
    ")"; $imp_s; $srt_s; "("; ploci(#nr=$l); ",";
    if [$succ = 0] { "$true"; } else {
    if [$succ = 1] { apply[*[4]]; } 
    else { "( "; apply[*[4]]; " )"; } }
    "))"; ",file("; `translate(@aid,$ucletters,$lcletters)`; ",";
    absk(#el=`.`,#kind="cc"); "),mptp_info("; `@nr`; ",ccluster)).\n"; } }

tpl [FCluster] { if [ErrorCluster] { } else {
    "fof("; absk(#el=`.`,#kind="fc"); ",sort,";
    apply[ArgTypes];
    $succ = { `count(Cluster/*)`; }
    $srt_s; "("; apply[*[2]];  ",";
    if [$succ = 0] { "$true"; } else {
    if [$succ = 1] { apply[Cluster]; } 
    else { "( "; apply[Cluster]; " )"; } }
    ")"; ",file("; `translate(@aid,$ucletters,$lcletters)`; ",";
    absk(#el=`.`,#kind="fc"); "),mptp_info("; `@nr`; ",fcluster)).\n"; } }

tpl [RCluster] { if [ErrorCluster] { } else {
    "fof("; absk(#el=`.`,#kind="rc"); ",sort,";
    $l = `1 + count(ArgTypes/Typ)`;
    apply[ArgTypes];
    "?["; ploci(#nr=$l); " : "; apply[Typ]; "]: "; 
    $succ = { `count(Cluster/*)`; }
    $srt_s; "("; ploci(#nr=$l); ",";
    if [$succ = 0] { "$true"; } else {
    if [$succ = 1] { apply[Cluster]; } 
    else { "( "; apply[Cluster]; " )"; } }
    ")"; ",file("; `translate(@aid,$ucletters,$lcletters)`; ",";
    absk(#el=`.`,#kind="rc"); "),mptp_info("; `@nr`; ",rcluster)).\n"; } }




tpl [ArgTypes] { if [Typ] {
       "!["; for-each [Typ] { 
          ploci(#nr=`position()`); " : "; apply[.]; 
          if [not(position()=last())] { ","; } }
       "]: "; } }

tpl pvar(#nr) { "B"; $nr; }
tpl pconst(#nr,#pl) { "c"; $nr; "_"; absconst(#nr=$nr,#pl=$pl); }
tpl ploci(#nr) { "A"; $nr; }
tpl plab(#nr) { <i { <font { @color=$labcolor; "E"; `@nr`; } } }

// absolute constructor names (use $fail for debugging absnrs)
tpl absc(#el) { for-each [$el] {
    if [@absnr and @aid] {
     `translate(concat(@kind,@absnr,'_',@aid),$ucletters,$lcletters)`; }
    else { `translate(@kind,$ucletters,$lcletters)`; `@nr`;  $fail; 
} } }

// absolute redefinition names (use $fail for debugging absnrs)
tpl absredef(#el) { for-each [$el] {
    if [@redefaid and @absredefnr] {
     `translate(concat(@kind,@absredefnr,'_',@redefaid),
		$ucletters,$lcletters)`; }
    else { `translate(@kind,$ucletters,$lcletters)`; `@redefnr`;  $fail; 
} } }

tpl absc1(#el) { for-each [$el] {
    if [@aid and @nr] {
     `translate(concat(@kind,@nr,'_',@aid),$ucletters,$lcletters)`; }
    else { `translate(@kind,$ucletters,$lcletters)`; `@nr`;  $fail; 
} } }

// absolute reference names (use $fail for debugging absnrs)
tpl absr(#el) { for-each [$el] {
    if [@nr and @aid and @kind] {
     `translate(concat(@kind,@nr,'_',@aid),$ucletters,$lcletters)`; }
    else { `translate(@kind,$ucletters,$lcletters)`; `@nr`;  $fail; 
} } }

// absolute cluster and scheme names
tpl absk(#el,#kind) { for-each [$el] {
    if [@nr and @aid] {
     `translate(concat($kind,@nr,'_',@aid),$ucletters,$lcletters)`; }
    else { `translate($kind,$ucletters,$lcletters)`; `@nr`;  $fail; 
} } }



// List utilities

tpl list(#separ,#elems) { 
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { $separ; } }
}

// List utility with additional arg
tpl ilist(#separ,#elems,#i,#pl) { 
 for-each [$elems] {
  apply[.](#i=$i,#pl=$pl); if [not(position()=last())] { $separ; } }
}

// newlined list
tpl nlist(#separ,#elems) { 
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { <br; $separ; } }
}

tpl dlist(#separ,#elems) { 
 for-each [$elems] {
  <div { apply[.]; if [not(position()=last())] { $separ; } } }
}

// argument list
tpl arglist(#separ,#elems,#s) { 
 for-each [$elems] {
  if [$s > 0] { ploci(#nr=`position() + $s`);} else {ploci(#nr=`position()`);} 
  if [not(position()=last())] { $separ; } }
}

// add numbers starting at #j+1 between #sep1 and #sep2 - now with constants
tpl jlist(#j,#sep1,#sep2,#elems) { 
for-each [$elems] {
  apply[.]; if [not(position()=last())] 
  {  $sep1; pconst(#nr=`$j+position()`); $sep2; } }}

// from-to list of variables starting numbering at $f ending at $t
// $l ouiputs loci vars
tpl ft_list(#f,#t,#sep,#l) {
  if [$f = $t] {  if [$l=1] { ploci(#nr=$f); } else { pvar(#nr=$f); } }
  else { if [$f < $t] { 
       if [$l=1] { ploci(#nr=$f); } else { pvar(#nr=$f); } $sep; 
            ft_list(#f=`$f+1`,#t=$t,#sep=$sep,#l=$l); } }}

// $same is used for reflexivity
tpl switchedargs(#nr,#nr1,#nr2,#lim,#same) {
    if [$nr = $nr2] { ploci(#nr=$nr1); } else {
    if [$nr = $nr1] { 
     if [$same=1] { ploci(#nr=$nr1); } else {  ploci(#nr=$nr2); } } 
    else { ploci(#nr=$nr); }}
    if [$nr < $lim] { ","; 
     switchedargs(#nr=`$nr+1`,#nr1=$nr1,#nr2=$nr2,#lim=$lim,#same=$same); } }

// $same is used for reflexivity
tpl argsinsert(#nr,#nr1,#arg,#lim) {
    if [$nr = $nr1] { $arg; } else { ploci(#nr=$nr); }
    if [$nr < $lim] { ","; 
     argsinsert(#nr=`$nr+1`,#nr1=$nr1,#arg=$arg,#lim=$lim); } } 

// find the constant with #nr on level #pl or higher,
// rpint @constnr "_" $pl
tpl absconst(#nr,#pl) {
    if [key("C",$pl)[@nr=$nr]] { `key("C",$pl)[@nr=$nr]/@constnr`; 
			       if [string-length($pl)>0] { "_"; $pl; }}
    else { if [key("C",$pl)[@nr < $nr]] { 
      for-each [key("C",$pl)[@nr < $nr]] { if [position() = last()] {
      $n1 = { if [(name() = "Reconsider")] { 
	      `count(Var|LocusVar|Const|InfConst|Num|Func|PrivFunc|
		     Fraenkel|QuaTrm|It|ErrorTrm)`; }
	      else { `count(Typ)`; } }
      if [@nr + $n1 >= $nr] { `@nr + @constnr - $nr`; 
			 if [string-length($pl)>0] { "_"; $pl; }} 
	 else { $fail;}}}}
    else { if [string-length($pl)>0] { 
	 $ss = `exsl-str:tokenize($pl,'_')[position() < last()]`; 
	 $pl1= mjoin(#el=$ss,#s="_");
//	 "bb"; $pl1; "bb";
	 absconst(#nr=$nr,#pl=$pl1); } else { $fail;}}
 }}

tpl mjoin(#el,#s) {
 for-each [$el] { `string(.)`; if [not(position()=last())] { $s; } }}

stylesheet 1.0;

// XSLTXT (https://xsltxt.dev.java.net/) stylesheet taking 
// Mizar XML terms, formulas and types to Prolog TSTP-like format.

// To produce standard XSLT from this do e.g.: 
// java -jar xsltxt.jar toXSL mizpl.xsltxt >mizpl.xsl

output method=text;

strip-space "*";
// nr. of clusters in Typ
// this needs to be set to 1 for processing MML files
#cluster_nr = { "2"; }
// symbols, take care, the spaces are sometimes (e.g. for '~')
// needed for correct Prolog parsing
#not_s = { "~ "; }
#non_s = { "~ "; }
#and_s = { " & "; }
#srt_s = { "sort"; }
#frank_s = { "all"; }
#eq_s = { " = "; }

// this will ensure failure of Prolog parsing
#fail = { "zzz k l-**)))))))"; }

$lcletters= { "abcdefghijklmnopqrstuvwxyz"; }
$ucletters= { "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; } 

// Formulas

// #i is nr of the bound variable, 1 by default 
// empty list can be after ':' for type 'set'
tpl [For](#i,#k) { 
  $j = { if [$i>0] { `$i + 1`;} else { "1"; } }
  "!["; pvar(#nr=$j); ": "; apply[*[1]](#i=$j); "]: "; apply[*[2]](#i=$j); }

tpl [Not](#i) { $not_s; 
    if [For] { "("; apply[*[1]](#i=$i); ")"; } else { apply[*[1]](#i=$i); }}
tpl [And](#i) { "( "; ilist(#separ=$and_s, #elems=`*`, #i=$i); " )"; }
// here we differ from Mizar and ILF - all 'V' are turned into 'sort'
tpl [Pred](#i) { 
      if [@kind='V']  { 
         $srt_s; "("; 
         apply[*[position() = last()]](#i=$i); ","; absc(#el=`.`); 
         if [count(*)>1] { 
            "("; ilist(#separ=",", #elems=`*[position() < last()]`, #i=$i); 
            ")"; }
         ")"; }
      else { 
	 if [(@kind='R') and (@absnr=1) and (@aid="HIDDEN")] {
	    "( "; apply[*[1]]; $eq_s; apply[*[2]]; " )"; }
	 else {
          if [@kind='P'] { "p"; `@nr`; } else { absc(#el=`.`); }
          if [count(*)>0] { "("; ilist(#separ=",", #elems=`*`, #i=$i); ")"; }
	 } }}

tpl [PrivPred](#i) { apply[*[position() = last()]](#i=$i); }
// empty list can be here - then it can be replaced by 'true'
tpl [Is](#i) { $srt_s; "("; apply[*[1]](#i=$i); ","; apply[*[2]](#i=$i); ")"; }
tpl [Verum](#i) { "true"; }
tpl [ErrorFrm](#i) { "errorfrm"; }

// Terms
// #p is the parenthesis count
tpl [Var](#i) { pvar(#nr=`@nr`); } 
tpl [LocusVar](#i) { ploci(#nr=`@nr`); } 
tpl [FreeVar](#i) { $fail; }
tpl [Const](#i) { pconst(#nr=`@nr`); }
tpl [InfConst](#i) { $fail; }
tpl [Num](#i) {  `@nr`; }
tpl [Func](#i) { 
    if [@kind='F'] { "f"; `@nr`; }  else { absc(#el=`.`); }
    if [count(*)>0] { "("; ilist(#separ=",", #elems=`*`, #i=$i); ")"; } }

tpl [PrivFunc](#i) { apply[*[position() = 1]](#i=$i); }
tpl [ErrorTrm](#i) { "errortrm"; }
tpl [Fraenkel](#i) { 
     $j = { if [$i>0] { $i;} else { "0"; } }
     $frank_s; "(["; 
     for-each [Typ] { 
       $k = `$j + position()`;
       pvar(#nr=$k); ":"; apply[.](#i=$k); 
       if [not(position()=last())] { ","; } }
     "],";
     $l = `$j + count(Typ)`;
     apply[*[position() = last() - 1]](#i=$l); ","; 
     apply[*[position() = last()]](#i=$l); ")";
}

// Types - the list of attributes and radix type in square brackets
// m1_hidden is not printed; we expect 'L' instead of 'G'
tpl [Typ](#i) { 
      if [@kind='errortyp'] { "errortyp"; }
      else { if [(@kind="M") or (@kind="L")] {
        $radix = { if [(@aid = "HIDDEN") and (@kind="M") and (@nr="1")]
                         { "0"; } else { "1"; } }
        $adjectives = { `count(*[1]/*)`; }
        if [($adjectives + $radix) = 0] { "true"; }
        else {
          if [($adjectives + $radix) > 1] { "( "; }
          if [$adjectives > 0] {
             apply[*[1]](#i=$i); 
             if [$radix > 0] { $and_s; } }
          if [($radix > 0)] { 
             absc(#el=`.`);
             if [count(*) > $cluster_nr ] { 
               "(";
               ilist(#separ=",", #elems=`*[position() > $cluster_nr]`, #i=$i); 
               ")"; } }
          if [($adjectives + $radix) > 1] { " )"; }
         }
      }
      else { $fail; } }
}

tpl [Cluster](#i) { ilist(#separ=$and_s, #elems=`*`, #i=$i); }
tpl [Adjective](#i) { if [@value="false"] { $non_s; } absc(#el=`.`);
    if [count(*)>0] { "("; ilist(#separ=",", #elems=`*`, #i=$i); ")"; } }


tpl [Theorem] { 
    if [@kind="T"] { "theorem"; } else {
       if [@kind="D"] { "definition"; } else { $fail; } }
    "("; absr(#el=`.`); ","; `translate(@aid,$ucletters,$lcletters)`;
    ","; `@nr`; ","; apply; ").\n"; }

tpl pvar(#nr) { "B"; $nr; }
tpl pconst(#nr) { "c"; $nr; }
tpl ploci(#nr) { "A"; $nr; }
tpl plab(#nr) { <i { <font { @color=$labcolor; "E"; `@nr`; } } }

// absolute constructor names (use $fail for debugging absnrs)
tpl absc(#el) { for-each [$el] {
    if [@absnr and @aid] {
     `translate(concat(@kind,@absnr,'_',@aid),$ucletters,$lcletters)`; }
    else { `translate(@kind,$ucletters,$lcletters)`; `@nr`;  $fail; 
} } }

// absolute reference names (use $fail for debugging absnrs)
tpl absr(#el) { for-each [$el] {
    if [@nr and @aid and @kind] {
     `translate(concat(@kind,@nr,'_',@aid),$ucletters,$lcletters)`; }
    else { `translate(@kind,$ucletters,$lcletters)`; `@nr`;  $fail; 
} } }


// List utilities

tpl list(#separ,#elems) { 
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { $separ; } }
}

// List utility with additional arg
tpl ilist(#separ,#elems,#i) { 
 for-each [$elems] {
  apply[.](#i=$i); if [not(position()=last())] { $separ; } }
}

// newlined list
tpl nlist(#separ,#elems) { 
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { <br; $separ; } }
}

tpl dlist(#separ,#elems) { 
 for-each [$elems] {
  <div { apply[.]; if [not(position()=last())] { $separ; } } }
}

// argument list
tpl arglist(#separ,#elems) { 
 for-each [$elems] {
  ploci(#nr=`position()`); if [not(position()=last())] { $separ; } }
}

// add numbers starting at #j+1 between #sep1 and #sep2 - now with constants
tpl jlist(#j,#sep1,#sep2,#elems) { 
for-each [$elems] {
  apply[.]; if [not(position()=last())] 
  {  $sep1; pconst(#nr=`$j+position()`); $sep2; } }}

// from-to list of variables starting numbering at $f ending at $t
tpl ft_list(#f,#t,#sep) {
  if [$f = $t] {  pvar(#nr=$f); }
  else { if [$f < $t] { pvar(#nr=$f); $sep; 
            ft_list(#f=`$f+1`,#t=$t,#sep=$sep); } }}

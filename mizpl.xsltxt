stylesheet "1.0" 
extension-element-prefixes = "exsl exsl-str xt";
xmlns exsl "http://exslt.org/common"; 
xmlns exsl-str "http://exslt.org/strings";
xmlns xt "http://www.jclark.com/xt";
output method=text;

// $Revision: 1.61 $
//
// File: mizpl.xsltxt - stylesheet translating Mizar XML terms, 
//                      formulas and types to Prolog TSTP-like format.
//
// Author: Josef Urban
//
// License: GPL (GNU GENERAL PUBLIC LICENSE)

// XSLTXT (https://xsltxt.dev.java.net/) stylesheet taking 
// Mizar XML terms, formulas and types to Prolog TSTP-like format.

// To produce standard XSLT from this call make, or do e.g.: 
// java -jar xsltxt.jar toXSL mizpl.xsltxt | sed -e 's/<!\-\- *\(<\/*xsl:document.*\) *\-\->/\1/g' >mizpl.xsl

// ##NOTE: TPTP types 'theorem' and 'definition' are wider
//   than in Mizar. Mizar 'property' is also exported as
//   TPTP 'theorem', and there are various Mizar items
//   exported as TPTP 'definition'. Use the 'mptp_info' slot
//   to determine the Mizar item kind.
//
// ##TODO: try to replace the exsl stuff by get_parent_level like in miz.xsltxt

strip-space "*";

// this needs to be set to 1 for processing MML files
#mml = { "0"; }
// nr. of clusters in Typ
// this is set to 1 for processing MML files
#cluster_nr = { if [$mml = "0"] { "2"; } else { "1"; }}

// include natural deduction explanations (also computes
// the assumptions of each proposition)
#do_nd = { "1"; }

// dump the table of Mizar identifiers for propositions;
// this will probably slow down the processing a bit by 
// loading the .idx file and by the lookups
#dump_prop_labels = { "0"; }

// symbols, take care, the spaces are sometimes (e.g. for '~')
// needed for correct Prolog parsing
#not_s = { "~ "; }
#non_s = { "~ "; }
#and_s = { " & "; }
#imp_s = { " => "; }
#equiv_s = { " <=> "; }
#or_s = { " | "; }
#srt_s = { "sort"; }
#frank_s = { "all"; }
#eq_s = { " = "; }
#the_s = { "the"; }

#derived_lemma = { "lemma_conjecture"; }

// this will ensure failure of Prolog parsing
#fail = { "zzz k l-**)))))))"; }

$lcletters= { "abcdefghijklmnopqrstuvwxyz"; }
$ucletters= { "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; } 

tpl lc(#s) { `translate($s, $ucletters, $lcletters)`; }
tpl uc(#s) { `translate($s, $lcletters, $ucletters)`; }

// this is for lookup of selectors for Abstractness property
key "G" [Constructor[@kind='G']] `@nr` ;

// lookup for local constants
key "C" [Let|Given|TakeAsVar|Consider|Set|Reconsider] `@plevel` ;

// lookup for propositions
key "E" [Proposition|IterEquality|Now] `concat(@nr,":",@plevel)` ;

// lookup for JustifiedTheorems' propnr (needed in plname)
key "JT" [/Article/JustifiedTheorem/Proposition] `@propnr`;

// lookup for DefTheorems' propnr (needed in plname)
key "DT" [/Article/DefTheorem/Proposition] `@propnr`;

// lookup for scheme functors and predicates
key "f" [SchemeFuncDecl] `concat(@nr,":",@plevel)` ;
key "p" [SchemePredDecl] `concat(@nr,":",@plevel)` ;

// lookup for private functors and predicates
key "pf" [DefFunc] `concat(@nr,":",@plevel)` ;
key "pp" [DefPred] `concat(@nr,":",@plevel)` ;

// lookup for identifiers (propositions)
// used only if $dump_prop_labels = 1
key "D_I" [Symbol[@kind='I']] `@nr`;

// name of current article (upper case)
#aname= { `string(/*/@aid)`; }

// name of current article (lower case)
#anamelc= { lc(#s=$aname); }

// .idx file with identifier names
// used only if $dump_prop_labels = 1
#ids=  { `concat($anamelc, '.idx')`; }

// private - look up the name of id
tpl get_vid_name(#vid)
{
  for-each [document($ids, /)] 
  { 
     for-each [key('D_I', $vid)] { `@name`; }
  }
}



// Formulas

// old versions without pretty-printing
// // #i is nr of the bound variable, 1 by default 
// // empty list can be after ':' for type 'set'
// tpl [For](#i,#pl,#k) { 
//   $j = { if [$i>0] { `$i + 1`;} else { "1"; } }
//   "!["; pvar(#nr=$j); ": "; apply[Typ[1]](#i=$j,#pl=$pl); "]: "; 
//   apply[*[2]](#i=$j,#pl=$pl); }

// // need to put brackets around PrivPred here - may contain For
// tpl [Not](#i,#pl) { $not_s; 
//     if [For|PrivPred] { "("; apply[*[1]](#i=$i,#pl=$pl); ")"; } 
//     else { apply[*[1]](#i=$i,#pl=$pl); }}
// tpl [And](#i,#pl) { "( "; 
//     ilist(#separ=$and_s, #elems=`*`, #i=$i,#pl=$pl); " )"; }


// pretty printing for FOF
#pid_Ex 		= { "-1"; } // usually NegFrmPtr
#pid_Ex_Univ 		= { "-2"; } // usually UnivFrmPtr
#pid_Ex_InnerNot 	= { "-3"; } // usually NegFrmPtr
#pid_Impl 		= { "-4"; } // usually NegFrmPtr
#pid_Impl_And 		= { "-5"; } // usually ConjFrmPtr       
#pid_Impl_RightNot 	= { "-6"; } // usually NegFrmPtr
#pid_Iff 		= { "-7"; } // usually ConjFrmPtr
#pid_Or 		= { "-8"; } // usually NegFrmPtr
#pid_Or_And 		= { "-9"; } // usually ConjFrmPtr
#pid_Or_LeftNot 	= { "-10"; } // usually NegFrmPtr
#pid_Or_RightNot 	= { "-11"; } // usually NegFrmPtr

tpl is_or(#el) { for-each [$el] { if [(@pid=$pid_Or) 
        and (*[1][@pid=$pid_Or_And]) and (count(*[1]/*)=2)
	and (*[1]/*[1][@pid=$pid_Or_LeftNot])
	and (*[1]/*[2][@pid=$pid_Or_RightNot])]
 { "1"; } else { "0"; }}}

tpl is_impl(#el) { for-each [$el] { if [(@pid=$pid_Impl) 
        and (*[1][@pid=$pid_Impl_And]) and (count(*[1]/*)=2)
	and (*[1]/*[2][@pid=$pid_Impl_RightNot])]
 { "1"; } else { "0"; }}}

tpl is_impl1(#el) { for-each [$el] { if [(@pid=$pid_Impl) 
        and (*[1][@pid=$pid_Impl_And]) and (count(*[1]/*)>2)
	and (*[1]/*[@pid=$pid_Impl_RightNot])]
 { "1"; } else { "0"; }}}

tpl is_impl2(#el) { for-each [$el] { if [(@pid=$pid_Impl) 
        and (*[1][@pid=$pid_Impl_And]) and (count(*[1]/*)>=2)
	and (*[1]/*[@pid=$pid_Impl_RightNot])]
 { "1"; } else { "0"; }}}


tpl is_equiv(#el) { for-each [$el] {
       $e1 = { if [(@pid=$pid_Iff) and (count(*)=2)] {
		  $i1 = { is_impl(#el=`$el/*[1]`); } 
		  if [$i1="1"] { is_impl(#el=`*[2]`); }
		  else { "0"; }}
	       else { "0"; } }
       if [$e1="1"] { 
	  $res1 = { are_equal( #el1=`*[1]/*[1]/*[1]`, 
			       #el2=`*[2]/*[1]/*[2]/*[1]`); }
	  $res2 = { are_equal( #el1=`*[2]/*[1]/*[1]`, 
			       #el2=`*[1]/*[1]/*[2]/*[1]`); }
	  if [($res1="1") and ($res2="1")] { "1"; }
          else { "0"; }}
       else  { $e1; }}}

//  recursive equality on subnodes and attributes
tpl are_equal(#el1,#el2) { 
    if[ not(name($el1)=name($el2)) or not(count($el1/*)=count($el2/*))
	or not(count($el1/@*)=count($el2/@*))] { "0"; }
    else { 
	 $s1 = { for-each [$el1/@*] { `string()`;} }
	 $s2 = { for-each [$el2/@*] { `string()`;} }
	 if [not($s1=$s2)] { "0"; }
    else 
     { are_equal_many(#els1=`$el1/*`,#els2=`$el2/*`,#nr=`count($el1/*)`); }}}

tpl are_equal_many(#els1,#els2,#nr) { if [$nr > 0] {
    $el1=`$els1[position()=$nr]`;
    $el2=`$els2[position()=$nr]`; 
    $res1 = { are_equal(#el1=$el1, #el2=$el2); }
    if [$res1="1"] { are_equal_many(#els1=$els1, #els2=$els2, #nr=`$nr - 1`);}
    else { "0"; }} else { "1"; }}


// #i is nr of the bound variable, 1 by default 
// empty list can be after ':' for type 'set'
tpl [For](#i,#pl,#k,#ex) {
  $j = { if [$i>0] { `$i + 1`;} else { "1"; } } 
  if [$ex="1"] { 
   $nm = { `name(*[2])`; }
   "?["; pvar(#nr=$j); ": "; apply[Typ[1]](#i=$j,#pl=$pl); "]: ";
   if [$nm = "For"] { apply[*[2]](#i=$j,#ex=$ex,#pl=$pl); }
   else { apply[Not/*[1]](#i=$j,#pl=$pl); }
  }
  else { 
   "!["; pvar(#nr=$j); ": "; apply[Typ[1]](#i=$j,#pl=$pl); "]: ";
   apply[*[2]](#i=$j,#pl=$pl); }
 }


// return 1 if this is a Not-ended sequence of For-s
tpl check_for_not(#el) { 
    if [name($el)="Not"] { "1"; } 
    else { if [name($el)="For"] { check_for_not(#el=`$el/*[2]`); }
    else { "0"; }}}

// need to put brackets around PrivPred here - may contain For
tpl [Not](#i,#pl) { 
    $fnb = { if [For] { check_for_not(#el=`*[1]/*[2]`); } else { "0"; } }
    if [$fnb="1"]  { apply[*[1]](#i=$i,#pl=$pl,#ex="1"); }
    else { 
	 $i1= is_impl(#el=`.`);
	 if [$i1="1"] { "( "; apply[*[1]/*[1]](#i=$i,#pl=$pl); $imp_s;
			apply[*[1]/*[2]/*[1]](#i=$i,#pl=$pl); " )"; }
         else {
	      $i2= is_or(#el=`.`);
	      if [$i2="1"] { "( "; apply[*[1]/*[1]/*[1]](#i=$i,#pl=$pl); $or_s;
			apply[*[1]/*[2]/*[1]](#i=$i,#pl=$pl); " )"; }
           else { 
             $i3= is_impl1(#el=`.`);
	    if [($i3="1") and (*[1]/*[not(name()="Not")]) and (*[1]/Not)] { "( ( "; 
	     ilist(#separ=$and_s, #elems=`*[1]/*[not(name()="Not")]`, #i=$i,#pl=$pl);
	    " )"; $imp_s;
	    "( "; ilist(#separ=$or_s, #elems=`*[1]/Not/*[1]`, #i=$i,#pl=$pl); " ) )"; }
             else { $not_s; 
		    if [For|PrivPred] { "("; apply[*[1]](#i=$i,#pl=$pl); ")"; } 
		    else { apply[*[1]](#i=$i,#pl=$pl); } } } } } }

// try for equivalence
tpl [And](#i,#pl) { "( "; $e1= is_equiv(#el=`.`); 
    if [$e1="1"] { 
       apply[*[1]/*[1]/*[1]](#i=$i,#pl=$pl); $equiv_s;
       apply[*[1]/*[1]/*[2]/*[1]](#i=$i,#pl=$pl); }
    else { // a bit risky?
    if [(@pid=$pid_Iff) and (count(*)=2)] {
       $i1= is_impl(#el=`*[1]`);
       if [$i1="1"] { 
	  apply[*[1]/*[1]/*[1]](#i=$i,#pl=$pl); $equiv_s;
	  apply[*[1]/*[1]/*[2]/*[1]](#i=$i,#pl=$pl); }
       else { $i2= is_impl(#el=`*[2]`);
       if [$i2="1"] { 
	  apply[*[2]/*[1]/*[2]/*[1]](#i=$i,#pl=$pl); $equiv_s;
	  apply[*[2]/*[1]/*[1]](#i=$i,#pl=$pl); }
       else { ilist(#separ=$and_s, #elems=`*`, #i=$i,#pl=$pl); }}}
    else { ilist(#separ=$and_s, #elems=`*`, #i=$i,#pl=$pl); }}
    " )";
    }

// here we differ from Mizar and ILF - all 'V' are turned into 'sort'
// ##GRM: Sch_Pred : "p" Number "_" Scheme_Name
tpl [Pred](#i,#pl) { 
      if [@kind='V']  { 
         $srt_s; "("; 
         apply[*[position() = last()]](#i=$i,#pl=$pl); ","; absc(#el=`.`); 
         if [count(*)>1] { "("; 
	    ilist(#separ=",", #elems=`*[position() < last()]`, #i=$i,#pl=$pl); 
            ")"; }
         ")"; }
      else { 
	 if [(@kind='R') and (@absnr=1) and (@aid="HIDDEN")] {
	    "( "; apply[*[1]](#i=$i,#pl=$pl); $eq_s; 
	    apply[*[2]](#i=$i,#pl=$pl); " )"; }
	 else {
          if [@kind='P'] { abs_fp(#k="p",#el=`.`); }
	  else { absc(#el=`.`); }
          if [count(*)>0] { "("; 
	     ilist(#separ=",", #elems=`*`, #i=$i,#pl=$pl); ")"; }
	 } }}

tpl [PrivPred](#i,#pl) { apply[*[position() = last()]](#i=$i,#pl=$pl); }
// empty list can be here - then it can be replaced by 'true'
tpl [Is](#i,#pl) { $srt_s; "("; apply[*[1]](#i=$i,#pl=$pl); ","; 
		   apply[*[2]](#i=$i,#pl=$pl); ")"; }
tpl [Verum](#i,#pl) { "$true"; }
tpl [ErrorFrm](#i,#pl) { "errorfrm"; }

// Terms
// #p is the parenthesis count
tpl [Var](#i,#pl) { pvar(#nr=`@nr`); } 
tpl [LocusVar](#i,#pl) { ploci(#nr=`@nr`); } 
tpl [FreeVar](#i,#pl) { $fail; }
tpl [Const](#i,#pl) { pconst(#nr=`@nr`,#pl=$pl); }
tpl [InfConst](#i,#pl) { $fail; }
tpl [Num](#i,#pl) {  `@nr`; }
// ##GRM: Sch_Func : "f" Number "_" Scheme_Name
tpl [Func](#i,#pl) { 
    if [@kind='F'] { abs_fp(#k="f",#el=`.`); }
    else { absc(#el=`.`); }
    if [count(*)>0] { "("; ilist(#separ=",", #elems=`*`, #i=$i,#pl=$pl); ")"; } }

tpl [PrivFunc](#i,#pl) { apply[*[position() = 1]](#i=$i,#pl=$pl); }
tpl [Choice](#i,#pl) { $the_s; "("; apply[*[position() = 1]](#i=$i,#pl=$pl); ")"; }
tpl [ErrorTrm](#i,#pl) { "errortrm"; }
tpl [Fraenkel](#i,#pl) { 
     $j = { if [$i>0] { $i;} else { "0"; } }
     $frank_s; "(["; 
     for-each [Typ] { 
       $k = `$j + position()`;
       pvar(#nr=$k); ": "; apply[.](#i=$k,#pl=$pl); 
       if [not(position()=last())] { ","; } }
     "],";
     $l = `$j + count(Typ)`;
     apply[*[position() = last() - 1]](#i=$l,#pl=$pl); ","; 
     apply[*[position() = last()]](#i=$l,#pl=$pl); ")";
}

// Types - the list of attributes and radix type in square brackets
// m1_hidden is not printed; we expect 'L' instead of 'G'
tpl [Typ](#i,#pl) { 
      if [@kind='errortyp'] { "errortyp"; }
      else { if [(@kind="M") or (@kind="L")] {
        $radix = { if [(@aid = "HIDDEN") and (@kind="M") and (@nr="1")]
                         { "0"; } else { "1"; } }
        $adjectives = { `count(*[1]/*)`; }
        if [($adjectives + $radix) = 0] { "$true"; }
        else {
          if [($adjectives + $radix) > 1] { "( "; }
          if [$adjectives > 0] {
             apply[*[1]](#i=$i,#pl=$pl); 
             if [$radix > 0] { $and_s; } }
          if [($radix > 0)] { 
             absc(#el=`.`);
             if [count(*) > $cluster_nr ] { 
               "(";
               ilist(#separ=",", #elems=`*[position() > $cluster_nr]`, 
	             #i=$i, #pl=$pl); 
               ")"; } }
          if [($adjectives + $radix) > 1] { " )"; }
         }
      }
      else { $fail; } }
}

tpl [Cluster](#i,#pl) { ilist(#separ=$and_s, #elems=`*`, #i=$i,#pl=$pl); }
tpl [Adjective](#i,#pl) { if [@value="false"] { $non_s; } absc(#el=`.`);
    if [count(*)>0] { "("; ilist(#separ=",", #elems=`*`, #i=$i, #pl=$pl); 
		      ")"; } }

tpl addp(#pl) { if [string-length($pl)>0] { "_"; $pl; }}

// concat number and level
tpl propname(#n,#pl) { "e"; $n; addp(#pl=$pl); }
tpl abspropname(#n,#pl) { propname(#n=$n,#pl=$pl); "__"; $anamelc; }
tpl lemmaname(#n) { "l"; $n; "_"; $anamelc; } 
tpl plname(#n,#pl) 
{
    if [string-length($pl)>0] { propname(#n=$n, #pl=$pl); }
    else { if [key("JT",$n)] 
    {
      for-each [key("JT",$n)] { absr(#el=`..`); }
    } 
    else { if [key("DT",$n)] 
    {
      for-each [key("DT",$n)] { absr(#el=`..`); }
    } 

    else { lemmaname(#n=$n); }
    }}
}

tpl thesisname(#n,#pl) { "i"; $n; addp(#pl=$pl); }

// thesis is usually justified by following thesis,
// and some ND rule (and possibly axiom);
// the corresponding ND item can be 
// %Let; | %Conclusion; | %Assume; | %Given; | %Take; | %TakeAsVar; | %Suppose; | %Case;
// for Proofs it immediately precedes the Thesis, while
// for Now it has to be looked up by having the same position 
// among skeleton items as the current thesis has among theses

// ##NOTE: this is the same for  Suppose and Case, however for
// PerCases the thesis follows only if not diffuse - we hack it there anyway,
// and avoid its processing here
tpl [Thesis]
{
   $prec_nm = `name(preceding-sibling::*[1])`;
   if [not($prec_nm = "PerCases")]
   {
     $nr    = `1 + count(preceding-sibling::Thesis)`;
     $tname = { thesisname(#n = $nr, #pl = `@plevel`); }
     "fof("; $tname; ",thesis,";
     apply(#pl=`@plevel`); 
     ",file("; $anamelc; ","; $tname; 
     "),[mptp_info("; $nr; ",["; `translate(@plevel,"_",",")`; 
     "],thesis,position(0,0),[])"; ",";
     try_nd_inference(#el = `.`, #thes_nr = $nr);
     "]).\n";
   }
}

// no thesis only subblock theses used
// usage of plevel in subblocks (instead of their newlevel) is correct
tpl [PerCasesReasoning]
{
  for-each [CaseBlock|SupposeBlock]
  {
    $nr = `position()`;
    $tname = { thesisname(#n = $nr, #pl = `@plevel`); }
    "fof("; $tname; ",thesis,";
    apply[BlockThesis/*[position() = last()]](#pl=`@plevel`);
    ",file("; $anamelc; ","; $tname; 
    "),[mptp_info("; $nr; ",["; `translate(@plevel,"_",",")`; 
    "],thesis,position(0,0),[])"; ",";
    try_nd_inference(#el = `BlockThesis/*[position() = last()]`, #thes_nr = "0");
   "]).\n";
  }
}


// tpl [CaseBlock/BlockThesis|SupposeBlock/BlockThesis]
// {
//    $nr    = `1 + count(../../preceding-sibling::Thesis)`;
//    $tname = { thesisname(#n = $nr, #pl = `@plevel`); }
//    "fof(bl"; $tname; ",blockthesis,";
//    apply(#pl=`@plevel`); 
//    ",file("; $anamelc; ",bl"; $tname; 
//    "),[mptp_info("; $nr; ",["; `translate(@plevel,"_",",")`; 
//    "],thesis,position(0,0),[])"; ",";
// //   try_nd_inference(#el = `.`, #thes_nr = $nr);
//    "]).\n";
// }


// the henkin axioms will be created by MPTP (for each const. separately);
// doing it here would mean that we either have to cheat a bit (just 
// imply previous thesis by thenext one, and call it axiom), or instantiate
// or generalize - which is much easier to do in prolog
tpl henkin_ax_nm(#cnm)  { "dh_"; $cnm; }

// can be empty string or more than one (separated by commas)
// private for Let, Consider, and Given
// #tpos optionally tells to use only first #tpos Typs
tpl get_henkin_axioms(#tpos)
{
   $cnr = `@constnr`; $pl=`@plevel`;
   $pos = { if [not($tpos)] { `count(Typ)`; } else { $tpos; } }
   for-each [Typ[position() <= $pos]]
   {
      $nr   = `$cnr + position() - 1`; 
      $nm   =  { "c"; $nr; addp(#pl = $pl); }
      henkin_ax_nm(#cnm = $nm);
      if [not(position() = $pos)] { ","; }
   }
}


// ###GRM:
// Mizar_ND_Inference = "mizar_nd(" "inference(" Mizar_ND_Rule "," "[" Optional_ND_Info* "]" "," 
//                       "[" Optional_Ref* Optional_NextThesis "]" ")" ")"
// Mizar_ND_Rule = "let" | "consider" | "take" | "assume" | "discharge_asm" | "conclusion" 
//                 | "trivial" | "iterative_eq" | "percases"
// Optional_ND_Info = AssumptionList | DischargeAsmInfo | ThesisExpansions

// list of assumptions under which a formula is valid
// AssumptionList = "assumptions(" "[" References "]" ")"

// list of discharged assumptions used for inferring this formula;
// say "Foo implies Poo" (with assumptions(Asms1)) is justified by discharged(Dis2)
// and "Poo" with assumptions(Asms2), then "Foo" has to be equivalent to /\Dis2,
// and Asms2 has to be subset of Dis2 \/ Asms1 (i.e. ever y assumption of "Poo" is
// either discharged, or also an assumption of "Foo implies Poo")
// DischargeAsmInfo = "discharged(" "[" References "]" ")"

// expansions used to infer this thesis, note that these can only be definitions,
// and they have to appear among the standard inferences too
// ThesisExpansions = "thesis_expansions(" "[" References "]" ")"


// "let": Henkin_Axiom_For_Let: here it is that "for x1 p(x1)" is justified by
// "let c1"; translating to the henkin axiom: 
// "p(c1) => for x1 p(x1)" and the next thesis "p(c1)"
// "consider": Henkin_Axiom_For_Consider: here "p(c1)" is justified by 
// "ex x1 st p(x1)"; translating to the axiom:
//  "(ex x1 st p(x1)) => p(c1)" (note that having Henkin_Axiom_For_Let is enough
// to justify Henkin_Axiom_For_Consider, and vice versa (use negated formulas))
// "take": no special axiom is needed, since "take" justifies "ex x1 st p(x1)"
// by reference to "p(c1)", which is implicit in ATP systems; no bg should be needed
// "assume": no axiom needed, only check that the fof name is among its AssumptionList
// "discharge_asm": no axiom needed
// "conclusion" : Concluded_Proposition: "p & q" is justified by "thus p;" and next thesis "q"; no bg needed
// "trivial": this is the last thesis, and it must be trivial (i.e. $true)
// "iterative_eq": is justified by conjunction of the iterative steps; note that no background is needed
// "percases": is justified by all the subblocks implications, and the truth of disjucntion of all cases - propositional
// Optional_Ref = Henkin_Axiom_For_Let | Henkin_Axiom_For_Consider | Concluded_Proposition | Iterative_Step
//                | CaseThesis

// #thes_nr gives a number of thesis for which this is created
// here we come from the "previous thesis", and look for the 
// "next skeleton item" (which justifies the previous thesis)
tpl try_nd_inference(#el,#thes_nr) 
{ 
   $res =
   {
     if [name($el/..) = "BlockThesis"] // we are inside diffuse theses (also any BlockThesis/Formula allowed)
     {
         for-each [$el/../../*[
	    (name()="Let") or (name()="Conclusion") or (name()="Assume") or (name()="Given") or 
	    (name()="Take") or (name()="TakeAsVar") or (name()="Case") or (name()="Suppose") or 
	    (name()="PerCasesReasoning")][$thes_nr + 1]]
	 {
	   do_nd(#thes_nr = $thes_nr);
	 }
     }
     else
     { 
         for-each [$el/following-sibling::*[
            (name()="Let") or (name()="Conclusion") or (name()="Assume") or (name()="Given") or 
	    (name()="Take") or (name()="TakeAsVar") or (name()="Case") or (name()="Suppose") or 
	    (name()="PerCasesReasoning")][1]]
         {
	   do_nd(#thes_nr = $thes_nr);
	 }
     }
   }

   // if none of above existed, export as trivial (this is the case for last thesis)
   if [substring($res, 1, 8) = 'mizar_nd'] { $res; }
   else
   {
     "mizar_nd("; "inference("; "trivial"; ","; "[]"; ","; "[]"; "))";
   }
}

//          if this is the last thesis, then the inference is "trivial"     
// private for try_nd_inference()
// we look for an expansion in the following thesis (only for PerCasesReasoning for
// the expansion of the thesis following its PerCases item)
tpl do_nd(#thes_nr,#do_th_exps) 
{
   "mizar_nd("; "inference(";
   $inm = `name()`;

   $thexps0 =
   {
     if [($inm = "PerCasesReasoning")]
     {
        for-each [PerCases]
	{
	  if [(following-sibling::*[1]/ThesisExpansions/Ref)]
	  {
	    for-each [following-sibling::*[1]/ThesisExpansions/Ref] 
	    { 
              refname(#el=`.`,#pl="");
	      if [not(position()=last())] { ","; }
            }
          }
        }
     }
     else { if [(following-sibling::*[1]/ThesisExpansions/Ref)]
     {
       for-each [following-sibling::*[1]/ThesisExpansions/Ref] 
       { 
         refname(#el=`.`,#pl="");
	 if [not(position()=last())] { ","; }
       }
     }}
   }

   $thexps = { if [string-length($thexps0) > 0] { $thexps0; ","; } }

   $thexps1 = 
   {
      if [string-length($thexps0) > 0] { "thesis_expansions(["; $thexps0; "])"; }
   }

   choose 
   { 
       when [($inm = "Let")]
       {
         "let"; ","; "["; $thexps1; "]"; ","; "[";
	 $thexps;
         get_henkin_axioms(); ",";
         thesisname(#n = `$thes_nr + 1`, #pl = `@plevel`); "]";
       }
       when [($inm = "Take") or ($inm = "TakeAsVar")]
       {
         "take"; ","; "["; $thexps1; "]"; ","; "[";
	 $thexps;
         thesisname(#n = `$thes_nr + 1`, #pl = `@plevel`); "]";
       }
       when [($inm = "Assume") or ($inm = "Case") or ($inm = "Suppose")]
       {
         "discharge_asm"; ","; "["; $thexps1;
	 if [string-length($thexps1) > 0] { ","; }
         // ###TODO: write this and uncomment!
//         get_assumptions(#el = `.`); ",";
         "discharged(["; 
         for-each [Proposition] 
         { 
           plname(#n=`@propnr`, #pl=`@plevel`);
           if [not(position() = last())] { ","; }
         } 
         "])"; "]"; ","; "[";
	 $thexps;
         thesisname(#n = `$thes_nr + 1`, #pl = `@plevel`); "]";
       }
       when [($inm = "Given")]
       {
         "discharge_asm"; ","; "["; $thexps1;
	 if [string-length($thexps1) > 0] { ","; }
//         get_assumptions(#el = `.`); ",";
         "discharged(["; 
         for-each [Proposition[1]] { plname(#n=`@propnr`, #pl=`@plevel`); }
         "])"; "]"; ","; "[";
	 $thexps;
         thesisname(#n = `$thes_nr + 1`, #pl = `@plevel`); "]";
       }
       when [($inm = "Conclusion")]
       {
         "conclusion"; ","; "["; $thexps1;
	 "]"; ","; "[";
	 $thexps;
         plname(#n=`*[1]/@propnr`, #pl=`*[1]/@plevel`); ",";
         thesisname(#n = `$thes_nr + 1`, #pl = `@plevel`); "]";
       }

// ##NOTE: the thesis numbering in PerCasesReasoning is following:
// $thes_nr+1+PCR's plevel: the thesis preceding the whole block (justified by implications, and PerCases)
// 1+PCR's newlevel: the first cases BlockThesis - i.e. implication, justified by discharging
//                     the first cases' assumptions and its thesis
// ...
// N+PCR's newlevel: the last cases BlockThesis (i.e. implication)
// ##NOTE: the possible ThesisExpansions are now kept at the thesis following 
//         PerCases 
       when [($inm = "PerCasesReasoning")]
       {
         "percases"; ","; "["; $thexps1; "]"; ","; "[";
	 $thexps;
	 for-each [CaseBlock|SupposeBlock]
	 {
	   thesisname(#n = `position()`, #pl = `@plevel`); ",";
	 }
	 for-each [PerCases/Proposition]
	 {
	   plname(#n=`@propnr`, #pl=`@plevel`);
	 }
	 "]";
       }
       otherwise { $fail; $inm; }
   }
   "))";
}


// SchemePremises implies SchemeThesis
// the proof might rather be 'implication intro' - no
// the proof is standard, the premises are printed, because
// we just traverse all propositions. Note the following hacks:
// - scheme functors and preds get empty level (i.e. are defined globally)
// - the scheme gets empty level (i.e. one level up)
// - the scheme's proof is raised too (i.e. one number); on that proof level
//   exist only the premises and the thesis (this is standard), the premises are 
//   treated as assumptions, the thesis as a proved conclusion
tpl [SchemeBlock] 
{ 
    $sname = `concat('s',@schemenr,'_',$anamelc)`;
    "fof("; $sname; ",theorem,"; "(";
    if [SchemePremises/Proposition] 
    { "( "; 
       ilist( #separ=$and_s, #elems=`SchemePremises/Proposition/*`,
	      #pl=`@newlevel`); 
       " ) "; $imp_s; 
    }
    apply[Proposition/*](#pl=`@newlevel`); ")";
    ",file("; $anamelc; ","; $sname; "),[mptp_info("; 
    `@schemenr`; ",[],"; "scheme,position("; `@line`; ","; 
    `@col`; "),["; `@schemenr`; "])"; 
    // only Proof and SkippedProof
    try_inference( #el=`*[position() = (last() - 1)]`,#pl=`@newlevel`,#nl=`@newlevel`); ",";

// the ND stuff
    "mizar_nd("; "inference("; "discharge_asm"; ","; "["; 
// ###TODO: write this and uncomment!
//         get_assumptions(#el = `.`); ",";
    "discharged(["; 
    for-each [SchemePremises/Proposition] 
    { 
      plname(#n=`@propnr`, #pl=`@plevel`);
      if [not(position() = last())] { ","; }
    }
    "])"; "]"; ","; "[";
    plname(#n=`Proposition/@propnr`, #pl=`Proposition/@plevel`);
    "]"; "))";

    "]).\n"; 
}

// SchemePremises implies SchemeThesis
tpl [Scheme] 
{ 
    $sname = lc(#s=`concat('s',@nr,'_',@aid)`);
    "fof("; $sname; ",theorem,"; "(";
    if [count(*)>2] { "( "; 
       ilist( #separ=$and_s, #elems=`*[position() > 2]`);
	      " ) "; $imp_s; }
    apply[*[position()=2]]; ")";
    ",file("; lc(#s=`@aid`); ","; $sname; "),[mptp_info("; 
    `@nr`; ",[],"; "scheme,position(0,0),[0])]).\n"; 
}


tpl [JustifiedTheorem/Proposition] 
{ 
    "fof("; absr(#el=`..`); ",theorem,";
    apply(#pl=`@plevel`);
    ",file("; $anamelc; ","; absr(#el=`..`); "),[mptp_info("; 
    `../@nr`; ",[],"; "theorem,position("; `@line`; ","; 
    `@col`; "),["; if [@nr] { `@nr`;} else { "0";} 
    add_mizar_item();
    "])"; 
    try_inference(#el=`../*[2]`,#pl=`@plevel`, #prnr=`@propnr`);
    "]).\n"; 
}

tpl [Theorem] 
{ 
    "fof("; absr(#el=`.`); ",";
    $kword = { if [@kind="T"] { "theorem"; } else {
       if [@kind="D"] { "definition"; } else { $fail; } } }
    $kword; ",";
    apply; ",file("; lc(#s=`@aid`); ",";
    absr(#el=`.`); "),[mptp_info("; `@nr`; ",[],"; $kword; 
    ",position(0,0),[0])]).\n"; 
}


// ##GRM: Mptp_Info : "mptp_info(" 
//           Item_Number "," Level "," Item_Kind ","
//           Position "," "[" Item_Arguments "]" ")" .
tpl [DefTheorem/Proposition] 
{ 
   "fof("; absr(#el=`..`); ",definition,";
    apply(#pl=`@plevel`);
    ",file("; $anamelc; ","; absr(#el=`..`); "),[mptp_info("; 
    `../@nr`; ",[],"; "definition,position("; `@line`; ","; 
    `@col`; "),["; 
    if [@nr] { `@nr`;} else { "0";} 
    add_mizar_item();
    "]"; ")]).\n"; 
}

// add the name of the mizar item which introduced the current proposition
// private - assumes that we are inside Proposition, Now, IterEquality:
//
// Assume,Case,Conclusion,Given (expanded as assume and consider),PerCases,Suppose,
// Consider(2 kinds of props),Reconsider,
// DefTheorem,JustifiedTheorem,SchemeBlock,SchemePremises,
// Coherence,Compatibility,Consistency,Correctness,Existence,Uniqueness,UnknownCorrCond,
// JustifiedProperty
//
// additionally, regular statements can have just block parents, Proof, Now, and Article,
// and IterStep (never makes it here) gets iterstep
//
// ##GRM: Mizar_Item: "mizar_item(" Mizar_Item_Name ")" .
// ##GRM: Mizar_Item_Name: 
// ##GRM:       "assume" | "case" | "conclusion" | "percases" | "suppose"
// ##GRM:       | "consider_definition" | "consider_justification" | "reconsider"
// ##GRM:       | "deftheorem" | "justifiedtheorem" | "schemethesis" | "schemepremise"
// ##GRM:       | "coherence" | "compatibility" | "consistency" | "correctness" 
// ##GRM:       | "existence" | "uniqueness" | "unknowncorrcond"
// ##GRM:       | "unexpectedprop" | "symmetry" | "reflexivity" | "irreflexivity" 
// ##GRM:       | "associativity" | "transitivity" | "commutativity" | "connectedness"
// ##GRM:       | "antisymmetry" | "idempotence" | "involutiveness" | "projectivity" | "abstractness"
// ##GRM:       | "auxiliary_lemma" | "iterstep" .
tpl add_mizar_item
{
// temporarily commented to compile
  ",mizar_item(";
  $parent_nm = `name(..)`;
  choose 
  { 
     when [$parent_nm = "SchemeBlock"] { "schemethesis"; }
     when [$parent_nm = "SchemePremises"] { "schemepremise"; }
     when [$parent_nm = "JustifiedProperty"] 
     { 
       lc(#s = `name(preceding-sibling::*[1])`);
     }
     when [$parent_nm = "Consider"]
     { 
       if [preceding-sibling::Typ] { "consider_definition"; } 
       else { "consider_justification"; }
     }
     when [$parent_nm = "Given"]
     {
       // "given" is intentionally exported as an "assume" followed by a
       // "consider" - it is just a macro (like e.g. "hereby")
       if [preceding-sibling::Typ] { "consider_definition"; } 
       else { "assume"; }
     }
     when [($parent_nm = "Proof") or ($parent_nm = "Now") or 
           ($parent_nm = "Article") or (contains($parent_nm, "Block"))]
     {
       "auxiliary_lemma";
     }
     otherwise { lc(#s = $parent_nm); }
  }

  ")";
}


tpl dumproptable()
{
 if[$dump_prop_labels > 0]
 {

// <xsl:document href="{$anamelc}.propnames" format="text">
   for-each [//Proposition|//IterEquality|//Now]
   {
    if [@nr>0] 
    {
       $pname = plname(#n=`@propnr`, #pl=`@plevel`);
       $nm = { get_vid_name(#vid = `@vid`); }
       "propname("; $pname; ",'"; $nm; "').\n";
    }
   }
// </xsl:document>
       $bogus=`1`;
 }
}

tpl [Proposition] 
{ 
    $pname = plname(#n=`@propnr`, #pl=`@plevel`);

    $consider_kind =
    { 
      if [((name(..) = "Consider") or (name(..) = "Given"))]
      {
        if [preceding-sibling::Typ] { "1"; } else { "2"; }
      }
      else { "0"; }
    }

    "fof(";  $pname; ","; 
    if [following-sibling::*[1][name() = "By" or name() = "From" or name() = "Proof"]] 
    { 
      $derived_lemma;
    } 
    else { if [$consider_kind = 1] { $derived_lemma; } // derived in ND-sense
    else
    {
      "assumption"; 
    }}
    ",";
    apply(#pl=`@plevel`); ",file("; $anamelc; 
    ","; $pname; "),[mptp_info("; `@propnr`; ",["; 
    `translate(@plevel,"_",",")`; "],proposition,position("; `@line`; ","; 
    `@col`; "),["; if [@nr] { `@nr`;} else { "0";} 
    add_mizar_item();
    if [$consider_kind = 2] // keep a list of all considered constants here for easy lookup
    {
        ","; "considered_constants([";
        $cnr = `../@constnr`; $pl=`@plevel`; 
	for-each [../Typ] 
	{
	  $pos1 = `position()`; 
	  $nr   = `$cnr + $pos1 - 1`; 
	  "c"; $nr; addp(#pl=$pl);
	  if [not(position()=last())] { ","; }
        }
	"])";
    }
    "])";
    try_inference(#el=`following-sibling::*[1]`,#pl=`@plevel`,#prnr=`@propnr`);
    if [$consider_kind = 1]
    {
      ","; "mizar_nd("; "inference(";
      "consider"; ","; "[]"; ","; "[";
      for-each [..] { get_henkin_axioms(); } ",";
      for-each [../Proposition[1]] { plname(#n=`@propnr`, #pl=`@plevel`); }
      "]))";
    }
    "]).\n"; 
}

tpl [Now] 
{ 
   $pname = plname(#n=`@propnr`, #pl=`@plevel`);
   "fof(";  $pname; ","; $derived_lemma; ",";
   apply[BlockThesis/*[position() = last()]](#pl=`@plevel`); ",file("; $anamelc; 
   ","; $pname; "),[mptp_info("; `@propnr`; ",["; 
   `translate(@plevel,"_",",")`; "],proposition,position("; `@line`; ","; 
   `@col`; "),["; 
   if [@nr] { `@nr`;} else { "0";} 
   add_mizar_item();
   "]),"; 
   proofinfer(#el=`.`,#pl=`@plevel`,#prnr=`@propnr`); ",";
   try_nd_inference(#el = `BlockThesis/*[position() = last()]`, #thes_nr = "0");
   "]).\n"; 
}

tpl [IterEquality] 
{ 
   $pname = plname(#n=`@propnr`, #pl=`@plevel`);
   "fof(";  $pname; ","; $derived_lemma; ",";
   "( "; apply[*[1]](#pl=`@plevel`); $eq_s; 
   apply[IterStep[position() = last()]/*[1]](#pl=`@plevel`); " )";
   ",file("; $anamelc; 
   ","; $pname; "),[mptp_info("; `@propnr`; ",["; 
   `translate(@plevel,"_",",")`; "],proposition,position("; `@line`; ","; 
   `@col`; "),["; if [@nr] { `@nr`;} else { "0";} 
   add_mizar_item();
   "]),"; 
   proofinfer(#el=`.`,#pl=`@plevel`,#prnr=`@propnr`); ",";
   "mizar_nd("; "inference("; "iterative_eq"; ","; "[]"; ","; "[";
   for-each [IterStep] 
   { 
      plname(#n=`@propnr`, #pl=`@plevel`);
      if [not(position() = last())] { ","; }
   }
   "]"; "))";
   "]).\n"; 
   apply[IterStep]; 
}

// ##NOTE: not sure if IterStep should be treated as just auxiliary_lemma, or
//          as a special kind of skeleton item, which changes the thesis
//          to equality with the next term. So I'll better use iterstep to 
//          preserve the info for now.
// ##SOLUTION: currently the IterEquality is justified by mizar_proof, and also
//             by "mizar_nd(iterative_eq,...", which just contains all the internal
//             Iterstep equalities.
tpl [IterStep] 
{ 
   $pname = plname(#n=`@propnr`, #pl=`@plevel`);
   "fof(";  $pname; ","; $derived_lemma; ","; "( "; 
   if [name(preceding-sibling::*[1])="IterStep"] 
   {
      apply[preceding-sibling::*[1]/*[1]](#pl=`@plevel`); 
   }
   else 
   { 
      apply[preceding-sibling::*[1]](#pl=`@plevel`); 
   }
   $eq_s; apply[*[1]](#pl=`@plevel`); " )";
   ",file("; $anamelc; 
   ","; $pname; "),[mptp_info("; `@propnr`; ",["; 
   `translate(@plevel,"_",",")`; "],proposition,position("; `*[2]/@line`; ",";
   `*[2]/@col`; "),["; if [@nr] { `@nr`;} else { "0";} 
   ",mizar_item(iterstep)";
   "])"; 
   try_inference(#el=`*[2]`,#pl=`@plevel`,#prnr=`@propnr`);
   "]).\n"; 
}

// #nl is only passsed to proofinfer when dealing with schemes;
// it is also used to prevent trying ND for schemes
tpl try_inference(#el,#pl,#prnr,#nl) 
{ 
  for-each [$el] 
  {
    if [name() = "By"] { ",";
       byinfer(#el=`.`,#pl=$pl,#prnr=$prnr); }
    else { if [name() = "From"] { ",";
       frominfer(#el=`.`,#pl=$pl,#prnr=$prnr); }
    else { if [name() = "Proof"] { ",";
       proofinfer(#el=`.`,#pl=$pl,#prnr=$prnr,#nl=$nl); 
       if [not($nl)] 
       {
         ",";
	 try_nd_inference(#el = `BlockThesis/*[position() = last()]`, #thes_nr = "0");
       }
    }
    else { if [name() = "SkippedProof"] { ",";
       skippedinfer(#el=`.`,#pl=$pl,#prnr=$prnr); }
  }}}}
}


tpl skippedinfer(#el,#pl,#prnr) { "inference(mizar_skipped_proof,[],[])"; }

// ##GRM: By_Inference: "inference(" "mizar_by" "," "[" "]" "," "[" References "]" ")".
// assumes By
tpl byinfer(#el,#pl,#prnr) { for-each [$el] {
    "inference(mizar_by,[";
    "position("; `@line`; ","; `@col`; ")],"; 
    "["; refs(#el=`.`,#pl=$pl,#prnr=$prnr); "])"; }}

// handles Refs for From, (possibly linked) By and ThesisExpansions
// ignores possible ThesisExpansions/Pair - each has a Ref added to it
tpl refs(#el,#pl,#prnr) 
{  
  for-each [$el] 
  {
    if [@linked] 
    { 
       if [name(..)="IterStep"] {
	  plname(#n=`../../@propnr - 1`,#pl=`../../@plevel`); } 
       else { if [$prnr>1] {
	  plname(#n=`$prnr - 1`,#pl=$pl); }
	  // Since MML 1136, "then per cases" is possible
	  else { if [(name(..)="PerCases") and (name(../..)="PerCasesReasoning")] { prevpropname(#el=`../..`); }
	  else { $fail; } 
       }}
      if [Ref|PolyEval] { ","; } 
    }
    else { if [name()="From"] 
    { 
	 sch_instname(#el=`.`, #pl=$pl, #prnr=$prnr); 
	 if [Ref|PolyEval] { ","; }
    }}

    for-each [Ref] 
    { 
       refname(#el=`.`,#pl=$pl); 
       if [not(position()=last())] { ","; } 
    }
    
    if [PolyEval]
    {
       if[Ref] { ","; }
       for-each [PolyEval] 
       { 
          polyeval_name(#el=`.`,#pl=$pl); 
	  if [not(position()=last())] { ","; } 
       }
    }
  }
}

// TODO: this is needed just for finding the linked reference for PerCases -
// - a bit annoying; we could promote PerCases one level up to get rid of this.
tpl prevpropname(#el) { 
    for-each [$el/preceding-sibling::*[(name() = "Assume") or (name() = "Given") 
	 or (name() = "Conclusion") or (name() = "Case") 
	 or (name() = "Suppose") or (name() = "Now") 
	 or (name() = "Proposition") or (name() = "IterEquality")][1]]
    {
    if[(name() = "Proposition") or (name() = "Now") or (name() = "IterEquality")]
    { 
       plname(#n=`@propnr`, #pl=`@plevel`);
    }
    else {   for-each[*[(name() = "Proposition") or (name() = "Now") or (name() = "IterEquality")]]
    {
      plname(#n=`@propnr`, #pl=`@plevel`);
    }
}}}

tpl [FuncInstance](#pl) { $k = `@kind`;
    sch_fpname(#k="f",#nr=`@instnr`,#schnr=`@instschemenr`, #aid=`@instaid`); 
    "/";
    // instantiated to other functor
    if [$k] { choose { 
       when [$k="K"] { absc(#el=`.`); }
       when [$k="F"] { abs_fp(#k="f",#el=`.`); }
       when [$k="H"] { "("; priv_def(#k="pf",#nr=`@nr`,#pl=$pl); ")";}
       otherwise { $fail; }
    }}
    // instantiated to term
    else { if [*[1]] { "([] : "; apply[*[1]](#pl=$pl); ")"; } else { $fail; } } }

tpl [PredInstance](#pl) { $k = `@kind`;
    sch_fpname(#k="p",#nr=`@instnr`,#schnr=`@instschemenr`, #aid=`@instaid`); 
    "/";
    choose { 
	     when [$k="R"] { absc(#el=`.`); }
	     when [$k="P"] { abs_fp(#k="p",#el=`.`); }
	     when [$k="S"] { "("; priv_def(#k="pp",#nr=`@nr`,#pl=$pl); ")";}
	     otherwise { $fail; }
    }}

tpl [SchemeInstantiation](#pl) { "[";
    for-each [FuncInstance | PredInstance] { apply[.](#pl=$pl); 
	     if [not(position()=last())] { ","; } }
    "]"; }

// assumes From, introduces a unique name for this scheme instance
// ##GRM: Scheme_Inference : 
//          "inference(mizar_from,[scheme_instance(" 
//          Scheme_Instance_Name "," Scheme_Name "," Proposition_Name
//          "," Aid "," Scheme_Instantiation ")],[" 
//          Scheme_Instance_Name [ "," References ] "])" .   
tpl frominfer(#el,#pl,#prnr) { for-each [$el] {
    "inference(mizar_from,[";
    "position("; `@line`; ","; `@col`; "),"; 
    "scheme_instance("; 
    sch_instname(#el=`.`, #pl=$pl, #prnr=$prnr); ",";
    absr(#el=`.`); ","; plname(#n=$prnr,#pl=$pl); ","; $anamelc; ",";
    apply[SchemeInstantiation](#pl=$pl); ")],[";
    refs(#el=`.`,#pl=$pl,#prnr=$prnr); "])";
}}


// ###TODO: finish the description!! 
// assumes Proof, Now or IterEquality,
// selects all references (no matter what their level is) used for
// justifying anything inside the proof (so e.g. assumption, which 
// is never used to justify anything willnot be listed). This is a 
// bit arbitrary choice, because in computing background theory for 
// a given proof, this is not sufficient for getting a complete 
// symbol set (all formulas inside the proof have to be collected anyway).
// Another options would be to encode just the Mizar ND proof's 
// last inference (e.g. "universal intro", if the proof starts with "let"),
// or to encode only the formulas on the child level.
// ##GRM: Proof_Inference : 
//          "inference(mizar_proof,[proof_level(" Level ")], 
//          [ References ] ")" .   
// seems that #pl and #prnr are no longer used, only #nl is used to possibly
// override #el's own @newlevel (used for schemes)
tpl proofinfer(#el,#pl,#prnr,#nl) 
{ 
  for-each [$el] 
  {
    "inference(mizar_proof,[proof_level(["; 
    if [$nl] { `translate($nl,"_",",")`; }
    else { if [@newlevel] { `translate(@newlevel,"_",",")`; }
    else { $fail; }}
     "])],["; 
    for-each [.//By[((name(preceding-sibling::*[1])="Proposition") 
	              or (name(..)="IterStep"))
	            and ((@linked="true") or (count(Ref)>0))] 
	     | .//From[((name(preceding-sibling::*[1])="Proposition") 
	                 or (name(..)="IterStep"))]
             | .//ThesisExpansions[count(Ref)>0]] 
    { 
      if [name()="ThesisExpansions"] { refs( #el=`.`); }
      else { if [name(..)="IterStep"] {  
	     refs( #el=`.`,#pl=`../@plevel`,#prnr=`../@propnr`); }
        else 
	{
	      refs( #el=`.`,#pl=`preceding-sibling::*[1]/@plevel`,
		    #prnr=`preceding-sibling::*[1]/@propnr`); 
        }
      }
      if [not(position()=last())] { ","; } 
    }
    "])";
  }
}


// create name and info for a scheme instance
tpl sch_instname(#el,#pl,#prnr) { for-each [$el] { absr(#el=`.`); 
    "__"; abspropname(#n=$prnr,#pl=$pl); }}

// uncomment apply[Proposition] if not used explicit descent
// constant arising from "Given" are treated as if they came from "Consider"
// Let typing is treated as an assumption, the rest of typings are derived,
// in case of Consider (and thus also Given) by an ND argument
tpl [Let|Given|TakeAsVar|Consider|Set] 
{ 
  $cnr = `@constnr`; $pl=`@plevel`; 
  $rnm = { if [name() = "Given"] { "consider"; } else { lc(#s=`name()`); } }
  for-each [Typ] 
  {
      $pos1 = `position()`; 
      $nr   = `$cnr + $pos1 - 1`; 
      $nm   =  { "c"; $nr; addp(#pl=$pl); }
      $levl = { ",["; `translate($pl,"_",",")`; "],";}
      "fof(dt_";  $nm; ","; 
      if [$rnm = "let"] { "assumption"; } else { $derived_lemma; }
      ","; $srt_s; "("; $nm; ",";
      apply[.](#pl=$pl); ")"; ",file("; $anamelc; ","; $nm;
      "),[mptp_info("; $nr; $levl; "constant,position(0,0),["; $rnm; 
      ",type])";
      if [($rnm = "takeasvar") or ($rnm = "set")]
      {
        ","; "inference(mizar_by,["; $rnm; "],[de_"; $nm; "])";
      }
      else { if [($rnm = "consider")]
      {
        ","; "mizar_nd("; "inference(";
        "consider"; ","; "[]"; ","; "[";
	for-each [..] { get_henkin_axioms(#tpos = $pos1); } ",";
	for-each [../Proposition[1]] { plname(#n=`@propnr`, #pl=`@plevel`); }
	"]))";
      }}
      "]).\n"; 
      if [($rnm = "takeasvar") or ($rnm = "set")] 
      {
	 "fof(de_";  $nm; ",definition,"; "( "; $nm; $eq_s; 
	 apply[../*[not(name() = "Typ")]](#pl=$pl); " )";
	 ",file("; $anamelc; ","; $nm; "),[mptp_info("; $nr; $levl;
	 "constant,position(0,0),["; $rnm; ",equality])]).\n"; 
      } 
  }
//    apply[Proposition];
}

// New reconsider has the same type for each term now - this is
// hopefully a compatible way for both new and old.
// The typing is justified by the proposition and the equality def.
// That should be OK for problem creation using mizar_by - the type
// statement will be deleted from the axioms, and the rest of BG are just 
// general theorems, nothing specific about the constant.
// The proposition is generated before the types and equalities, otherwise in MizAR
// the article_position is wrong, resulting in bad .allowed_local info
tpl [Reconsider] 
{ 

  $cnr     = `@constnr`; 
  $pl      = `@plevel`; 
  apply[Proposition](#pl=$pl);
  $prop_nm = plname(#n=`Proposition/@propnr`, #pl=`Proposition/@plevel`);
  for-each [Var|LocusVar|Const|InfConst|Num|Func|PrivFunc|Fraenkel|
	      QuaTrm|It|Choice|ErrorTrm] 
  {
      $nr   = `$cnr + position() - 1`; 
      $nm   =  { "c"; $nr; addp(#pl=$pl); }
      $levl = { ",["; `translate($pl,"_",",")`; "],";}
      "fof(dt_";  $nm; ","; $derived_lemma; ","; $srt_s; "("; $nm; ",";
      apply[../Typ[position() = 1]](#pl=$pl); ")"; ",file("; $anamelc; ","; $nm;
      "),[mptp_info("; $nr; $levl; 
      "constant,position(0,0),[reconsider,type]),";
      "inference(mizar_by,[reconsider],[de_"; $nm; ","; $prop_nm; "])";
      "]).\n";

      "fof(de_";  $nm; ",definition,"; "( "; $nm; $eq_s; 
      apply[.](#pl=$pl); " )"; ",file("; $anamelc; ","; $nm; "),[mptp_info("; 
      $nr; $levl; "constant,position(0,0),[reconsider,equality])]).\n";
  }
}

// The argument types of scheme functors are forgotten by Mizar
// so we do not use them either and use $true.
// The proof level is just [], to be compatible with scheme
// proof level. The scheme to which this belongs is remembered 
// instead in the Item_Arguments.
tpl [SchemeFuncDecl] 
{ 
    $pl   = `@plevel`; 
    $schnr= `../@schemenr`;
//  $levl = { ",["; `translate($pl,"_",",")`; "],"; }
    $levl = { ",[],"; }  
    $sname = `concat('s',$schnr,'_',$anamelc)`;
//  $nm   =  { "f"; `@nr`; addp(#pl=$pl); }
    $nm   = { sch_fpname(#k="f",#nr=`@nr`,#schnr=`../@schemenr`,#aid=$aname); }
    $l    = `count(ArgTypes/Typ)`;

    "fof(dt_";  $nm; ",axiom,"; 
    if [$l > 0] 
    { 
       "!["; 
       for-each [ArgTypes/Typ] 
       { 
          ploci(#nr=`position()`); 
	  " : $true"; 
	  if [not(position()=last())] { ","; } 
       }
       "]: "; 
    }

    $srt_s; "("; $nm;
    if [$l > 0] 
    { 
       "("; arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; 
    }
    ","; apply[Typ](#pl=$pl); ")";
    ",file("; $anamelc; ","; $nm; "),[mptp_info("; `@nr`; $levl;
    "functor,position(0,0),[scheme,type,"; $sname; "])]).\n"; 
}


// "M" | "L" | "V" | "R" | "K" | "U" | "G"
// ###TODO: add the inference, do the properties
tpl [Constructor] 
{ 
    $lkind = { lc(#s=`@kind`); } 
// the type hierarchy formula for "M" | "L" | "K" | "U" | "G"
    if [(@kind='M') or (@kind='L') or (@kind='K') or 
        (@kind='U') or (@kind='G')] 
    {
      "fof(dt_";  absc1(#el=`.`); ","; $derived_lemma; ",";
      apply[ArgTypes];
      $l = `1 + count(ArgTypes/Typ)`;
      if [(@kind='M') or (@kind='L')] 
      {
        "!["; ploci(#nr=$l); " : "; "$true"; "]: ("; 
        $srt_s; "("; ploci(#nr=$l); ","; absc1(#el=`.`); 
        if [$l > 1] { "("; 
           arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
        ")"; $imp_s;
        if [count(Typ) = 0] { $srt_s; "("; ploci(#nr=$l); ",$true)"; }

        if [count(Typ) > 1] { "("; }
        for-each [Typ] {
           $srt_s; "("; ploci(#nr=$l); ","; apply[.]; ")";
           if [not(position()=last())] { $and_s; }
        }
        if [count(Typ) > 1] { ")"; }
        ")";
      }  
      else  { if [(@kind='K') or (@kind='U') or (@kind='G')] 
      {
        $srt_s; "("; absc1(#el=`.`);
        if [$l > 1] { "("; 
           arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
	",";
        apply[Typ]; ")";
      }}
      
      ",file("; lc(#s=`@aid`); ",";
      absc1(#el=`.`); "),[mptp_info("; `@nr`; ",[],"; $lkind; 
      ",position(0,0),[ctype])]).\n"; 
    }
    apply[Properties](#el=`.`);
    if [@kind='G'] { free_prop(#el=`.`); }
    if [(@kind='M') or (@kind='L')] {	 existence(#el=`.`); }
    if [@redefnr > 0] { redefinition(#el=`.`); }
}

tpl existence(#el) 
{ 
  for-each [$el] 
  {
      $lkind = { lc(#s=`@kind`); } 
      "fof(existence_"; absc1(#el=`.`); ","; $derived_lemma; ",";
      apply[ArgTypes]; 
      $l = `1 + count(ArgTypes/Typ)`;
      "? ["; ploci(#nr=$l); " : "; "$true"; "]: "; 
      $srt_s; "("; ploci(#nr=$l); ","; absc1(#el=`.`); 
      if [$l > 1] 
      { 
        "("; arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; 
      }
      ")";
      ",file("; lc(#s=`@aid`); ",";
      absc1(#el=`.`); "),[mptp_info("; `@nr`; ",[],"; $lkind; 
      ",position(0,0),[existence])]).\n"; 
  }
}


// ##GRM: Redef_Info : "redefinition(" Redefined_Constr_Nr "," 
//           Redefined_Constr_Kind "," Redefined_Constr_Aid "," 
//           Redefined_Constr_Name ")" .
tpl redefinition(#el) 
{ 
    $lkind  = { lc(#s=`$el/@kind`); }
    $redaid = { lc(#s=`$el/@redefaid`); }
    $absn   = absc1(#el=$el); $n = `$el/@nr`;
    $f      = { lc(#s=`$el/@aid`); }
    $s      = `@superfluous`;
    for-each [$el] 
    {
      "fof(redefinition_"; $absn; ",definition,";
      apply[ArgTypes]; 
      $l0 = `count(ArgTypes/Typ)`;
      if [(@kind = 'K') or (@kind = 'R')] 
      { 
        "( "; absc1(#el=`.`); 
	if [$l0 > 0] { "("; arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
	if [@kind = 'K'] { $eq_s; } else { $equiv_s; }

	if [(@kind='R') and (@absredefnr=1) and (@redefaid="HIDDEN")] {
	    "( "; ploci(#nr=`$l0 - 1`); $eq_s; ploci(#nr=$l0); " )"; }
        else { 
	     absredef(#el=`.`); 
	     if [$l0 > $s] { "("; 
		arglist(#separ=",",#elems=`ArgTypes/Typ[position() > $s]`,#s=$s); 
		")";
             }
	} ")";
      } else { if [(@kind = 'V') or (@kind = 'M')] 
      {
	 $l = { if [@kind = 'V'] { $l0; } else { `$l0 + 1`; } }
	 if [@kind = 'M'] 
	 { 
	    "!["; ploci(#nr=`$l`); ": "; 
	    // This is too strong, the original type can hardly get
	    // the redefinition's result type
	    // apply[Typ]; 
	    "$true"; "]: "; 
         }
	 "( "; $srt_s; "("; ploci(#nr=$l); ","; absc1(#el=`.`);
	 if [$l>1] 
	 { 
            "("; arglist(#separ=",",#elems=`ArgTypes/Typ[position() < $l]`);
            ")"; 
	 }
	 ")"; $equiv_s; $srt_s; "("; ploci(#nr=$l); ","; 
	 absredef(#el=`.`); 
	 if [($l - $s) > 1] 
	 { 
	    "("; 
	    arglist(#separ=",",#elems=`ArgTypes/Typ[(position() > $s) 
                                  and (position() < $l)]`, #s=$s); ")"; 
	 } 
	 "))"; 
      }}
      ",file("; $f; ","; $absn; "),[mptp_info("; $n; ",[],"; $lkind; 
      ",position(0,0),[redefinition("; `@absredefnr`; ","; $lkind; 
      ","; $redaid; ","; absredef(#el=`.`); ")])]).\n"; }
}

// free property - this is rather definition than theorem
// g(x1,x2) = g(x3,x4) implies (x1 = x2 and x3 = x4)
tpl free_prop(#el) 
{ 
    $lkind = { lc(#s=`$el/@kind`); }
    $absn  = absc1(#el=$el); $n = `$el/@nr`;
    $f     = { lc(#s=`$el/@aid`); }

    for-each [$el] 
    {
      "fof(free_"; $absn; ",definition,";
      apply[ArgTypes]; 
      $s=`count(ArgTypes/Typ)`;
      "!["; 
      for-each [ArgTypes/Typ] 
      { 
          ploci(#nr=`position() + $s`); " : $true"; 
          if [not(position()=last())] { ","; } 
      }
      "]: ";
      "(( "; absc1(#el=`.`); "("; 
      arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; $eq_s; 
      absc1(#el=`.`); "("; 
      arglist(#separ=",",#elems=`ArgTypes/Typ`,#s=$s); "))"; $imp_s; "( ";
      for-each [ArgTypes/Typ] 
      { 
	  $p=`position()`;
	  "( "; ploci(#nr=$p); $eq_s;  ploci(#nr=`$p+$s`); ")";
	  if [not($p=last())] { $and_s; }
      }
      "))";
      ",file("; $f; ","; $absn; "),[mptp_info("; $n; ",[],"; 
      $lkind; ",position(0,0),[property(free)])]).\n"; 
    }
}

tpl [Properties](#el) 
{ 
    $a1    = `@propertyarg1`; 
    $a2    = `@propertyarg2`;
    $lkind = { lc(#s=`$el/@kind`); }
    $absn  = absc1(#el=$el); $n = `$el/@nr`;
    $f     = { lc(#s=`$el/@aid`); }

    for-each [*] 
    {
      $nm = { lc(#s=`name()`); }
      if [not($nm = "sethood")]  // no formula for sethood, we trust Mizar with Fraenkels
      {
        "fof(";  $nm; "_"; $absn; ",theorem,";
        apply[.](#el=$el,#arg1=$a1,#arg2=$a2);
        ",file("; $f; ","; $absn; "),[mptp_info("; $n; ",[],"; 
        $lkind; ",position(0,0),[property("; $nm; ")])]).\n"; 
      }
    }
}


tpl [UnexpectedProp](#el,#arg1,#arg2) { "$true"; } 

tpl symmetry(#el,#arg1,#arg2,#anti) 
{ 
  for-each [$el] 
  {
    apply[ArgTypes]; "( "; absc1(#el=`.`); "("; 
    arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; $imp_s;
    if [$anti=1] { $not_s; } absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,#lim=`count(ArgTypes/Typ)`); 
    "))"; 
  }
}

tpl [Symmetry](#el,#arg1,#arg2) { symmetry(#el=$el,#arg1=$arg1,#arg2=$arg2); } 
tpl [Antisymmetry](#el,#arg1,#arg2) { 
    symmetry(#el=$el,#arg1=$arg1,#arg2=$arg2,#anti="1"); } 

tpl reflexivity(#el,#arg1,#arg2,#anti) 
{ 
  for-each [$el] 
  {
    apply[ArgTypes]; 
    if [$anti=1] { $not_s; } 
    absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,
                 #lim=`count(ArgTypes/Typ)`,#same="1"); 
    ")"; 
  }
}

tpl [Reflexivity](#el,#arg1,#arg2) { 
    reflexivity(#el=$el,#arg1=$arg1,#arg2=$arg2); }
tpl [Irreflexivity](#el,#arg1,#arg2) { 
    reflexivity(#el=$el,#arg1=$arg1,#arg2=$arg2,#anti="1"); }

tpl [Connectedness](#el,#arg1,#arg2) 
{ 
  for-each [$el] 
  {
    apply[ArgTypes]; "( "; absc1(#el=`.`); "("; 
    arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; $or_s;
    absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,#lim=`count(ArgTypes/Typ)`); 
    "))"; 
  }
}

tpl [Commutativity](#el,#arg1,#arg2) 
{ 
  for-each [$el] 
  {
    apply[ArgTypes]; "( "; absc1(#el=`.`); "("; 
    arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; $eq_s;
    absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,#lim=`count(ArgTypes/Typ)`); 
    "))"; 
  }
}

tpl [Idempotence](#el,#arg1,#arg2) 
{ 
  for-each [$el] 
  {
    apply[ArgTypes]; 
    "("; absc1(#el=`.`); "("; 
    switchedargs(#nr="1",#nr1=$arg1,#nr2=$arg2,
                 #lim=`count(ArgTypes/Typ)`,#same="1"); ")"; $eq_s; 
    ploci(#nr=$arg1); ")";
  } 
}

tpl [Involutiveness](#el,#arg1,#arg2) 
{ 
  for-each [$el] 
  {
    apply[ArgTypes]; 
    "("; absc1(#el=`.`); "(";
    $trm = { absc1(#el=`.`); "("; 
             arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
    argsinsert(#nr="1",#nr1=$arg1,#arg=$trm,#lim=`count(ArgTypes/Typ)`);
    ")"; $eq_s; ploci(#nr=$arg1); ")"; 
  }
}

tpl [Projectivity](#el,#arg1,#arg2) 
{ 
  for-each [$el] 
  {
    apply[ArgTypes]; 
    "("; absc1(#el=`.`); "(";
    $trm = { absc1(#el=`.`); "("; 
             arglist(#separ=",",#elems=`ArgTypes/Typ`); ")"; }
    argsinsert(#nr="1",#nr1=$arg1,#arg=$trm,#lim=`count(ArgTypes/Typ)`);
    ")"; $eq_s; $trm; ")"; 
  }
}

// This needs fixing for structures "over" - then the
// functor has more args than just the fields! - seems fixed now
tpl [Abstractness](#el,#arg1,#arg2) 
{ 
  for-each [$el] 
  {
    apply[ArgTypes];
    $l = `count(ArgTypes/Typ)`;
    $lasttyp = `ArgTypes/Typ[position() = last()]`;
    "(";  $srt_s; "("; ploci(#nr=$l); ","; absc1(#el=`.`);
    if [$l > 1] 
    { 
     "("; arglist(#separ=",",#elems=`ArgTypes/Typ[position() < last()]`); ")";
    }
    ")"; $imp_s; "("; ploci(#nr=$l); $eq_s;
    if [key('G',$lasttyp/@absnr)] 
    {  
       for-each [key('G',$lasttyp/@absnr)] 
       {  
         absc1(#el=`.`); "("; 
	 // print the "over" args first
	 if [$l > 1] { ft_list(#f="1",#t=`$l - 1`,#sep=",",#l="1"); ","; }
	 for-each [Fields/Field] 
	 {
	     absc(#el=`.`); "("; 
	     // the selector might have been defined earlier, without some
	     // hidden args - $f is the difference in arities
	     $f=`1 + $l - @arity`;
	     ft_list(#f=$f,#t=$l,#sep=",",#l="1"); ")";
	     if [not(position()=last())] { ","; }
	 } 
	 ")"; 
       }
    }
    else { $fail; }
    "))";
  }
}



// tpl [Abstractness](#el,#arg1,#arg2) { for-each [$el] {
//     apply[ArgTypes];
//     $l = `count(ArgTypes/Typ)`;
//     $lasttyp = `ArgTypes/Typ[position() = last()]`;
//     "(";  $srt_s; "("; ploci(#nr=$l); ","; absc1(#el=`.`);
//     if [$l > 1] { 
//      "("; arglist(#separ=",",#elems=`ArgTypes/Typ[position() < last()]`); ")";
//     }
//     ")"; $imp_s; "("; ploci(#nr=$l); $eq_s;
//     if [key('L',$lasttyp/@absnr)] {  
//        for-each [key('L',$lasttyp/@absnr)] {  
//          "g"; `@nr`; "_"; lc(#s=`@aid`);
// 	 "("; 

//     absref(#elems=`key($k,$nr)`,#r=$r); }

 
//     "("; 

// $srt_s; "("; 
//          apply[*[position() = last()]](#i=$i,#pl=$pl); ","; absc(#el=`.`); 
//          if [count(*)>1] { 
//             "("; ilist(#separ=",", #elems=`*[position() < last()]`, #i=$i,#pl=$pl); 
//             ")"; }
//          ")"; }



tpl [CCluster] 
{ 
  if [ErrorCluster] { } else {
  if [(name(..) = "Presentation")] { } 
  else 
  {
    $pres = { if[Presentation] { "1"; } else { "0"; } }
    "fof("; absk(#el=`.`,#kind="cc"); ",theorem,";
    $l = `1 + count(ArgTypes/Typ)`;
    apply[ArgTypes];
    "!["; ploci(#nr=$l); " : "; apply[Typ]; "]: ("; 
    $ante = { `count(*[$pres + 2]/*)`; }
    $succ = { `count(*[$pres + 4]/*)`; }
    $srt_s; "("; ploci(#nr=$l); ",";
    if [$ante = 0] { "$true"; } else {
    if [$ante = 1] { apply[*[$pres + 2]]; } 
    else { "( "; apply[*[$pres + 2]]; " )"; } }
    ")"; $imp_s; $srt_s; "("; ploci(#nr=$l); ",";
    if [$succ = 0] { "$true"; } else {
    if [$succ = 1] { apply[*[$pres + 4]]; } 
    else { "( "; apply[*[$pres + 4]]; " )"; } }
    "))"; ",file("; lc(#s=`@aid`); ",";
    absk(#el=`.`,#kind="cc"); "),[mptp_info("; `@nr`; 
    ",[],ccluster,position(0,0),["; 
    if [$mml="0"] 
    { 
       "proof_level(["; `translate(../@newlevel,"_",",")`; "]),"; 
       cluster_correctness_conditions(#el=`../*[position() = last()]`);
    }
    "])]).\n"; 
   }
}}

// sufficient proof refs can be collected from its coherence 
// (correctness) proof (the corr_conds are therefore written here, 
// with the proposition given as argument)
// generalization of the local consts is however needed for small-step 
// proof export, and the local consts can be re-used for other clusters
// inside this block; so then their henkin axiom will generally be a conjunction
// ##GRM: Cluster_Info: "proof_level(" Level ")" "," ( Correctness_Info | By_Inference ) .
// ##GRM: Correctness_Info: "correctness_conditions(" "[" Correctness_Proposition+ "]" ")" .
// ##GRM: Correctness_Proposition: Correctness_Condition_Name "(" Proposition_Ref ")" .
// ##GRM: Correctness_Condition_Name: "unknowncorrcond" | "coherence" | "compatibility" | 
// ##GRM:                             "consistency" | "existence" | "uniqueness" | "correctness" .
tpl [FCluster] 
{ 
  if [ErrorCluster] { } else {
  if [(name(..) = "Presentation")] { } 
  else 
  {
    $pres = { if[Presentation] { "1"; } else { "0"; } }
    "fof("; absk(#el=`.`,#kind="fc"); ",theorem,";
    apply[ArgTypes];
    $succ = { `count(Cluster[1]/*)`; }
    $srt_s; "("; apply[*[$pres + 2]];  ",";
    if [$succ = 0] { "$true"; } else {
    if [$succ = 1] { apply[Cluster[1]]; } 
    else { "( "; apply[Cluster[1]]; " )"; } }
    ")"; ",file("; lc(#s=`@aid`); ",";
    absk(#el=`.`,#kind="fc"); "),[mptp_info("; `@nr`; 
    ",[],fcluster,position(0,0),[";
    if [$mml="0"] 
    { 
       "proof_level(["; `translate(../@newlevel,"_",",")`; "]),"; 
       cluster_correctness_conditions(#el=`../*[position() > 1]`);
    }
    "])]).\n"; 
  }
}}

// private for clusters
tpl cluster_correctness_conditions(#el)
{

  "correctness_conditions([";

  for-each [$el]
  {
    $corr_nm = `name()`;
    if [Proposition]
    {
      lc(#s = $corr_nm); "(";
      plname(#n=`Proposition/@propnr`, #pl=`Proposition/@plevel`);
      ")";
    }
    else { $fail; }
    if [not(position()=last())] { ","; }
    "])";
  }
}

// ##NOTE: We need to deal with the RCluster coming from structurel 
// definitions (attribute "strict") specially, since the existence
//  is never proved in Mizar. The current choice is to forge the justification
//  by the type declaration of the appropriate 
// aggregate functor (which is defined to be "strict").
tpl [RCluster] 
{ 
  if [ErrorCluster] { } else {
  if [(name(..) = "Presentation")] { } 
  else
  {
    "fof("; absk(#el=`.`,#kind="rc"); ",theorem,";
    $l = `1 + count(ArgTypes/Typ)`;
    apply[ArgTypes];
    "?["; ploci(#nr=$l); " : "; apply[Typ]; "]: "; 
    $succ = { `count(Cluster[1]/*)`; }
    $srt_s; "("; ploci(#nr=$l); ",";
    if [$succ = 0] { "$true"; } else {
    if [$succ = 1] { apply[Cluster[1]]; } 
    else { "( "; apply[Cluster[1]]; " )"; } }
    ")"; ",file("; lc(#s=`@aid`); ",";
    absk(#el=`.`,#kind="rc"); "),[mptp_info("; `@nr`; 
    ",[],rcluster,position(0,0),[";
    if [$mml="0"] 
    { 
       "proof_level(["; `translate(../@newlevel,"_",",")`; "]),"; 
       // forge the correctness of structural "strict" registrations
       if [name(../..) = "Definition"] 
       {
	 if [not(../../Constructor[@kind = "G"])] { $fail; }
	 else
	 {
	    "inference(mizar_by,[strict],[dt_"; 
	    absc1(#el=`../../Constructor[@kind = "G"]`);
	    "])";
	 }
       }
       else 
       { 
         cluster_correctness_conditions(#el=`../*[position() = last()]`);
       }
    }
    "])]).\n"; 
  }
}}

// the newer version of Identify
// sufficient proof refs done as for clusters
// ##GRM: Identify_Name : "ie" Number "_" Aid .
tpl [Identify] 
{ 
  if [ErrorIdentify] { } 
  else 
  {
    "fof("; absk(#el=`.`,#kind="ie"); ",theorem,";
    if [Typ] 
    {  
       "!["; for-each [Typ] { 
          ploci(#nr=`position()`); " : "; apply[.]; 
          if [not(position()=last())] { ","; } }
       "]: "; 
    } 
    "(";
    if [EqArgs/Pair]
    {
       "(";
       for-each [EqArgs/Pair] 
       { 
	  "( "; ploci(#nr=`@x`); $eq_s; ploci(#nr=`@y`); " )"; 
          if [not(position()=last())] { $and_s; } 
       }
       ")"; $imp_s;
    }
    "(";
    apply[Func[1]];
    $eq_s;
    // the next/last one should be Func too, but just for safety:
    apply[Func[2]];
    "))";
    ",file("; lc(#s=`@aid`); ",";
    absk(#el=`.`,#kind="ie"); "),[mptp_info("; `@nr`; 
    ",[],identifyexp,position(0,0),[";
    if [$mml="0"] 
    { 
       "proof_level(["; `translate(../@newlevel,"_",",")`; "]),"; 
       cluster_correctness_conditions(#el=`../*[position() > 1]`);
    }
    "])]).\n"; 
  }
}

// sufficient proof refs done as for clusters
// ##GRM: IdentifyExp_Name : "ie" Number "_" Aid .
tpl [IdentifyWithExp] 
{ 
  if [ErrorIdentify] { } 
  else 
  {
    "fof("; absk(#el=`.`,#kind="ie"); ",theorem,";
    if [Typ] 
    {  
       "!["; for-each [Typ] { 
          ploci(#nr=`position()`); " : "; apply[.]; 
          if [not(position()=last())] { ","; } }
       "]: "; 
    } 
    "(";
    apply[Func[1]];
    $eq_s;
    // the next/last one should be Func too, but just for safety:
    apply[*[position() = last()]];
    ")";
    ",file("; lc(#s=`@aid`); ",";
    absk(#el=`.`,#kind="ie"); "),[mptp_info("; `@nr`; 
    ",[],identifyexp,position(0,0),[";
    if [$mml="0"] 
    { 
       "proof_level(["; `translate(../@newlevel,"_",",")`; "]),"; 
       cluster_correctness_conditions(#el=`../*[position() > 1]`);
    }
    "])]).\n"; 
  }
}


tpl [ArgTypes] { if [Typ] {
       "!["; for-each [Typ] { 
          ploci(#nr=`position()`); " : "; apply[.]; 
          if [not(position()=last())] { ","; } }
       "]: "; } }

tpl pvar(#nr) { "B"; $nr; }
tpl pconst(#nr,#pl) { "c"; absconst(#nr=$nr,#pl=$pl); }
tpl ploci(#nr) { "A"; $nr; }
tpl plab(#nr) { <i { <font { @color=$labcolor; "E"; `@nr`; } } }

// absolute constructor names (use $fail for debugging absnrs)
tpl absc(#el) { for-each [$el] {
    if [@absnr and @aid] { lc(#s=`concat(@kind,@absnr,'_',@aid)`); }
    else { lc(#s=`@kind`); `@nr`;  $fail; } } }

// absolute redefinition names (use $fail for debugging absnrs)
tpl absredef(#el) { for-each [$el] {
    if [@redefaid and @absredefnr] {
       lc(#s=`concat(@kind,@absredefnr,'_',@redefaid)`); }
    else { lc(#s=`@kind`); `@redefnr`;  $fail; } } }

tpl absc1(#el) { for-each [$el] {
    if [@aid and @nr] { lc(#s=`concat(@kind,@nr,'_',@aid)`); }
    else { lc(#s=`@kind`); `@nr`;  $fail; } } }

// absolute reference names (use $fail for debugging absnrs)
// also used for From to get the scheme name
tpl absr(#el) { for-each [$el] {
    if [@nr and @aid and @kind] { lc(#s=`concat(@kind,@nr,'_',@aid)`); }
    else { lc(#s=`@kind`); `@nr`;  $fail; } } }

// absolute cluster and scheme names
tpl absk(#el,#kind) { for-each [$el] {
    if [@nr and @aid] { lc(#s=`concat($kind,@nr,'_',@aid)`); }
    else { lc(#s=$kind); `@nr`;  $fail;} } }



// List utilities

tpl list(#separ,#elems) { 
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { $separ; } }
}

// List utility with additional arg
tpl ilist(#separ,#elems,#i,#pl) { 
 for-each [$elems] {
  apply[.](#i=$i,#pl=$pl); if [not(position()=last())] { $separ; } }
}

// argument list
tpl arglist(#separ,#elems,#s) { 
 for-each [$elems] {
  if [$s > 0] { ploci(#nr=`position() + $s`);} else {ploci(#nr=`position()`);} 
  if [not(position()=last())] { $separ; } }
}

// add numbers starting at #j+1 between #sep1 and #sep2 - now with constants
tpl jlist(#j,#sep1,#sep2,#elems) { 
for-each [$elems] {
  apply[.]; if [not(position()=last())] 
  {  $sep1; pconst(#nr=`$j+position()`); $sep2; } }}

// from-to list of variables starting numbering at $f ending at $t
// $l ouiputs loci vars
tpl ft_list(#f,#t,#sep,#l) {
  if [$f = $t] {  if [$l=1] { ploci(#nr=$f); } else { pvar(#nr=$f); } }
  else { if [$f < $t] { 
       if [$l=1] { ploci(#nr=$f); } else { pvar(#nr=$f); } $sep; 
            ft_list(#f=`$f+1`,#t=$t,#sep=$sep,#l=$l); } }}

// $same is used for reflexivity
tpl switchedargs(#nr,#nr1,#nr2,#lim,#same) {
    if [$nr = $nr2] { ploci(#nr=$nr1); } else {
    if [$nr = $nr1] { 
     if [$same=1] { ploci(#nr=$nr1); } else {  ploci(#nr=$nr2); } } 
    else { ploci(#nr=$nr); }}
    if [$nr < $lim] { ","; 
     switchedargs(#nr=`$nr+1`,#nr1=$nr1,#nr2=$nr2,#lim=$lim,#same=$same); } }

// $same is used for reflexivity
tpl argsinsert(#nr,#nr1,#arg,#lim) {
    if [$nr = $nr1] { $arg; } else { ploci(#nr=$nr); }
    if [$nr < $lim] { ","; 
     argsinsert(#nr=`$nr+1`,#nr1=$nr1,#arg=$arg,#lim=$lim); } } 

// find the constant with #nr on level #pl or higher,
// rpint @constnr "_" $pl
tpl absconst(#nr,#pl) {
    if [key("C",$pl)[@nr=$nr]] 
    { 
       `key("C",$pl)[@nr=$nr]/@constnr`; 
       addp(#pl=$pl); 
    }
    else { if [key("C",$pl)[@nr < $nr]] 
    { 
       for-each [key("C",$pl)[@nr < $nr]] 
       { 
          if [position() = last()] 
	  {
	      $n1 = getcnr(#el=`.`); 
	      $lastnr = `@nr + $n1 - 1`;
	      if [$lastnr >= $nr] { `@constnr + ($nr - @nr)`; addp(#pl=$pl); }
	      else { $fail;}
          }
       }
    }
    else { if [string-length($pl)>0] 
    { 
       $ss = `exsl-str:tokenize($pl,'_')[position() < last()]`; 
       $pl1= mjoin(#el=$ss,#s="_");
//	 "bb"; $pl1; "bb";
       absconst(#nr=$nr,#pl=$pl1); 
    } 
    else { $fail;}}
 }}

tpl mjoin(#el,#s) {
 for-each [$el] { `string(.)`; if [not(position()=last())] { $s; } }}

// count local constants introduced in the current element -
// this asssumes Let | Given | TakeAsVar | Consider | Set | Reconsider
tpl getcnr(#el) { for-each [$el] {
    if [(name() = "Reconsider")] { `count(Var|LocusVar|Const|InfConst|
		  Num|Func|PrivFunc|Fraenkel|QuaTrm|It|Choice|ErrorTrm)`; }
    else { `count(Typ)`; } }}


tpl refname(#el,#pl) { for-each [$el] {
    if [(@kind = "T") or (@kind = "D")] { absr(#el=$el); }
    else { privname(#nr=`@nr`,#pl=$pl); } }}

tpl polyeval_name(#el,#pl) 
{ 
    for-each [$el] 
    {
       `Requirement/@reqname`; "__";
       absc(#el=`Requirement`); "__";
       if [Requirement/@value = "false"] { "false__"; }
       for-each[*[position() > 1]]
       {
          if[(name() = "RationalNr") or (name() = "ComplexNr")] {  apply[.]; }
	  else { `name()`; $fail; }
	  if [not(position()=last())] { "_"; }
       }
    }
}

// this produces m 2.964693601e+09 for pepin at 2058,54; so we use
// string replacement instead
tpl encode_minus_bad (#n) { if[$n < 0] { "m";  `0 - $n`; } else { $n; } }

tpl encode_minus(#n) { if[$n < 0] { `translate($n,"-","m")`; } else { $n; } }

tpl [RationalNr] 
{
   "r";
   if[@denominator = "1"] {  encode_minus(#n=`@numerator`); }
   else { "n"; encode_minus(#n=`@numerator`); "d"; encode_minus(#n=`@denominator`); }
}

tpl [ComplexNr] {"c"; apply;}


tpl top_propname(#el) 
{ 
  for-each [$el/..] 
  {
    if [(name() = "DefTheorem") or (name() = "JustifiedTheorem")] 
       { absr(#el=`.`); }
    else 
    { 
       $k1 = `concat($el/@nr,":")`;
       lemmaname(#n=`key("E",$k1)/@propnr`); 
    } 
  }
}

// name of private reference - name of the proposition
// this differs from `plname` in that the #pl is not the
// proof level to print, but the proof level used to start the
// search for the reference 
tpl privname(#nr,#pl) 
{
   $k1 = `concat($nr,":",$pl)`;
   if [key("E",$k1)] 
   { 
	 if [not(string-length($pl)>0)] { top_propname(#el=`key("E",$k1)`); }
	 else { propname(#n=`key("E",$k1)/@propnr`,#pl=$pl); } 
   }
   else { if [string-length($pl)>0] 
   { 
	 $ss = `exsl-str:tokenize($pl,'_')[position() < last()]`; 
	 $pl1= mjoin(#el=$ss,#s="_");
	 privname(#nr=$nr,#pl=$pl1); 
   } 
   else { $fail;}
   }
}

// name of scheme functor (#k='f') or predicate (#k='p')
tpl sch_fpname(#k,#nr,#schnr,#aid) 
{
    if [$k and $nr and $aid and $schnr] 
    {
       lc(#s=`concat($k,$nr,'_s',$schnr,'_',$aid)`); 
    }
    else 
    { 
       lc(#s=$k); `@nr`;  $fail; 
    }
}

// name of scheme functor (#k='f') or predicate (#k='p')
tpl abs_fp(#k,#el) { for-each [$el] { 
    sch_fpname(#k=$k,#nr=`@nr`,#schnr=`@schemenr`,#aid=`@aid`); }}

// definition of private functor (#k='pf') or predicate (#k='pp'); 
// either a term with LocusVars or a formula with LocusVars
// the list of arguments is printed first, to know their order
tpl priv_def(#k,#nr,#pl) 
{
      $k1 = `concat($nr,":",$pl)`;
      if [key($k,$k1)] { 
	 for-each [key($k,$k1)] { 
		  "["; arglist(#separ=",",#elems=`ArgTypes/Typ`); "] : ";
		  apply[*[position() = 2]](#pl=`@plevel`); }}
      else { if [string-length($pl)>0] { 
	 $ss = `exsl-str:tokenize($pl,'_')[position() < last()]`; 
	 $pl1= mjoin(#el=$ss,#s="_");
	 priv_def(#k=$k,#nr=$nr,#pl=$pl1); } else { $fail;}}
}


// hack for .bex1 file, it's the same as Typ, but uses upper cluster
// instead of lower cluster; maybe the lower cluster should be fixed
// to a more proper value in iocorrel.pas
tpl [ByExplanations](#i,#pl) { for-each [Typ] { if[position() = 2] { "non"; } "zerotyp("; $anamelc; ","; 

      if [@kind='errortyp'] { "errortyp"; }
      else { if [(@kind="M") or (@kind="L")] {
        $radix = { if [(@aid = "HIDDEN") and (@kind="M") and (@nr="1")]
                         { "0"; } else { "1"; } }
        $adjectives = { `count(*[2]/*)`; }
        if [($adjectives + $radix) = 0] { "$true"; }
        else {
          if [($adjectives + $radix) > 1] { "( "; }
          if [$adjectives > 0] {
             apply[*[2]](#i=$i,#pl=$pl); 
             if [$radix > 0] { $and_s; } }
          if [($radix > 0)] { 
             absc(#el=`.`);
             if [count(*) > $cluster_nr ] { 
               "(";
               ilist(#separ=",", #elems=`*[position() > $cluster_nr]`, 
	             #i=$i, #pl=$pl); 
               ")"; } }
          if [($adjectives + $radix) > 1] { " )"; }
         }
      }
      else { $fail; } }

 ").\n"; }}


tpl [/] { if [$mml="0"] { apply[//Constructor|//Proposition[not(name(..)="Reconsider")]|//Now|//IterEquality|
	     //Let|//Given|//TakeAsVar|//Consider|//Set|
	     //Reconsider|//SchemeFuncDecl|//SchemeBlock|
	     //CCluster|//FCluster|//RCluster|//IdentifyWithExp|//Identify|//Thesis|//PerCasesReasoning|/ByExplanations]; 
           dumproptable(); }
	  else { apply; } }







 

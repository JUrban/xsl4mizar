stylesheet 1.0;

output method=html;

include mhtml_utils.xsl;


// $Revision: 1.6 $
//
// File: print_complex.xsltxt - html-ization of Mizar XML, more complex printing stuff
//
// Author: Josef Urban
//
// License: GPL (GNU GENERAL PUBLIC LICENSE)


// ##TODO: try some unification of mkref and absref
//
// theorem, definition and scheme references
// add the reference's href, $c tells if it is from current article
// $nm passes the explicit text to be displayed
tpl mkref(#aid, #nr, #k, #c, #nm) 
{
  $mk  =  { refkind(#kind = $k); }
  $alc =  { lc(#s = $aid); }
  <a {
      @class = "ref";

      if [($linking = 'q') or (($linking = 'm') and not($c))] 
      {
        @href = `concat($mmlq,$aid,":",$mk,".",$nr)`;
      }
      else 
      {
        @href = `concat($alc, ".", $ext, "#",$k, $nr)`;

        if [$c = "1"] 
	{
          @target = "_self";
        }
      }

      if [$titles="1"] 
      {
        @title = `concat($aid,":",$mk,".",$nr)`;
      }

      if [$nm] 
      { 
        $nm; 
      }
      else 
      {
        $aid; ":";

        if [not($k="T")] 
	{
          $mk; " ";
        }

        $nr;
      }

    }
}




// add the constructor/pattern href, $c tells if it is from current article
// #sym is optional Mizar symbol
// #pid links to  patterns instead of constructors
tpl absref(#elems, #c, #sym, #pid)
{ 
   $n = { if [$pid > 0] { "N"; } else { ""; } }

   for-each [$elems] 
   { 
      $mk  = mkind(#kind = `@kind`); 
      $alc = lc(#s=`@aid`);

      <a 
      { 
         if [($linking = 'q') or (($linking = 'm') and not($c = "1"))] 
	 { 
	    @href = `concat($mmlq,@aid,":",$mk,".",@nr)`;
	 }
	 else 
	 { 
            @href=`concat($alc, ".", $ext, "#", $n, @kind, @nr)`; 
	    // this is probably needed if $mml = 1
	    if [$c = "1"] { @target="_self"; } 
         }

	 if [$titles="1"] 
	 { 
	    $t1 = { if [$pid > 0] { `@kind`; } else { $mk; } }
	    @title=`concat(@aid, ":", $n, $t1, ".", @nr)`; 
         }

	 if [$sym] 
	 { 
	    $sym; 
	 }
	 else 
	 { 
	    if [$relnames > 0]
	    { 
	       $n; `@kind`; `@relnr`; 
	    }
	    else 
	    { 
	       $n; `@kind`; `@nr`; "_"; `@aid`;  
	    } 
	 }
      }
   } 
}

// look up and link the constructor/pattern with kind #k and #nr;
// #sym is optionally forces the given Mizar symbol
// #pid links to  patterns instead of constructors
tpl abs(#k, #nr, #sym, #pid) 
{
   if [$pid>0] 
   {
      $k1  = `concat('P_',$k)`;
      $doc = { if [key($k1,$nr)[$pid=@relnr]] { ""; } else { $patts; } }
      $c1  = { if [($doc = "") and ($mml = "0")] { "1"; } else { "0"; } }

      for-each [document($doc,/)] 
      {
         absref(#elems = `key($k1,$nr)[$pid=@relnr]`, #c = $c1, #sym = $sym, #pid = $pid);
      }
   } 
   else 
   {
      $doc = { if [key($k,$nr)] { ""; } else { $constrs; } }
      $c1  = { if [($doc = "") and ($mml = "0")] { "1"; } else { "0"; } }

      for-each [document($doc,/)] 
      {
         absref(#elems = `key($k,$nr)`, #c = $c1, #sym = $sym);
      }
   }
}

// pretty printer - gets arguments, visibility info from pattern,
// format telling arities, the linked symbol and optionally right bracket
// parenth hints to put the whole expression in parentheses, but this
// is overrriden if the expression uses functor brackets
// #loci tells to print loci instead of arguments
// #i is the bound var nbr
tpl pp(#k, #nr, #args, #parenth, #pid, #loci, #i) 
{
  $pkey = `concat('P_',$k)`;

  //  pattern number given 
  if [$pid>0] 
  {
     $doc     = { if [key($pkey,$nr)[$pid=@relnr]] { ""; } else { $patts; } }

     for-each [document($doc,/)] 
     {
         if [key($pkey,$nr)[$pid=@relnr]] 
	 {
	    for-each [key($pkey,$nr)[$pid=@relnr]] 
	    {
	       $npid =  { if [@redefnr>0] { $pid; } }

	       pp1(#k = $k, #nr = $nr, #args = $args, #vis = `Visible/Int`, 
	           #fnr = `@formatnr`, #parenth = $parenth, #loci = $loci, #pid = $npid, #i = $i);
            }
	 }
	 //  failure, print in absolute notation 
	 else 
	 {
	    abs(#k = $k, #nr = $nr);
	    "(";
	    list(#separ = ",", #elems = $args);
	    ")";
	 }
     }
  }
  //  pattern number not given - take first suitable 
  else 
  {
     $doc     = { if [key($pkey,$nr)] { ""; } else { $patts; } }

     for-each [document($doc,/)] 
     {
         if [key($pkey,$nr)] 
	 {
	    for-each [key($pkey,$nr)[position()=1]] 
	    {
               $npid =  { if [@redefnr>0] { `@relnr`; } }
	       pp1(#k = $k, #nr = $nr, #args = $args, #vis = `Visible/Int`, 
		   #fnr = `@formatnr`, #parenth = $parenth, #loci = $loci, #pid = $npid, #i = $i);
            }
         }
	 //  failure, print in absolute notation 
	 else 
	 {
	    abs(#k = $k, #nr = $nr);
	    "(";
	    list(#separ = ",", #elems = $args);
	    ")";
         }
      }
   }
}




// it is legal to pass onlt #loci instead of #args here
// #pid is passed to abs, causes linking to patterns
// #i is the bound var nbr
tpl pp1(#k,#nr,#args,#vis,#fnr,#parenth,#loci,#pid,#i) {
    $la = { if [($k='M') or ($k='G') or ($k='L')] {  "0"; } 
            else { for-each [document($formats,/)] {
                     for-each [key('F',$fnr)] { 
                       if [@leftargnr] { `@leftargnr`;} else { "0";} }}} }
    // try if right bracket
    $rsym = { if [($k='K') and ($la='0')] {
                 abs1(#k=$k, #nr=$nr, #r="1"); } }
    $np = { if [not($vis) or ($k='G')] { "0"; } else {
               if [$parenth>0] { $parenth; } else { 
                  if [not($rsym='')] { "1"; } else { "0";} } } }
    $paren_color = `$np mod $pcolors_nr`;

    // print spanned paranthesis or left bracket
    if [($np>0)] { <span { @class=`concat("p",$paren_color)`;
      if [$rsym=''] { "("; } else { 
         abs(#k=$k, #nr=$nr, #sym=abs1(#k=$k, #nr=$nr, #fnr=$fnr), #pid=$pid); } 
      <span { @class="default";

    // this is duplicated later - needed for Mozilla - bad escaping
      for-each [$vis] { 
       if [position() <= $la] {
	$x=`@x`;
	if [$loci>0] { if [$loci="2"] { pconst(#nr=$x); } else { ploci(#nr=$x); }}
	else { apply[$args[position() = $x]](#p=$np,#i=$i); }
	if [position() < $la] { ",";} } }
      if [$rsym=''] {
       if [not($parenth>0) or ($la>0)] { " "; } 
       abs(#k=$k, #nr=$nr, #sym=abs1(#k=$k, #nr=$nr, #fnr=$fnr), #pid=$pid); " "; }
      for-each [$vis] { 
       if [(position() = 1) and (($k='M') or ($k='L'))] { "of "; }
       if [position() > $la] {
	$x=`@x`;
	if [$loci>0] { if [$loci="2"] { pconst(#nr=$x); } else { ploci(#nr=$x); }}
        else { apply[$args[position()  = $x]](#p=$np,#i=$i); }
        if [position() < last()] { ",";} } }
       }
      if [$rsym=''] { ")"; } else { abs(#k=$k, #nr=$nr, #sym=$rsym, #pid=$pid); } }
    } else {

      for-each [$vis] { 
       if [position() <= $la] {
	$x=`@x`;
	if [$loci>0] { if [$loci="2"] { pconst(#nr=$x); } else { ploci(#nr=$x); }}
	else { apply[$args[position() = $x]](#p=$np,#i=$i); }
	if [position() < $la] { ",";} } }
      if [$rsym=''] {
       if [not($parenth>0) or ($la>0)] { " "; } 
       abs(#k=$k, #nr=$nr, #sym=abs1(#k=$k, #nr=$nr, #fnr=$fnr), #pid=$pid); 
       if [$k='G'] { "(#"; } " "; }
      for-each [$vis] { 
       if [(position() = 1) and (($k='M') or ($k='L'))] { "of "; }
       if [position() > $la] {
	$x=`@x`;
	if [$loci>0] { if [$loci="2"] { pconst(#nr=$x); } else { ploci(#nr=$x); }}
        else { apply[$args[position()  = $x]](#p=$np,#i=$i); }
        if [position() < last()] { ",";} } }
      if [$k='G'] { " #)"; } 
     }
 }


// theorem, definition and scheme references
tpl getref(#k, #anr, #nr) 
{
  if [$anr>0] 
  {
    $refdoc = { if [$k="S"] { $schms; } else { $thms; } }

    for-each [document($refdoc,/)] 
    {
      for-each [key($k,concat($anr,':',$nr))[position()=1]] 
      {
         mkref(#aid = `@aid`, #nr = $nr, #k = $k);
      }
    }
  }
  else 
  {
     mkref(#aid = $aname, #nr = $nr, #k = $k, #c = "1");
  }
}

// find the constant with #nr on level #pl or higher,
// and pretty print it
// now assumes that proof levels are available, which is only through
// addabsrefs preprocessing
tpl absconst(#nr,#pl) 
{
   if [key("C",$pl)[@nr = $nr]] 
   { 
      for-each [key("C",$pl)[@nr = $nr]] 
      {
         ppconst(#nr = $nr, #vid = `Typ[position() = 1]/@vid`); 
      }
   }
   else 
   { 
      if [key("C",$pl)[@nr < $nr]] 
      { 
         for-each [key("C",$pl)[@nr < $nr]] 
         { 
            if [position() = last()] 
	    {
      	       $n1     = getcnr(#el = `.`); 
	       $lastnr = `@nr + $n1 - 1`; 
	       $n2     = `@nr`;

	       if [$lastnr >= $nr] 
	       { 
      	          ppconst(#nr = $nr, #vid = `Typ[position() = ($nr - $n2 + 1)]/@vid`); 
      	       }
	       else 
	       { 
      	          $dbgmsg;
	       }
      	    }
         }
      }
      else 
      {
         $ls = `string-length($pl)`;

         if [$ls>0] 
         { 
            $pl1 = { get_parent_level(#pl = $pl, #ls = $ls, #n = "1"); }
	    absconst(#nr = $nr, #pl = $pl1); 
         } 
         else 
         { 
	    $dbgmsg; 
         }
      }
   }
}

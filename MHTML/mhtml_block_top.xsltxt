stylesheet 1.0;

output method=html;

include mhtml_reasoning.xsl;

// $Revision: 1.19 $
//
// File: block_top.xsltxt - html-ization of Mizar XML, code for bloc and top elements
//
// Author: Josef Urban
//
// License: GPL (GNU GENERAL PUBLIC LICENSE)

// Registrations
tpl [RCluster] { 
    $nr1 = `1 + count(preceding::RCluster)`;
    if [$generate_items>0]	{ 
// <xsl:document href="proofhtml/exreg/{$anamelc}.{$nr1}" format="html">
       rc();
// </xsl:document>
   $bogus=`1`;
 } 
    else { rc(); } }

tpl rc 
{
  if [($mml="1") or ($generate_items>0)] { apply[ArgTypes]; }
  $nr1 = `1 + count(preceding::RCluster)`;
  <a 
  { 
    @NAME=`concat("RC",$nr1)`;
    <b { "cluster "; } 
  }
  if [ErrorCluster] { "errorcluster"; } else { apply[*[3]]; " "; apply[*[2]]; }
  ";"; <br; if [$mml="1"] { <br; }
}

tpl [CCluster] { 
    $nr1 = `1 + count(preceding::CCluster)`;
    if [$generate_items>0]	{ 
// <xsl:document href="proofhtml/condreg/{$anamelc}.{$nr1}" format="html">
       cc();
// </xsl:document>
   $bogus=`1`;
 } 
    else { cc(); } }


tpl cc         { if [($mml="1") or ($generate_items>0)] { apply[ArgTypes]; }
		 $nr1 = `1 + count(preceding::CCluster)`;
		 <a { @NAME=`concat("CC",$nr1)`;
		      <b { "cluster "; } }
                 if [ErrorCluster] { "errorcluster"; }
	         else { apply[*[2]]; <b {" -> ";} apply[*[4]]; " "; 
                        apply[*[3]]; }
                 ";"; <br; if [$mml="1"] { <br; }}

tpl [FCluster] { 
    $nr1 = `1 + count(preceding::FCluster)`;
    if [$generate_items>0]	{ 
// <xsl:document href="proofhtml/funcreg/{$anamelc}.{$nr1}" format="html">
       fc();
// </xsl:document>
   $bogus=`1`;
 } 
    else { fc(); } }

tpl fc
{ 
   if [($mml="1") or ($generate_items>0)] { apply[ArgTypes]; }
   $nr1 = `1 + count(preceding::FCluster)`;
   <a { @NAME=`concat("FC",$nr1)`;
   <b { "cluster "; } }
   if [ErrorCluster] { "errorcluster"; }
   else { apply[*[2]]; <b {" -> ";} apply[*[3]]; apply[Typ];}
   ";"; <br; if [$mml="1"] { <br; }
}


tpl [IdentifyWithExp|Identify] 
{ 
    $iname = `name()`; // to deal with both versions
    $nr1 = `1 + count(preceding::*[name() = $iname])`;
    if [$generate_items>0]	
    { 
// <xsl:document href="proofhtml/idreg/{$anamelc}.{$nr1}" format="html">
       iy();
// </xsl:document>
   $bogus=`1`;
    } 
    else { iy(); } 
}

tpl iy
{ 
   $iname = `name()`; // to deal with both versions
   if [($mml="1") or ($generate_items>0)] 
   { 
      argtypes(#el=`Typ`);
   }

   $nr1 = `1 + count(preceding::*[name() = $iname])`;

   <a 
   { 
      @NAME=`concat("IY",$nr1)`;
      <b { "identify "; } 
   }

   if [ErrorIdentify] { "erroridentify"; }
   else { if [($mml="1") or ($generate_items>0)] 
   { 
       if [$iname = 'Identify']
       {
           apply[Func[1]];
	   <b {" with ";} 
	   apply[Func[2]];
       }
       else
       {
	   apply[*[position() = last() - 1]]; 
       	   <b {" with ";} 
       	   apply[*[position() = last()]]; 
       }
   }
   else // try nice display from the compatibility formula
   {
     for-each [following-sibling::*[1]/Proposition/*[1]]
     {
       if [name() = "Pred"] // equality - terms
       { 
         apply[*[1]]; 
	 <b {" with ";} 
	 apply[*[2]];
       }
       else { if [name() = "And"] // equivalence - predicates
       {
         $e1= is_equiv(#el=`.`);
	 if [$e1="1"] 
	 { 
	   apply[*[1]/*[1]/*[1]]; 
	   <b {" with ";}
	   apply[*[1]/*[1]/*[2]/*[1]];
	 }
	 else 
	 {
	   "IDENTIFY DISPLAY FAILED -  PLEASE COMPLAIN!"; <br;
	   apply[.];		 
	 }
       }
       else 
       {
         $i3= is_impl1(#el=`.`);
	 if [not($i3=2)] { "IDENTIFY DISPLAY FAILED -  PLEASE COMPLAIN!";  }
	 else
	 {
           for-each [*[1]/*[@pid=$pid_Impl_RightNot]/*[1]]
	   {
	     if [name() = "Pred"] 
	     {
	       apply[*[1]]; 
	       <b {" with ";} 
	       apply[*[2]];
	     }
	     else 
	     {
	       $e1= is_equiv(#el=`.`);
	       if [$e1="1"] 
	       { 
	         apply[*[1]/*[1]/*[1]]; 
		 <b {" with ";}
		 apply[*[1]/*[1]/*[2]/*[1]];
               }
	       else 
	       {
	         "IDENTIFY DISPLAY FAILED -  PLEASE COMPLAIN!"; <br;
		 apply[.];		 
	       }
	     }
	   }
	   <b {" when ";}
	   ilist(#separ = ", ", #elems=`*[1]/*[not(@pid=$pid_Impl_RightNot)]`); 
	 }
       }}
     }
   }}

   ";"; <br; if [$mml="1"] { <br; }
}


// ignore them
tpl [Reservation/Typ] { ""; }
tpl [Definiens/*] { ""; }


// xsltxt cannot use xsl:document yet, so manually insert it 
// (now done by the perl postproc)
// the bogus is there to ensure that the ending xsl:doc element
// is printed by xslxtxt.jar too
tpl [JustifiedTheorem] 
{ 
    $nr1 = `1+count(preceding-sibling::JustifiedTheorem)`;
    if [$generate_items>0]	
    { 
// <xsl:document href="proofhtml/th/{$anamelc}.{$nr1}" format="html">
       jt();
// </xsl:document>
       $bogus=`1`;
    } 
    else 
    { 
      // optional interestingness rating produced by external soft
      if [@interesting > 0]
      {
         // scale red and blue from 0% (green) to 100% (white)
         $intensity = `(1 - @interesting) * 100`;
         <div 
	 { 
	    @style=`concat("background-color:rgb(",$intensity,"%,100%,", $intensity, "%);")`;
	    jt();
         }
      }
      else { jt(); } 
    }
}

// private - assumes that is inside JustifiedTheorem
tpl jt 
{
    $nr1 = `1+count(preceding-sibling::JustifiedTheorem)`;

    <b { "theorem "; } 

    if [($proof_links > 0) and ($print_lab_identifiers = 0)]
    { 
       plab1(#nr=$nr1,#txt="Th"); ": "; 
    }
    else 
    { 
       for-each [Proposition[@nr > 0]] { pplab(#nr=`@nr`, #vid=`@vid`); ": "; }
    }

    <a 
    { 
       @NAME = `concat("T", $nr1)`; 
       pcomment0(#str = `concat($aname,":", $nr1)`); 
       if [@interesting > 0] 
       { 
          " interestingness: "; `@interesting`;
       }
       if [$idv > 0] 
       { 
          idv_for_item(#k="t", #nr=$nr1);
       }
       if [$thms_tptp_links = 1]
       {
          tptp_for_thm(#line=`Proposition[1]/@line`, #col=`Proposition[1]/@col`);
       }

       <br;
    }

    if [Proof] 
    { 
       <div { @class="add"; apply[*[1]/*[1]]; } 
       if [not($generate_items>0) or ($generate_items_proofs>0)]
       {
         apply[*[2]]; 
       }
    }
    else 
    { 
       <div 
       { 
          @class="add"; 

          if [Proposition/Verum] 
	  { 
	     <b { "canceled; "; }
	  }
	  else 
	  { 
	     apply[*[1]/*[1]]; " "; 
	     apply[*[2]]; 
	  } 
       } 
    } 
}

tpl idv_for_item(#k,#nr)
{
  $idv_html = "http://www.cs.miami.edu/~tptp/MizarTPTP/";
// "http://lipa.ms.mff.cuni.cz/~urban/idvtest/";

//  $idv_html = "file:///home/urban/mptp0.2/idvhtml/";
  $tptp_file = `concat($idv_html,"problems/",$anamelc,"/",$anamelc, "__",$k, $nr, "_", $anamelc)`;
  " ";
  <img 
  {
    add_hs2_attrs();
    @src="PalmTree.jpg";
    @title="Show IDV graph";
    @alt="Show IDV graph";
  }

//   <a 
//   { 
// //    add_ajax_attrs(#u = $th);
//     add_hs2_attrs();
//     @title="Show IDV graph";
//     <b { " IDV graph "; } 
//   }

  <span 
  { 
      @style = "display:none"; 
      ":: Showing IDV graph ... (Click the Palm Tree again to close it)"; 
      <APPLET 
      { 
         @CODE = "IDVApplet.class";
	 @ARCHIVE = "http://www.cs.miami.edu/students/strac/test/IDV/IDV.jar,http://www.cs.miami.edu/students/strac/test/IDV/TptpParser.jar,http://www.cs.miami.edu/students/strac/test/IDV/antlr-2.7.5.jar";
	 @WIDTH = "0";
	 @HEIGHT = "0";
	 <PARAM { @NAME="URL"; @VALUE=$tptp_file; }
      }
  }
}


tpl tptp_for_thm(#line, #col)
{
  $tptp_file = `concat("problems/",$anamelc,"/",$anamelc,"__",$line,"_",$col)`;
  " ::";
  <a
  {
    @href= `concat($ltmpftptpcgi,"?file=",$tptp_file,"&tmp=",$lbytmpdir)`; 
    @target= `concat("MizarTPTP",$lbytmpdir)`;
    <img
    {
       @src= `concat($ltptproot,"TPTP.gif")`;
       @height= "17";
       @width= "17";
       @alt= "Show TPTP problem";
       @title= "Show TPTP problem";
    }
  }
} 

tpl [DefTheorem] 
{ 
    $nr1 = `1+count(preceding-sibling::DefTheorem)`;
    if [$generate_items>0]	
    { 
// <xsl:document href="proofhtml/def/{$anamelc}.{$nr1}" format="html">
       dt();
// </xsl:document>
       $bogus=`1`;
    } 
    else { dt(); } 
}

// private - assumes that is inside DefTheorem
tpl dt 
{
  $nr1 = `1+count(preceding-sibling::DefTheorem)`;

  ":: "; <b { "deftheorem "; }

  if [($proof_links > 0) and ($print_lab_identifiers = 0)]
  { 
     plab1(#nr = $nr1, #txt = "Def"); 
  } 
  else 
  { 
     for-each [Proposition[@nr > 0]] { pplab(#nr = `@nr`, #vid = `@vid`); }
  } 

  " ";
  //    <a { @NAME=`concat("D",$nr1)`; 
  if [@constrkind] 
  { 
     "  defines "; 
     abs(#k = `@constrkind`, #nr = `@constrnr`, 
         #sym = abs1(#k = `@constrkind`, #nr = `@constrnr`)); 
  } 

  " ";
  <a 
  { 
     @onclick = "hs(this)"; 
     @href    = "javascript:()";
     `concat($aname, ":def ", $nr1)`; 
     " : "; <br; 
  }

  <span 
  { 
     @class = "hide"; 

     <div 
     {   
        @class = "add"; 

	if [Proposition/Verum] 
	{ 
	   <b { "canceled; "; } 
        }
	else 
	{ 
	   apply[*[1]/*[1]];  ";"; 
	}  
     } 
  }
}

//   Property, elProposition, Justification
tpl [JustifiedProperty] 
{
   $nm = { lc(#s = `name(*[1])`); }

   <a 
   { 
      add_hs_attrs(); 
      <b { if [$nm = "antisymmetry"] { "asymmetry"; } else { $nm; } " "; }
   }

   <span { @class="hide"; <br; apply[*[2]]; }
   apply[*[position()>2]]; 
}

//  Formula | ( elProposition, Justification )
tpl [UnknownCorrCond|Coherence|Compatibility|Consistency|Existence|Uniqueness] 
{ 
   <a 
   { 
      add_hs_attrs();
      <b { lc(#s = `name()`); " "; }
   }

   <span { @class="hide"; <br; apply[*[1]]; }
   if [count(*)>1] { apply[*[position()>1]];  } else { ";"; <br; }
}

// CorrectnessCondition*, elProposition, Justification
tpl [Correctness] { 
<a { add_hs_attrs(); <b { "correctness "; } }
// apply to subconditions , skip their conjunction
<span { @class="hide"; <br; apply[*[position()<(last()-1)]]; }
apply[*[position()=last()]]; }

tpl [Canceled] { <b { "canceled;"; } <br; }

tpl [SchemeFuncDecl] { 
     pschfvar(#nr=`@nr`); "(";
     list(#separ=",", #elems=`ArgTypes/Typ`); ") "; <b {"-> ";}
     apply[*[2]]; }

tpl [SchemePredDecl] { 
     pschpvar(#nr=`@nr`); "[";
     list(#separ=",", #elems=`ArgTypes/Typ`); "]"; }

//   ( elSchemeFuncDecl | elSchemePredDecl )*,
//   element elSchemePremises { elProposition* },
//   elProposition, Justification, elEndPosition
tpl [SchemeBlock] {
    if [$generate_items>0]	
    { 
// <xsl:document href="proofhtml/sch/{$anamelc}.{@schemenr}" format="html">
       sd();
// </xsl:document>
   $bogus=`1`;
   } 
   else { sd(); } }

tpl sd 
{
  <div 
  { 
    <a 
    { 
      @NAME=`concat("S",@schemenr)`; <b { "scheme  "; }
      pcomment(#str=`concat($aname,":sch ",@schemenr)`); 
    }
//     "s"; `@schemenr`; 

    if [($proof_links > 0) and ($print_lab_identifiers = 0)]
    { 
       plab1(#nr = `@schemenr`, #txt = "Sch"); 
    } 
    else 
    { 
       pplab(#nr = `@schemenr`, #vid = `@vid`, #txt = "Sch");
    }

    "{ ";
    list(#separ=", ", #elems=`SchemeFuncDecl|SchemePredDecl`); 
    " } :"; <br;
    <div { @class="add"; apply[Proposition]; } 
    if [SchemePremises/Proposition] 
    { 
       <b { "provided"; }
       <div 
       { 
          @class="add"; 
	  andlist(#elems=`SchemePremises/Proposition`); 
       } 
    }
    if [not($generate_items>0)]
    {
       apply[*[position() = last() - 1]];
    }
  }
}


//   ( ( CorrectnessCondition*, elCorrectness?,
//       elJustifiedProperty*, elConstructor?, elPattern? )
//   | ( elConstructor, elConstructor, elConstructor+,
//       elRegistration, CorrectnessCondition*, 
//       elCorrectness?, elPattern+ ))
// ##TODO: commented registration and strict attr for defstruct
tpl [Definition] 
{     
    if [@expandable = "true"] 
    { 
       $argtypes = `../Let/Typ`;
       $loci = { if [($mml="1") or ($generate_items>0)] { "1"; } else { "2"; }}
       for-each [Pattern] 
       {
          <a 
	  { 
	     @NAME=`concat("NM", @nr)`;
	     <b { "mode ";}  
	     abs1(#k = "M", #fnr = `@formatnr`);

	     if [Visible/Int] 
	     { 
	        " of "; 

		for-each [Visible/Int] 
		{ 

		   $x=`@x`;

		   if [$loci="2"] 
		   { 
		      ppconst(#nr= $x,#vid=`$argtypes[position()=$x]/@vid`); 
                   } 
		   else { ploci(#nr=$x); }

		   if [not(position()=last())] { ","; } 
                }
             }

	     <b { " is "; } 
          }
 
	  apply[Expansion/Typ]; ";"; 
	  <br; 
       }
    }
    else 
    { 
       // @nr is present iff Definiens is present; it can be 0 if
       // the definiens is not labeled, otherwise it is the proposition number
       // of its deftheorem
       if [@nr and ($generate_items>0)]	
       { 
          $cnt1 = `1 + count(preceding-sibling::Definition[@nr])`;
	  $defnr = `../following-sibling::Definiens[position() = $cnt1]/@defnr`;
// <xsl:document href="proofhtml/dfs/{$anamelc}.{$defnr}" format="html">
          dfs();
// </xsl:document>
          $bogus = `1`;
       }
       else 
       { 
          dfs(); 
       }
    }

    apply[*[not((name()='Constructor') or (name()='Pattern') 
                or (name()='Registration'))]]; 
}

tpl dfs() 
{
    $nl = { if [@nr] { "0"; } else { "1"; }}
    $argtypes = `../Let/Typ`;
// Constructor may be missing, if this is a redefinition
// that does not change its types. In that case, the Constructor needs
// to be retrieved from the Definiens - see below.

    if [not(@nr)] 
    { 
        // for generate_items, we have to take loci from the constructor here
       $indef1 = { if [($generate_items > 0)] { "0"; } else { "1"; } }

       apply[Constructor](#indef = $indef1, #nl = $nl, #argt = $argtypes);
    } 

// @nr is present iff Definiens is present; it can be 0 if
// the deiniens is not labeled, otherwise it is the proposition number
// of its deftheorem
    if [@nr] 
    {  
       $nr1   = `@nr`;
       $vid   = `@vid`;
       $cnt1  = `1 + count(preceding-sibling::Definition[@nr])`;
       $cnstr = `count(Constructor)`;

       if [($generate_items > 0)]  
       { 
	  // Definiens is better than Constructor for loci display,
	  // since Constructor may be missing for redefinitions.
          for-each [../following-sibling::Definiens[position() = $cnt1]] 
	  {
	     argtypes(#el=`Typ`);
          }
       }

       apply[Constructor](#indef = "1", #nl = $nl, #argt = $argtypes);

       for-each [../following-sibling::Definiens[position() = $cnt1]] 
       {
          $ckind = `@constrkind`; 
	  $cnr   = `@constrnr`;

	  if [$cnstr = 0] 
	  {
             // here the redefined constructor is retrieved from definiens 
	     <b { "redefine "; }

	     $doc = { if [key($ckind, $cnr)] { ""; } else { $constrs; } }

	     for-each [document($doc, /)] 
	     { 
	        apply[key($ckind, $cnr)](#indef = "1", #nl = $nl, #argt = $argtypes, #nrt= "1"); 
	     } 
          }

	  <b { if [DefMeaning/@kind = 'e'] { " equals "; } else { " means "; } }

	  if [$nr1 > 0]  
	  { 
	     ":"; 

	     if [($proof_links > 0) and ($print_lab_identifiers = 0)]
	     { 
	        plab1(#nr = `@defnr`, #txt = "Def");
	     } 
	     else 
	     { 
	        pplab(#nr = $nr1, #vid = $vid); 
	     }

	     ": ";
	  }

	  <a 
	  { 
	     @NAME = `concat("D", @defnr)`; 
	     pcomment(#str = `concat($aname, ":def ", @defnr)`); 
	  }

         // note that loci below can be translated to constants and identifiers
         // - see definition of LocusVar
	 for-each [DefMeaning/PartialDef] 
	 { 
	    apply[*[1]]; 
	    <b { " if "; } 
	    apply[*[2]]; 
	    <br; 
	 }

	 if [(DefMeaning/PartialDef) 
	    and (DefMeaning/*[(position() = last()) 
		and not(name()="PartialDef")])] 
         { 
	    <b { " otherwise "; }
	 }

	 apply[DefMeaning/*[(position() = last()) and not(name()="PartialDef")]]; 

         ";"; <br;
      }
   } 
}



//   ( elLet | elAssume | elGiven | AuxiliaryItem |
//     elCanceled | elDefinition )*, elEndPosition
tpl [DefinitionBlock] 
{
   <div 
   { 
      <b { "definition"; }
      <div { @class="add"; apply[*[not(name()='EndPosition')]]; }
      <b { "end;"; }
   }
}

//   ( elRCluster | elFCluster | elCCluster ),
//   CorrectnessCondition*, elCorrectness?
tpl [Registration] { apply; }

//   elIdentifyWithExp, CorrectnessCondition*, elCorrectness?
tpl [IdentifyRegistration] { apply; }

//   ( elLet | AuxiliaryItem | elRegistration | elCanceled )+, elEndPosition
tpl [RegistrationBlock] 
{
    <div { <b { "registration"; }
    <div { @class="add"; apply[*[not(name()='EndPosition')]]; }
    <b { "end;"; } }  
} 

tpl [NotationBlock] 
{
    <div { <b { "notation"; }
    <div { @class="add"; apply[*[not(name()='EndPosition')]]; }
    <b { "end;";  } }  
} 


// Blocks
tpl [BlockThesis] { } // "blockthesis: "; apply; ";"; <br; }

//   (  ( elBlockThesis, elCase, elThesis, Reasoning )
//   |  ( elCase, Reasoning, elBlockThesis ) )
tpl [CaseBlock] 
{ 
    <div { <a { add_hsNdiv_attrs(); if [$proof_links>0] { @title=`@newlevel`; } <b { "case "; } }
    apply[Case];
    <div { @class="add"; apply[*[not(name()='Case')]]; }
    <b { "end;"; } } 
}

tpl [SupposeBlock] 
{
    <div { <a { add_hsNdiv_attrs(); if [$proof_links>0] { @title=`@newlevel`; } <b { "suppose "; } } 
    apply[Suppose];
    <div { @class="add"; apply[*[not(name()='Suppose')]]; }
    <b { "end;"; } } 
}

//   (  ( elBlockThesis, ( elCaseBlock+ | elSupposeBlock+ ),
//        elPerCases, elThesis, elEndPosition  )
//   |  ( ( elCaseBlock+ | elSupposeBlock+ ),
//        elPerCases, elEndPosition, elBlockThesis ) )
tpl [PerCasesReasoning] 
{
    <div 
    { 
       <a 
       { 
          add_hsNdiv_attrs(); 
	  if [$proof_links>0] { @title=`@newlevel`; } 
	  <b { "per "; } 
       }

       apply[PerCases];

       <div 
       { 
          @class="add"; apply[BlockThesis];
	  apply[Thesis];
	  apply[CaseBlock | SupposeBlock]; 
       }

       <b { "end;"; } 
    } 
}

//   elBlockThesis, Reasoning 
// the Proof is done in two parts, as a preparation for printing
// top proofs into separate documents, and their loading via AJAX
// this is a non-top-level proof
tpl [Proof/Proof | Now/Proof | Conclusion/Proof | CaseBlock/Proof | SupposeBlock/Proof]
{
    <div 
    { 
       <a 
       { 
          add_hs2_attrs(); 
	  if [$proof_links>0] { @title=`@newlevel`; } 
	  <b { "proof "; } 
       }

       <div { @class="add"; apply; }
       <b { "end;"; } 
    } 
}

// hence the rest is a top-level proof
// xsltxt cannot use xsl:document yet, so manually insert
// (now done as perl postproc)
// if you want ajax_proofs
tpl [Proof] {
    $nm = `concat($ajax_proof_dir,"/",$anamelc,"/",@newlevel)`;
    <div { 
	 <a { 
	    if [$ajax_proofs>0]	{ add_ajax_attrs(#u=$nm); } else { add_hs2_attrs(); }
	    if [$proof_links>0] { @title=`@newlevel`; } 
	    <b { "proof "; } 
	    }
         if [$ajax_proofs>0]	{ <span; 
// <xsl:document href="{$ajax_proof_dir}/{$anamelc}/{@newlevel}" format="html">
	    <div { @class="add"; apply; }
// </xsl:document>
   $bogus=`1`;
 }
	 else { <div { @class="add"; apply; } }
	 <b { "end;"; } 
	 } 
     }


//   Reasoning, elBlockThesis 
// #nkw tells not to print the keyword (used if hereby was printed above)
// ###TODO: fix for generating items (see Proposition)
tpl [Now](#nkw) 
{
    if [not($nkw="1")] 
    { 
       <div 
       { 
          if [@nr>0] { pplab(#nr=`@nr`, #vid=`@vid`); ": ";}

	  <a 
	  { 
	     add_hs2_attrs(); 
	     if [$proof_links>0] { @title=`@newlevel`; } 
	     <b {  "now "; } 
          }

          now_body();

	  <b { "end;"; } 
       }
    }
    else {  now_body(); }
}


tpl now_body
{
   <div 
   { 
      @class="add"; 
      apply[BlockThesis];
      apply[*[not(name()='BlockThesis')]]; 
   } 
}


tpl idv_for_top()
{
  $idv_html = "http://lipa.ms.mff.cuni.cz/~urban/idvtest/";

//  $idv_html = "file:///home/urban/mptp0.2/idvhtml/";
  $tptp_file = `concat($idv_html,"top/",$anamelc,".top.rated")`;
  " ";
  <img 
  {
    add_hs2_attrs();
    @src="hammock.jpg";
    @title="Show IDV graph for whole article";
    @alt="Show IDV graph for whole article";
  }

//   <a 
//   { 
// //    add_ajax_attrs(#u = $th);
//     add_hs2_attrs();
//     @title="Show IDV graph";
//     <b { " IDV graph "; } 
//   }

  <span 
  { 
      @style = "display:none"; 
      ":: Showing IDV graph ... (Click the Palm Trees again to close it)"; 
      <APPLET 
      { 
         @CODE = "IDVApplet.class";
	 @ARCHIVE = "IDV.jar,TptpParser.jar,antlr-2.7.5.jar";
	 @WIDTH = "0";
	 @HEIGHT = "0";
	 <PARAM { @NAME="URL"; @VALUE=$tptp_file; }
      }
  }
}



// tpl [Now](#nkw) {
//     <div { <b { if [not($nkw="1")] { "now ";} }
//     <div { @class="add"; apply[BlockThesis];
//            apply[*[not(name()='BlockThesis')]]; } 
//     <b { "end;"; } } } 

// separate top-level items by additional newline
tpl [Article] 
{ 
  <div
  {
    if [not($mk_header > 0)]
    {
       pcomment0(#str=`concat($aname, "  semantic presentation")`); 
    }
    if [$idv > 0] 
    { 
       idv_for_top();
    }
  }
    <br;

    for-each [*] 
    { 
      apply[.]; 
      if [(not(name()='Definiens')) and (not(name()='Reservation'))] { <br;} 
    } 
}

// processing of imported documents
tpl [Theorem] 
{ 
   <b { "theorem "; } 
   mkref(#aid=`@aid`, #nr=`@nr`, #k=`@kind`); <br; 
   if [Verum] { <b { "canceled; "; } } else { apply; } 
   <br; <br; 
}

// now used only when #mml=1 - in article the block has them
tpl [ArgTypes] { argtypes(#el = `*`); }

tpl argtypes(#el)
{ 
   if [$el] 
   { 
      <b { "let "; } 
      ploci(#nr="1");
      " be "; 
      alist(#j="1", #sep1=", ", #sep2=" be ", #elems=`$el`); 
      ";"; <br; 
   }
}

// #indef tells not to use Argtypes (we are inside Definition)
// note that this can also be used for displaying 
// environmental constructors, or constructor retrieved from other file
// #argt is explicit list of argument types, useful for
// getting the @vid (identifier numbers) of loci
// #nrt tells not to showthe result type(s)
tpl [Constructor](#indef,#nl,#argt,#nrt) 
{ 
    $loci = { if [($mml="1") or ($generate_items>0)] { "1"; } else { "2"; }}

    if [not($indef="1")] { apply[ArgTypes]; }

    if [@redefnr>0] 
    { 
       pcomment0(#str = "original: ");
       abs(#k=`@kind`,#nr=`@redefnr`,#sym=abs1(#k=`@kind`, #nr=`@redefnr`));
       <br;
       <b { "redefine "; }
    }

    <a { @NAME=`concat(@kind,@nr)`; <b { mkind(#kind=`@kind`); }  " "; }
 
    if [@kind="G"] 
    { 
       abs(#k=`@kind`,#nr=`@relnr`,#sym=abs1(#k=`@kind`, #nr=`@relnr`)); 
       "(# "; 

       for-each [Fields/Field] 
       { 
          abs(#k="U",#nr=`@nr`,#sym=abs1(#k="U", #nr=`@nr`)); 
	  if [not(position()=last())] { ", "; } 
       }

       " #)"; 
    }
    else 
    { 
       if [@kind='V'] 
       {
          $nr1 = `count(ArgTypes/Typ)`;
          if [$loci = 1] { ploci(#nr = $nr1); }
	  else { ppconst(#nr = $nr1, #vid = `$argt[position() = $nr1]/@vid`); }
	  " is ";  
       	  pp(#k=`@kind`,#nr=`@relnr`, #args = `$argt[position() < last()]`, #loci=$loci);
	  // abs(#k=`@kind`, #nr=`@relnr`, #sym=abs1(#k=`@kind`, #nr=`@relnr`)); 
       }
       else { pp(#k=`@kind`,#nr=`@relnr`, #args = $argt, #loci=$loci); }
       // "( ";  arglist(#separ=",", #elems=`ArgTypes/Typ`); ")"; 
    }

    if [not($nrt = 1) and 
        ((@kind = 'M') or (@kind = 'K') or (@kind= 'G') 
         or (@kind= 'U') or (@kind= 'L'))] 
    { 
       <b {" -> ";}
       // note that loci in Typs here can be translated to constants and identifiers
       // - see definition of LocusVar
       list(#separ=",",#elems=`Typ`); 
    }
 
    if [not($indef="1")]  
    {  
       ";"; <br;  <br; 
    }
    else { if [$nl="1"] { ";"; <br;} }
}

// display synonym and antonym definiiotns
tpl [NotationBlock/Pattern] {
// pp1(#k=`@constrkind`,#nr=`@constrnr`,#vis=`Visible/Int`,
// #fnr=`@formatnr`, #loci="1"); <br;
$loci = { if [$mml="1"] { "1"; } else { "2"; }}
$argtypes = `../Let/Typ`;
<a { @NAME=`concat("N",@kind,@nr)`;
<b { if [@antonymic] { "antonym "; } else { "synonym "; }}
pp1(#k=`@constrkind`,#nr=`@constrnr`, #args = $argtypes, #vis=`Visible/Int`,
#fnr=`@formatnr`, #loci=$loci); } <b { " for "; } 

pp(#k=`@constrkind`,#nr=`@constrnr`, #args = $argtypes,
#pid=`@redefnr`, #loci=$loci); ";"; <br;

}

// ignore forgetful functors - unhandled yet
tpl [Notations/Pattern] {
// pp1(#k=`@constrkind`,#nr=`@constrnr`,#vis=`Visible/Int`,
// #fnr=`@formatnr`, #loci="1"); <br;
   if [not(@kind = "J")]
   {
      apply[ArgTypes];

      if[Expansion]
      {

//	     $alc = lc(#s=`@aid`);
	     $sym = abs1(#k = "M", #fnr = `@formatnr`);
	     <b { "mode ";}  

	     absref(#elems = `.`, #c = "0", #sym = $sym, #pid = `@relnr`);

// 	     <a 
// 	     { 
// 	        @href=`concat($alc, ".", $ext, "#","NM",@nr)`; 
// 		if [$titles="1"] { @title=`concat(@aid,":","NM",".",@nr)`; }
// 		abs1(#k = "M", #fnr = `@formatnr`);
// 	     }

	     if [Visible/Int] 
	     { 
	        " of "; 
		for-each [Visible/Int] 
		{ 
		   ploci(#nr=`@x`); 
		   if [not(position()=last())] { ","; } 
                }
             }

	     <b { " is "; } 
          
 
	  apply[Expansion/Typ]; ";"; 
	  <br; 
      }
      else 
      {
         $loci = { if [$mml="1"] { "1"; } else { "2"; }}
	 <b { mkind(#kind=`@kind`); }  " ";
	 pp1(#k=`@constrkind`,#nr=`@constrnr`,#vis=`Visible/Int`,
	     #fnr=`@formatnr`, #loci="1"); 

	 <br;

      }

      <br;
}
}

// ignore normal Patterns now
tpl [Pattern] {}

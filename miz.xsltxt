stylesheet 1.0;

// XSLTXT (https://xsltxt.dev.java.net/) stylesheet taking 
// XML terms, formulas and types to less verbose format.

// To produce standard XSLT from this do e.g.: 
// java -jar xsltxt.jar toXSL miz.xsltxt >miz.xsl

// Then e.g.: xalan -XSL miz.xsl <ordinal2.pre >ordinal2.pre1

// TODO: number B vars in fraenkel
//       handle F and H parenthesis as K parenthesis
//       article numbering in Ref?
//       absolute definiens numbers for thesisExpansions?
//       do not display BlockThesis for Proof?
//       add @nr to canceled
//       Constructor should know its serial number! - needed in defs
//       possibly also article?
//       change globally 'G' to 'L' for types? -> then change the
//       hacks here and in emacs.el
//       display definiens?

// NOTES: constructor disambiguation is done using the absolute numbers
//        (attribute 'nr' and 'aid' of the Constructor element.
//        This info for Constructors not defined in the article is
//        taken from the .atr file (see variable $constrs)

output method=html;

// The following are user-customizable 

// mmlquery address
#mmlq= { "http://merak.pb.bialystok.pl/mmlquery/fillin.php?entry="; }
//#mmlq= {"";}

// linking methods:
// "q" - query, everything is linked to mmlquery
// "s" - self, everything is linked to these xml files
// "m" - mizaring, current article's constructs are linked to self,
//       the rest is linked to mmlquery
#linking = { "s"; }

// extension for linking - either xml or html
#ext = { "html"; }

// put titles to links or not
#titles = { "0"; }

// coloured output or not
#colored = { "0"; }


// tells whether relative or absolute names are shown
#relnames= { "1"; }


// keys for fast constructor and reference lookup
key "M" [Constructor[@kind='M']] `@relnr` ;
key "L" [Constructor[@kind='L']] `@relnr` ;
key "V" [Constructor[@kind='V']] `@relnr` ;
key "R" [Constructor[@kind='R']] `@relnr` ;
key "K" [Constructor[@kind='K']] `@relnr` ;
key "U" [Constructor[@kind='U']] `@relnr` ;
key "G" [Constructor[@kind='G']] `@relnr` ;

key "T" [/Theorems/Theorem[@kind='T']] `concat(@articlenr,':',@nr)`;
key "D" [/Theorems/Theorem[@kind='D']] `concat(@articlenr,':',@nr)`;
key "S" [/Schemes/Scheme] `concat(@articlenr,':',@nr)`;
key "DF" [Definiens] `@relnr` ;

// patterns are slightly tricky, since a predicate pattern
// may be linked to an attribute constructor; hence the
// indexing is done according to @constrkind and not @kind
// TODO: the attribute<->predicate change should propagate to usage
//       of "is"
// Expandable modes have all @constrkind='M' and @constrnr=0,
// they are indexed separately only on their @relnr (@pid)
key "P_M" [Pattern[(@constrkind='M') and (@constrnr>0)]] `@constrnr` ;
key "P_L" [Pattern[@constrkind='L']] `@constrnr` ;
key "P_V" [Pattern[@constrkind='V']] `@constrnr` ;
key "P_R" [Pattern[@constrkind='R']] `@constrnr` ;
key "P_K" [Pattern[@constrkind='K']] `@constrnr` ;
key "P_U" [Pattern[@constrkind='U']] `@constrnr` ;
key "P_G" [Pattern[@constrkind='G']] `@constrnr` ;
key "EXP" [Pattern[(@constrkind='M') and (@constrnr=0)]] `@relnr` ;

key "F" [Format] `@nr`;

key "D_G" [Symbol[@kind='G']] `@nr`;
key "D_K" [Symbol[@kind='K']] `@nr`;
key "D_J" [Symbol[@kind='J']] `@nr`;
key "D_L" [Symbol[@kind='L']] `@nr`;
key "D_M" [Symbol[@kind='M']] `@nr`;
key "D_O" [Symbol[@kind='O']] `@nr`;
key "D_R" [Symbol[@kind='R']] `@nr`;
key "D_U" [Symbol[@kind='U']] `@nr`;
key "D_V" [Symbol[@kind='V']] `@nr`;

$lcletters= { "abcdefghijklmnopqrstuvwxyz"; }
$ucletters= { "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; } 

// name of current article (upper case)
#aname= { `string(/*/@aid)`; }

// name of current article (lower case)
#anamelc= { `translate($aname, $ucletters, $lcletters)`; }

// this needs to be set to 1 for processing MML files
#mml = { if [/Article] { "0"; } else { "1"; } }

// nr. of clusters in Typ
// this is set to 1 for processing MML files
#cluster_nr = { if [$mml = "0"] { "2"; } else { "1"; }}

// .atr file with imported constructors
#constrs=  { `concat($anamelc, '.atr')`; }

// .eth file with imported theorems
#thms=  { `concat($anamelc, '.eth')`; }

// .esh file with imported schemes
#schms=  { `concat($anamelc, '.esh')`; }

// .eno file with imported patterns
#patts=  { `concat($anamelc, '.eno')`; }

// .frx file with all (both imported and article's) formats
#formats=  { `concat($anamelc, '.frx')`; }

// .dcx file with vocabulary
#vocs=  { `concat($anamelc, '.dcx')`; }

// .dfs file with imported definientia
#dfs=  { `concat($anamelc, '.dfs')`; }

#varcolor = { "Olive"; }

#constcolor = { "Maroon"; }

#locicolor = { "Maroon"; }

#labcolor = { "Green"; }

#commentcolor = { "Red"; }

// number of parenthesis colors (see the stylesheet in the bottom)
#pcolors_nr = { "6"; }

// top level element instead of top-level document, which is hard to
// know
#top = `/`;

// Formulas

// #i is nr of the bound variable, 1 by default 
// #k is start of the sequence of vars with the same type, $i by default 
// we now output only one typing for such sequences
tpl [For](#i,#k) { 
  $j = { if [$i] { $i;} else { "1"; } }
  $l = { if [$k] { $k;} else { $j; } }
  $nm = { `name(*[2])`; }
  if [($nm = "For") and (*[1]/@nr = *[2]/*[1]/@nr) 
      and (string(*[1]) = string(*[2]/*[1]))] { 
     apply[*[2]](#i=`$j+1`,#k=$l); }
  else {
  "for "; ft_list(#f=$l,#t=$j,#sep=", ");
  " being"; apply[*[1]]; if [not(($nm = "For"))] {" holds ";} 
  if [not(($nm = "Pred"))] { <br; }
  apply[*[2]](#i=`$j+1`); } }

// tpl [And/For] { <div {"for B being"; apply[*[1]]; 	
//                " holds "; <div { @class="add";  apply[*[2]]; } } }

tpl [Not](#i) { 
    if [Pred[(@kind='V') or (@kind='R')]] {  apply[*[1]](#i=$i,#not="1"); }
    else { "not "; apply[*[1]](#i=$i); } }
// tpl [And/Not] { if [For] { <div { "not "; apply[*[1]]; } }
//                else { "not "; apply[*[1]]; } }

tpl [And](#i) { "( "; ilist(#separ=" & ", #elems=`*`, #i=$i); " )"; }
tpl [Pred](#i,#not) { 
    choose {
      when [@kind='P'] { "P"; `@nr`; "["; list(#separ=",", #elems=`*`); "]";}
      when [(@kind='V') or (@kind='R')]  { 
	   $pi = { patt_info(#k=`@kind`, #nr=`@nr`, #pid =`@pid`); }
	   $fnr = car(#l=$pi);
	   $antonym = cadr(#l=$pi);
	   $neg = { if [$not="1"] { `($antonym + $not) mod 2`; }
		    else { $antonym; }}
           if [$neg="1"] { "not ";}
       if [@kind='V'] {
	  apply[*[position() = last()]]; " is ";  
	  abs(#k=`@kind`, #nr=`@nr`, #sym=abs1(#k=`@kind`, #nr=`@nr`, #fnr=$fnr)); }
       else { pp(#k=`@kind`,#nr=`@nr`,#args=`*`,#pid=`@pid`); }} }}
//,#sym1=abs(#k=`@kind`, #nr=`@nr`, #sym=abs1(#k=`@kind`, #nr=`@nr`))); }}
//  "[ "; list(#separ=",", #elems=`*`); "]"; }
tpl [PrivPred](#i) { "S"; `@nr`; "["; 
    list(#separ=",", #elems=`*[position() < last()]`); "]"; }
tpl [Is](#i) { apply[*[1]]; " is "; apply[*[2]]; } 
tpl [Verum](#i) { "verum"; }
tpl [ErrorFrm](#i) { "errorfrm"; }

// Terms
// #p is the parenthesis count
tpl [Var](#p) { pvar(#nr=`@nr`); } 
tpl [LocusVar](#p) { ploci(#nr=`@nr`); } 
tpl [FreeVar](#p) { "X"; `@nr`; }
tpl [Const](#p) { pconst(#nr=`@nr`); }
tpl [InfConst](#p) { "D"; `@nr`; }
tpl [Num](#p) {  `@nr`; }
tpl [Func](#p) { 
    choose {
      when [@kind='F'] { "F"; `@nr`; "("; list(#separ=",", #elems=`*`); ")";}
      when [@kind='U'] { "the ";
        abs(#k=`@kind`, #nr=`@nr`, #sym=abs1(#k=`@kind`, #nr=`@nr`));
        " of "; apply[*[position() = last()]](#p=$p); }
      otherwise { 
        $par = { if [$p>0] { `$p+1`;} else { 
                 if [name(..)='Func'] { "1"; } else { "0";} }  }
        pp(#k=`@kind`,#nr=`@nr`,#args=`*`,#parenth=$par); }}} 

tpl [PrivFunc](#p) { "H"; `@nr`; "("; 
    list(#separ=",", #elems=`*[position()>1]`); ")"; }
tpl [ErrorTrm](#p) { "errortrm"; }
tpl [Fraenkel](#p) { 
     $par = { if [$p>0] { `$p+1`;} else { "1"; } }
     $paren_color = `$par mod $pcolors_nr`;
     <span { @class=`concat("p",$paren_color)`; "{"; 
       <span { @class="default"; " ";
         apply[*[position() = last() - 1]](#p=$par); 
         if  [count(*)>2] { " where B is ";
            list(#separ=", B is ", #elems=`*[position() < last() - 1]`); }
         " : "; apply[*[position() = last()]]; " "; }
       "}"; } " ";
 }

// Types
tpl [Typ] { 
   " ";
   if [count(*)>0] { apply[*[1]]; }
   if [(@kind="M") or (@kind="G")] { 
      $pi = { patt_info(#k=`@kind`, #nr=`@nr`, #pid =`@pid`); }
      $fnr = car(#l=$pi);
      $expand = cadr(#l=$pi);
      $k1= { if [@kind="M"] { "M"; } else { "L";} }
      if [($expand="0") or not(@pid)] {
	 abs(#k=$k1, #nr=`@nr`, #sym=abs1(#k=`@kind`, #nr=`@nr`, #fnr=$fnr)); 
         if [count(*)>2] { " of "; list(#separ=",", 
				   #elems=`*[position()>$cluster_nr]`); } }
      else {
      abs(#k=$k1, #nr=`@nr`, #sym=abs1(#k=`@kind`, #nr=`@nr`, #fnr=$fnr));
      $vis= cddr(#l=$pi); $el =`.`;  //DEBUG ":"; `@pid`; ":"; $pi; ":";
//      apply[$el/*];
//      if [not(@pid)] {
      if [not($vis="")] { $pid=`@pid`; " of ";
       if [key('EXP',$pid)] { 
        for-each [key('EXP',$pid)] {
	  descent_many_vis(#patt=`Expansion/Typ`,#fix=$el,#vis=`Visible/Int`); }}
     else { for-each [document($patts,/)] {
       if [key('EXP',$pid)] { 
        for-each [key('EXP',$pid)] {
	     descent_many_vis(#patt=`Expansion/Typ`,#fix=$el,#vis=`Visible/Int`); 
}}}}}}}
     else { `@kind`; }}

// gets two Typ, and list of Visible/Int;
// tries to find and print the terms in #fix corresponding
// to the visible loci; #patt is structurally similar to
// #fix, up to the loci
tpl descent_many_vis(#patt,#fix,#vis) { if [$vis] {
    $v1= `$vis[position()=1]/@x`;
    $v2= `$vis[position()>1]`;
//DEBUG    "descen:"; $v1; ":"; apply[$patt]; ":"; 
    descent_many(#patts=`$patt/*[not(name()="Cluster")]`,
		 #fixs=`$fix/*[not(name()="Cluster")]`,#lnr=$v1,
		 #nr=`count($patt/*[not(name()="Cluster")])`); 
    if [$v2] { ","; descent_many_vis(#patt=$patt,#fix=$fix,
		    #vis=`$vis[position()>1]`); }
}}

tpl descent_many(#patts,#fixs,#lnr,#nr) { if [$nr > 0] {
    $patt=`$patts[position()=$nr]`;
    $fix =`$fixs[position()=$nr]`;
//DEBUG "desone:"; $nr; ":"; `name($patt)`; ":"; `name($fix)`; ":";
    if [(name($patt)="LocusVar") and ($patt/@nr=$lnr)] { 
//DEBUG    $lnr; ":"; `$patt/@nr`; ":";  "fff";
	  for-each [$top] { apply[$fix](#p="0"); } } 
// the duplication here is needed to generated the html properly;
// it does not cause any visible slowdown in practice
    else { $res= { if [name($patt) = name($fix)] { 
		      descent_many(#patts=`$patt/*`,#fixs=`$fix/*`,
				   #lnr=$lnr,#nr=`count($patt/*)`);  } 
                   else {"";}} 
      if [$res and not($res="")] {
//DEBUG [and contains($res,"fff")]
	  descent_many(#patts=`$patt/*`,#fixs=`$fix/*`,
		      #lnr=$lnr,#nr=`count($patt/*)`);  }
      else 
      { descent_many(#patts=$patts,#fixs=$fixs,#lnr=$lnr,#nr=`$nr - 1`); }}}}

// Clusters
// only attributes with pid are now printed, others are results of 
// cluster mechanisms
tpl [Cluster] { list(#separ=" ", #elems=`*[@pid]`); " "; }

// Adjective
tpl [Adjective] { 
     $pi = { patt_info(#k="V", #nr=`@nr`, #pid =`@pid`); }
     $fnr = car(#l=$pi);
     $anto = cadr(#l=$pi);
     $neg = { if [@value="false"] { `($anto + 1) mod 2`; } else { $anto; }}
     if [$neg="1"] { "non ";}
     abs(#k="V", #nr=`@nr`, #sym=abs1(#k="V", #nr=`@nr`, #fnr=$fnr)); }
//	         if [count(*)>0] { "("; list(#separ=",", #elems=`*`); ")"; }}

tpl [Proposition] { 
    if [following-sibling::*[1][(name()="By") and (@linked="true")]] { 
      if [not((name(..) = "Consider") or (name(..) = "Reconsider") 
              or (name(..) = "Conclusion"))] { <b { "then "; } }}
    if [@nr>0] { plab(#nr=`@nr`); ": ";}  apply; " ";}

// Justifications
tpl [By	] { if [(count(*)>0)] { <b { "by "; } 
      <i { list(#separ=", ", #elems=`*`); } } ";"; <br; }
tpl [IterStep/By] { if [(count(*)>0)] { <b { "by "; } 
      <i { list(#separ=", ", #elems=`*`); } }}
tpl [From] { <b { "from "; }
        <i { getschref(#anr=`@articlenr`, #nr=`@nr`); "(";
             list(#separ=", ", #elems=`*`); ")"; ";"; <br; } }
tpl [IterStep/From] { <b { "from "; } 
   <i { getschref(#anr=`@articlenr`, #nr=`@nr`); "(";
        list(#separ=", ", #elems=`*`); ")"; } }

tpl [Ref] { if [not(@articlenr)] {  plab(#nr=`@nr`); }
            else { getref(#k=`@kind`, #anr=`@articlenr`, #nr=`@nr`);} }
tpl [ErrorInf] { "errorinference;"; <br; }
tpl [IterStep/ErrorInf] { "errorinference"; }
tpl [SkippedProof] { <b { "@proof .. end;"; } <br; }
tpl [IterStep/SkippedProof] { <b { "@proof .. end;"; } }

//   Term, elIterStep+
tpl [IterEquality] { if [IterStep[1]/By[@linked="true"]] {
    if [not(name(..)="Conclusion")] { <b { "then ";}}}
   if [@nr>0] {  plab(#nr=`@nr`); ": ";}
   apply[*[1]]; " = ";
   nlist(#separ=".= ", #elems=`IterStep`); ";"; <br; }
tpl [IterStep] { apply;  }

// Skeleton steps
//tpl [Let] { $j=`@nr`; <b { "let "; } pconst(#nr=$j);
//             " be "; 
//            jlist(#j=$j, #sep2=" be ", #elems=`*`); 
//	    ";"; try_th_exps(#el=`.`); <br; }

tpl [Let] { $j=`@nr - 1`; <b { "let "; } 
	    jtlist(#j=$j, #sep2=" be ", #elems=`Typ`); 
            ";"; try_th_exps(#el=`.`); <br; }

tpl [Assume] { <b { "assume "; }  if [count(*)>1] { "that "; }
	       nlist(#separ="and ", #elems=`*`);
               ";"; try_th_exps(#el=`.`); <br; } 

tpl [Given] { $j=`@nr - 1`; <b {"given ";} 
              jtlist(#j=$j, #sep2=" being ", #elems=`Typ`); 
	      " such that ";
              nlist(#separ="and ",#elems=`Proposition`); 
              ";"; try_th_exps(#el=`.`); <br; }

tpl [Take] { <b { "take ";} apply; ";"; try_th_exps(#el=`.`); <br; }
tpl [TakeAsVar] { <b { "take "; } pconst(#nr=`@nr`); " = ";   apply[*[2]]; 
		  ";"; try_th_exps(#el=`.`); <br; }
tpl [Conclusion] { <b { if [(By[@linked="true"]) or 
		   (IterEquality/IterStep[1]/By[@linked="true"])] 
		   { "hence "; }
			else { "thus "; }} apply; }
tpl [Case] { <b { "case "; } if [count(*)>1] { "that ";}
             nlist(#separ="and ", #elems=`*`); ";"; <br; }
tpl [Suppose] { <b { "suppose "; } if [count(*)>1] { "that ";} 
             nlist(#separ="and ", #elems=`*`); ";"; <br; }
tpl [PerCases] { <b { "per cases "; } apply; }

// Auxiliary items
tpl [Consider] { $j=`@nr - 1`; <b { if [By[@linked="true"]] { "then "; }
		 "consider ";}
                 jtlist(#j=$j,#sep2=" being ", #elems=`Typ`);
	         if [count(Proposition) > 1] { 
                   " such that "; <br; 
		   nlist(#separ="and ",
                        #elems=`Proposition[position() > 1]`); } 
                 apply[*[2]]; }

tpl [Reconsider] { $j=`@nr`; <b { if [By[@linked="true"]] { "then "; } 
    "reconsider "; } pconst(#nr=$j); " = "; 
    jlist(#j=$j, #sep2=" = ", #elems=`*[(position() > 1) 
                        and (position() < (last() - 1))]`);
    " as "; apply[*[1]]; " "; 
    apply[*[last()]]; } 

tpl [Set] { <b { "set ";} pconst(#nr=`@nr`); " = "; apply[*[1]]; ";"; <br; }
tpl [DefFunc] { <b { "deffunc"; } " H"; `@nr`; "(";  
                list(#separ=",", #elems=`ArgTypes/Typ`); ") "; <b {"-> ";}
                apply[*[3]]; " = ";
	        apply[*[2]]; ";"; <br; }
tpl [DefPred] { <b { "defpred";} " S"; `@nr`; "["; 
                list(#separ=",", #elems=`ArgTypes/Typ`); "] means ";
	        apply[*[2]]; ";"; <br; }

// Thesis after skeleton item, with definiens numbers
// forbid as default
tpl [Thesis] { }

tpl try_th_exps(#el) { for-each [$el] {
    apply[./following-sibling::*[1][name()="Thesis"]/ThesisExpansions]; } }

tpl [ThesisExpansions] { if [Pair] {
    " "; pcomment0(#str="uses "); 
    list(#separ=",", #elems=`Pair[@x]`); } }

tpl [ThesisExpansions/Pair] { 
   $x= `@x`;
   if [key('DF',$x)] { 
      for-each [key('DF',$x)] { 
	       mkref(#aid=`@aid`, #nr=`@defnr`, #k="D", #c="1"); }}
   else { 
      for-each [document($dfs,/)] { 
            for-each [key('DF',$x)] { 
	       mkref(#aid=`@aid`, #nr=`@defnr`, #k="D"); } }}}

// Registrations
tpl [RCluster] { if [$mml="1"] { apply[ArgTypes]; }
                 <b { "cluster "; }
                 if [ErrorCluster] { "errorcluster"; }
	         else { apply[*[3]]; " "; apply[*[2]]; }
                 ";"; <br; if [$mml="1"] { <br; }}
tpl [CCluster] { if [$mml="1"] { apply[ArgTypes]; }
                 <b { "cluster "; }
                 if [ErrorCluster] { "errorcluster"; }
	         else { apply[*[2]]; <b {" -> ";} apply[*[4]]; " "; 
                        apply[*[3]]; }
                 ";"; <br; if [$mml="1"] { <br; }}
tpl [FCluster] { if [$mml="1"] { apply[ArgTypes]; }
                 <b { "cluster "; }
                 if [ErrorCluster] { "errorcluster"; }
	         else { apply[*[2]]; <b {" -> ";} apply[*[3]]; }
                 ";"; <br; if [$mml="1"] { <br; }}
// Blocks
tpl [BlockThesis] { } // "blockthesis: "; apply; ";"; <br; }

//   (  ( elBlockThesis, elCase, elThesis, Reasoning )
//   |  ( elCase, Reasoning, elBlockThesis ) )
tpl [CaseBlock] { 
    <div { apply[Case];
    <div { @class="add"; apply[*[not(name()='Case')]]; }
    <b { "end;"; } } }

tpl [SupposeBlock] {
    <div { apply[Suppose];
    <div { @class="add"; apply[*[not(name()='Suppose')]]; }
    <b { "end;"; } } }

//   (  ( elBlockThesis, ( elCaseBlock+ | elSupposeBlock+ ),
//        elPerCases, elThesis, elEndPosition  )
//   |  ( ( elCaseBlock+ | elSupposeBlock+ ),
//        elPerCases, elEndPosition, elBlockThesis ) )
tpl [PerCasesReasoning] {
    <div { apply[PerCases];
    <div { @class="add"; apply[BlockThesis];
           apply[Thesis];
           apply[CaseBlock | SupposeBlock]; }
    <b { "end;"; } } }

//   elBlockThesis, Reasoning 
tpl [Proof] {
    <div { <b { "proof "; } 
    <div { @class="add"; apply; }
    <b { "end;"; } } } 

//   Reasoning, elBlockThesis 
tpl [Now] {
    <div { <b { "now "; }
    <div { @class="add"; apply[BlockThesis];
           apply[*[not(name()='BlockThesis')]]; } 
    <b { "end;"; } } } 


// ignore them
tpl [Reservation/Typ] { ""; }
tpl [Definiens/*] { ""; }

tpl [JustifiedTheorem] { <b { "theorem "; } 
    for-each [Proposition[@nr > 0]] { plab(#nr=`@nr`); ": "; } 
    $nr1 = `1+count(preceding-sibling::JustifiedTheorem)`;
    <a { @NAME=`concat("T",$nr1)`; 
	 pcomment(#str=`concat($aname,":",$nr1)`); }
    if [Proof] { <div { @class="add"; apply[*[1]/*[1]]; } apply[*[2]]; }
    else { <div { @class="add"; 
        if [Proposition/Verum] { <b { "canceled; "; } }
	else { apply[*[1]/*[1]]; " "; apply[*[2]]; } } } }

tpl [DefTheorem] { 
    if [@constrkind] { pcomment0(#str="defines "); 
		abs(#k=`@constrkind`, #nr=`@constrnr`, 
                    #sym=abs1(#k=`@constrkind`, #nr=`@constrnr`)); <br;}
    <b { "deftheorem "; } 
    for-each [Proposition[@nr > 0]] { plab(#nr=`@nr`); ": "; } 
    $nr1 = `1+count(preceding-sibling::DefTheorem)`;
    <a { @NAME=`concat("D",$nr1)`; 
	 pcomment(#str=`concat($aname,":def ",$nr1)`); }     
    <div { @class="add"; 
         if [Proposition/Verum] { <b { "canceled; "; } }
	 else { apply[*[1]/*[1]];  ";"; }  } }


//   Property, elProposition, Justification
tpl [JustifiedProperty] {
    <b { `translate(name(*[1]), $ucletters, $lcletters)`; }  <br; 
    apply[*[position()>1]]; }

//  Formula | ( elProposition, Justification )
tpl [UnknownCorrCond|Coherence|Compatibility|Consistency|Existence|Uniqueness] 
    { <b { `translate(name(), $ucletters, $lcletters)`; }
           <br; apply; }

// CorrectnessCondition*, elProposition, Justification
tpl [Correctness] { <b { "correctness: "; } <br; apply; }

tpl [Canceled] { <b { "canceled;"; } <br; }

tpl [SchemeFuncDecl] { 
    "F"; `@nr`; "(";
     list(#separ=",", #elems=`ArgTypes/Typ`); ") "; <b {"-> ";}
     apply[*[2]]; }

tpl [SchemePredDecl] { 
    "P"; `@nr`; "[";
     list(#separ=",", #elems=`ArgTypes/Typ`); "]"; }

//   ( elSchemeFuncDecl | elSchemePredDecl )*,
//   element elSchemePremises { elProposition* },
//   elProposition, Justification, elEndPosition
tpl [SchemeBlock] {
    <div { <a { @NAME=`concat("S",@schemenr)`; <b { "scheme  "; }
    pcomment(#str=`concat($aname,":sch ",@schemenr)`); }
     "s"; `@schemenr`; "{ ";
    list(#separ=", ", #elems=`SchemeFuncDecl|SchemePredDecl`); 
    " } :"; <br;
    <div { @class="add"; apply[Proposition]; } <b { "provided"; }
    <div { @class="add"; list(#separ=" and ", #elems=`SchemePremises/Proposition`); }
    apply[*[position() = last() - 1]];  }}


//   ( ( CorrectnessCondition*, elCorrectness?,
//       elJustifiedProperty*, elConstructor? )
//   | ( elConstructor, elConstructor, elConstructor+,
//       CorrectnessCondition*, elCorrectness? ))
tpl [Definition] {     
    if [@expandable="true"] { 
       $cnt = `1 + count(preceding-sibling::Definition[@expandable="true"])`;
       // get the $cnt-th pattern following this DefinitionBlock
       for-each [../following-sibling::Pattern[Expansion]] {
         if [position()=$cnt] {
	 <b { "expandable mode: is "; } apply[Expansion/Typ]; ";"; <br; }}}
    else { apply[Constructor](#nat="1"); }
    apply[*[not(name()='Constructor')]]; }

//   ( elLet | elAssume | elGiven | AuxiliaryItem |
//     elCanceled | elDefinition )*, elEndPosition
tpl [DefinitionBlock] {
   <div { <b { "definition"; }
   <div { @class="add"; apply[*[not(name()='EndPosition')]]; }
   <b { "end;"; } }  } 

//   ( elRCluster | elFCluster | elCCluster ),
//   CorrectnessCondition*, elCorrectness?
tpl [Registration] { apply; }

//   ( elLet | AuxiliaryItem | elRegistration | elCanceled )+, elEndPosition
tpl [RegistrationBlock] {
    <div { <b { "registration"; }
    <div { @class="add"; apply[*[not(name()='EndPosition')]]; }
    <b { "end;"; } }  } 

tpl [NotationBlock] {
    <div { <b { "notation"; }
    <div { @class="add"; apply[*[not(name()='EndPosition')]]; }
    <b { "end;";  } }  } 


tpl lc(#s) { `translate($s, $ucletters, $lcletters)`; }
tpl uc(#s) { `translate($s, $lcletters, $ucletters)`; }

// poor man's data structure, aka "colon-list"
#nil = { ""; }
tpl cons(#h,#t) { `concat($h,":",$t)`; }
tpl car(#l) { `substring-before($l,":")`;}
tpl cdr(#l) { `substring-after($l,":")`;}
tpl cadr(#l) { car(#l=cdr(#l=$l));}
tpl cddr(#l) { cdr(#l=cdr(#l=$l));}

// List utilities

tpl list(#separ,#elems) { 
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { $separ; } }
}

// List utility with additional arg
tpl ilist(#separ,#elems,#i) { 
 for-each [$elems] {
  apply[.](#i=$i); if [not(position()=last())] { $separ; } }
}

// newlined list
tpl nlist(#separ,#elems) { 
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { <br; $separ; } }
}

tpl dlist(#separ,#elems) { 
 for-each [$elems] {
  <div { apply[.]; if [not(position()=last())] { $separ; } } }
}

// argument list
tpl arglist(#separ,#elems) { 
 for-each [$elems] {
  ploci(#nr=`position()`); if [not(position()=last())] { $separ; } }
}

tpl jtlist(#j,#sep2,#elems) { 
    for-each [$elems] { pconst(#nr=`$j+position()`);
        if [position()=last()] { $sep2; apply[.]; }
	   else { if [not(string() = string(following-sibling::*[1]))] {
		  $sep2; apply[.]; } ", "; }} } 

// add numbers starting at #j+1 between #sep1 and #sep2 - now with constants
tpl jlist(#j,#sep2,#elems) { 
for-each [$elems] {
  apply[.]; if [not(position()=last())] 
  {  ", "; pconst(#nr=`$j+position()`); $sep2; } }}

// like jlist, but with loci
tpl alist(#j,#sep1,#sep2,#elems) { 
for-each [$elems] {
  apply[.]; if [not(position()=last())] 
  {  $sep1; ploci(#nr=`$j+position()`); $sep2; } }}


// from-to list of variables starting numbering at $f ending at $t
tpl ft_list(#f,#t,#sep) {
  if [$f = $t] {  pvar(#nr=$f); }
  else { if [$f < $t] { pvar(#nr=$f); $sep; 
            ft_list(#f=`$f+1`,#t=$t,#sep=$sep); } }}

// add the constructor href, $c tells if it is from current article
// #sym is optional Mizar symbol
tpl absref(#elems,#c,#sym) { 
     for-each [$elems] { $mk=mkind(#kind=`@kind`); $alc=lc(#s=`@aid`);
      <a { 
       if [($linking = 'q') or (($linking = 'm') and not($c = "1"))] { 
//          @onClick="l1(this.getAttribute('lu'))";
//          @lu = `concat(@aid,":",$mk,".",@nr)`;
//	    @href=`concat($alc, ".html#",@kind,@nr)`;
          @href=`concat($mmlq,@aid,":",$mk,".",@nr)`;
	  }
       else { 
         @href=`concat($alc, ".", $ext, "#",@kind,@nr)`; 
         if [$c] { @target="_self"; } }
       if [$titles="1"] { @title=`concat(@aid,":",$mk,".",@nr)`; }
       if [$sym] { $sym; }
       else { if [$relnames>0] { `@kind`; `@relnr`; }
         else { `@kind`; `@nr`; "_"; `@aid`;  } } }} }

tpl abs(#k,#nr,#sym) { 
   #c1 = { if [$mml = "1"] { "0"; } else { "1"; } }
   if [key($k,$nr)] { absref(#elems=`key($k,$nr)`,#c=$c1,#sym=$sym); }
   else { 
      for-each [document($constrs,/)] { 
      absref(#elems=`key($k,$nr)`,#sym=$sym); } } }


// return first symbol corresponding to constructor;
// if nothing found, just concat #k and #nr; #r says to look for
// right bracket instead of left or fail if the format is not bracket
tpl abs1(#k,#nr,#r,#fnr,#pid) {
   $fnr1= { if [$fnr] { $fnr;} else { formt_nr(#k=$k,#nr=$nr,#pid=$pid);}}
   for-each [document($formats,/)] {
     if [not(key('F',$fnr1))] { `concat($k,$nr)`; }
     else {
       for-each [key('F',$fnr1)] {
          $snr=`@symbolnr`; $sk=`@kind`; $dkey=`concat('D_',@kind)`;
          $rsnr= { if [$sk='K'] { `@rightsymbolnr`; } } 
        if [not($r='1') or ($sk='K')] {
         for-each [document($vocs,/)] {
          if [key($dkey,$snr)] {
	   for-each [key($dkey,$snr)] { 
             if [($sk='K') and ($r='1')] { 
               for-each [key('D_L',$rsnr)] { `@name`; } }
	     else {  `@name`; }
             } } 
          else { choose { 
           when [($snr='1') and ($sk='M')] { "set"; }
           when [($snr='1') and ($sk='R')] { "="; }
           when [($snr='1') and ($sk='K')] { if [$r='1'] { "]";} else {"[";} } 
           when [($snr='2') and ($sk='K')] { if [$r='1'] { "}";} else {"{";} }
	  otherwise { `concat($k,$nr)`; } } } } } } } } }

tpl formt_nr(#k,#nr,#pid) { $j = { patt_info(#k=$k,#nr=$nr,#pid=$pid); }
			    car(#l=$j);
//			    `string(floor($j div 2))`; 
}

tpl mk_vis_list(#els) { 
//    $t = mk_vis_list(#els=`$els[position()>1]`);
    for-each [$els] { `@x`; ":"; }}

// returns 2 * formatnr + 1 if antonymic or expandable;
// this is a small hack to minimize chasing patterns
tpl patt_info(#k,#nr,#pid) {
     $k1= { if [$k="L"] { "G"; } else { $k; }}
     $md = `($k1 = "G") or ($k1="M")`;
     $pkey=`concat('P_',$k1)`;
     if [$pid>0] {
     if [$md and key('EXP',$pid)] { 
	for-each [key('EXP',$pid)] { 
		 $vis = mk_vis_list(#els=`Visible/Int`);
		 cons(#h=`@formatnr`,#t=cons(#h="1",#t=$vis));} }
     else { if [key($pkey,$nr)[$pid=@relnr]] { 
        for-each [key($pkey,$nr)[$pid=@relnr]] {
		 $shift = { if [@antonymic] {"1";} else {"0";}}
		 $vis = mk_vis_list(#els=`Visible/Int`);
		 cons(#h=`@formatnr`,#t=cons(#h=$shift,#t=$vis));} }
     else { for-each [document($patts,/)] {
     if [$md and key('EXP',$pid)] { 
	for-each [key('EXP',$pid)] { 
		 $vis = mk_vis_list(#els=`Visible/Int`);
		 cons(#h=`@formatnr`,#t=cons(#h="1",#t=$vis));} }
     else { if [key($pkey,$nr)[$pid=@relnr]] {
                for-each [key($pkey,$nr)[$pid=@relnr]] {
		 $shift = { if [@antonymic] {"1";} else {"0";}}
		 $vis = mk_vis_list(#els=`Visible/Int`);
		 cons(#h=`@formatnr`,#t=cons(#h=$shift,#t=$vis));
//		 `(@formatnr + @formatnr) + $shift`; 
} }
else { "failedpid:"; $k1;":";$nr;":"; $pid;":";}
}}}}}
     else { 
     if [key($pkey,$nr)] { 
        for-each [key($pkey,$nr)[position()=1]] {
	         $shift = { if [Expansion or @antonymic] {"1";} else {"0";}}
		 $vis = mk_vis_list(#els=`Visible/Int`);
		 cons(#h=`@formatnr`,#t=cons(#h=$shift,#t=$vis));} }
     else { for-each [document($patts,/)] {
                for-each [key($pkey,$nr)[position()=1]] {
	        $shift = { if [Expansion or @antonymic] {"1";} else {"0";}}
		 $vis = mk_vis_list(#els=`Visible/Int`);
		 cons(#h=`@formatnr`,#t=cons(#h=$shift,#t=$vis));}}} } }


// pretty printer - gets arguments, visibility info from pattern,
// format telling arities, the linked symbol and optionally right bracket
// parenth hints to put the whole expression in parentheses, but this
// is overrriden if the expression uses functor brackets
tpl pp(#k,#nr,#args,#parenth,#pid) {
     $pkey=`concat('P_',$k)`;
     // pattern number given
     if [$pid>0] {
     if [key($pkey,$nr)[$pid=@relnr]] { 
        for-each [key($pkey,$nr)[$pid=@relnr]] {
       pp1(#k=$k,#nr=$nr,#args=$args, #vis=`Visible/Int`, 
           #fnr=`@formatnr`, #parenth=$parenth); } }
     else { for-each [document($patts,/)] {
              if [key($pkey,$nr)[$pid=@relnr]] {
                for-each [key($pkey,$nr)[$pid=@relnr]] {
     pp1(#k=$k,#nr=$nr,#args=$args, #vis=`Visible/Int`,
         #fnr=`@formatnr`, #parenth=$parenth); } }
// failure, print in absolute notation
     else { abs(#k=$k, #nr=$nr); "("; 
       list(#separ=",",#elems=$args); ")"; }
     }}}
     // pattern number not given - take first suitable
     else {
     if [key($pkey,$nr)] { 
        for-each [key($pkey,$nr)[position()=1]] {
       pp1(#k=$k,#nr=$nr,#args=$args, #vis=`Visible/Int`, 
           #fnr=`@formatnr`, #parenth=$parenth); } }
     else { for-each [document($patts,/)] {
              if [key($pkey,$nr)] {
                for-each [key($pkey,$nr)[position()=1]] { 
     pp1(#k=$k,#nr=$nr,#args=$args, #vis=`Visible/Int`,
         #fnr=`@formatnr`, #parenth=$parenth); } }
// failure, print in absolute notation
     else { abs(#k=$k, #nr=$nr); "("; 
       list(#separ=",",#elems=$args); ")"; }
}}}
}
 

tpl pp1(#k,#nr,#args,#vis,#fnr,#parenth) {
    $la = { if [($k='M') or ($k='G') or ($k='L')] {  "0"; } 
            else { for-each [document($formats,/)] {
                     for-each [key('F',$fnr)] { 
                       if [@leftargnr] { `@leftargnr`;} else { "0";} }}} }
    // try if right bracket
    $rsym = { if [($k='K') and ($la='0')] {
                 abs1(#k=$k, #nr=$nr, #r="1"); } }
    $np = { if [not($args)] { "0"; } else {
               if [$parenth>0] { $parenth; } else { 
                  if [not($rsym='')] { "1"; } else { "0";} } } }
    $paren_color = `$np mod $pcolors_nr`;

    // print spanned paranthesis or left bracket
    if [($np>0)] { <span { @class=`concat("p",$paren_color)`;
      if [$rsym=''] { "("; } else { 
         abs(#k=$k, #nr=$nr, #sym=abs1(#k=$k, #nr=$nr, #fnr=$fnr)); } 
      <span { @class="default";

    // this is duplicated later - needed for Mozilla - bad escaping
      for-each [$vis] { 
       if [position() <= $la] {
	$x=`@x`;
	apply[$args[position() = $x]](#p=$np); 
	if [position() < $la] { ",";} } }
      if [$rsym=''] {
       if [not($parenth>0) or ($la>0)] { " "; } 
       abs(#k=$k, #nr=$nr, #sym=abs1(#k=$k, #nr=$nr, #fnr=$fnr)); " "; }
      for-each [$vis] { 
       if [(position() = 1) and (($k='M') or ($k='L'))] { "of "; }
       if [position() > $la] {
	$x=`@x`;
        apply[$args[position()  = $x]](#p=$np); 
        if [position() < last()] { ",";} } }
       }
      if [$rsym=''] { ")"; } else { abs(#k=$k, #nr=$nr, #sym=$rsym); } }
    } else {

      for-each [$vis] { 
       if [position() <= $la] {
	$x=`@x`;
	apply[$args[position() = $x]](#p=$np); 
	if [position() < $la] { ",";} } }
      if [$rsym=''] {
       if [not($parenth>0) or ($la>0)] { " "; } 
       abs(#k=$k, #nr=$nr, #sym=abs1(#k=$k, #nr=$nr, #fnr=$fnr)); " "; }
      for-each [$vis] { 
       if [(position() = 1) and (($k='M') or ($k='L'))] { "of "; }
       if [position() > $la] {
	$x=`@x`;
        apply[$args[position()  = $x]](#p=$np); 
        if [position() < last()] { ",";} } } 
     }
 }


//  apply[.]; if [not(position()=last())] { $sep1; `$j+position()`; $sep2; } }}

// pretty print variables and labels
tpl pvar(#nr) { if [$colored="1"] { <font { @color=$varcolor; 
    "b"; <sub { $nr;} } } else { "b"; <sub { $nr;} } }

tpl pconst(#nr) {  if [$colored="1"] { <font { @color=$constcolor; 
    "c"; <sub { $nr;} } } else { "c"; <sub { $nr;} } }

tpl ploci(#nr) {  if [$colored="1"] { <font { @color=$locicolor; 
    "a"; <sub { $nr;} } } else { "a"; <sub { $nr;} } }

tpl plab(#nr) { <i {  if [$colored="1"] { <font { @color=$labcolor; 
    "E"; `@nr`;} }  else { "E"; `@nr`;} } }

tpl pcomment0(#str) { <i { if [$colored="1"] {
<font {@color=$commentcolor; ":: "; $str;}} else { ":: "; $str;}}}

tpl pcomment(#str) { pcomment0(#str=$str); <br;}

// theorem, definition and scheme references
// add the reference's href, $c tells if it is from current article
tpl mkref(#aid,#nr,#k,#c) { 
      $mk=refkind(#kind=$k); $alc=lc(#s=$aid);
      <a {   
       @class="ref";
       if [($linking = 'q') or (($linking = 'm') and not($c))] { 
          @href=`concat($mmlq,$aid,":",$mk,".",$nr)`; }
       else { 
	 @href=`concat($alc, ".", $ext, "#",$k,$nr)`;  
         if [$c] { @target="_self"; } }
       if [$titles="1"] { @title=`concat($aid,":",$mk,".",$nr)`; }
       $aid; ":"; if [not($k="T")] { $mk; " ";} $nr;  } }

tpl getschref(#anr,#nr) {
    if [$anr>0] { for-each [document($schms,/)] {
	for-each [key('S',concat($anr,':',$nr))] { 
           mkref(#aid=`@aid`, #nr=$nr, #k="S"); }}}
    else { mkref(#aid=$aname,#nr=$nr,#k="S",#c="1"); }}

tpl getref(#k,#anr,#nr) {
    if [$anr>0] { for-each [document($thms,/)] {
	for-each [key($k,concat($anr,':',$nr))[position()=1]] { 
           mkref(#aid=`@aid`, #nr=$nr, #k=$k); }}}
    else { mkref(#aid=$aname,#nr=$nr,#k=$k,#c="1"); }}

// translate constructor kinds to their mizar/mmlquery names
tpl mkind(#kind) {
   choose { 
      when [$kind = 'M'] { "mode";}
      when [$kind = 'V'] { "attr";}
      when [$kind = 'R'] { "pred";}
      when [$kind = 'K'] { "func";}
      when [$kind = 'G'] { "aggr";}
      when [$kind = 'L'] { "struct";}
      when [$kind = 'U'] { "sel";}
 }}

// translate reference kinds to their mizar/mmlquery names
tpl refkind(#kind) {
  choose { 
      when [$kind = 'T'] { "th";}
      when [$kind = 'D'] { "def";}
      when [$kind = 'S'] { "sch";}
  }}


// separate top-level items by additional newline
tpl [Article] { 
    pcomment(#str=`concat($aname, "  semantic presentation")`); <br;
    for-each [*] { apply[.]; 
      if [(not(name()='Definiens')) and (not(name()='Reservation')) 
          and (not(name()='Pattern'))] { <br;} } }

// processing of imported documents
tpl [Theorem] { <b { "theorem "; } 
    mkref(#aid=`@aid`, #nr=`@nr`, #k=`@kind`); <br; 
    if [Verum] { <b { "canceled; "; } } else { apply; } <br; <br; }

// now used only when #mml=1 - in article the block has them
tpl [ArgTypes] { if [*] { <b { "let "; } ploci(#nr="1");
             " be "; 
            alist(#j="1", #sep1=", ", #sep2=" be ", #elems=`*`); ";"; <br; }}

// #nat tells not to use Argtypes
tpl [Constructor](#nat) { 
    if [not($nat="1")] { apply[ArgTypes]; }
    if [@redefnr>0] { <b { "redefine "; } }
    <a { @NAME=`concat(@kind,@nr)`; <b { mkind(#kind=`@kind`); }  " "; } 
    if [@redefnr>0] { 
         abs(#k=`@kind`,#nr=`@redefnr`,#sym=abs1(#k=`@kind`, #nr=`@redefnr`));
         " as "; }
    abs(#k=`@kind`,#nr=`@relnr`,#sym=abs1(#k=`@kind`, #nr=`@relnr`)); 
    if [@kind="G"] { "(# "; 
       for-each [Fields/Field] { 
		   abs(#k="U",#nr=`@nr`,#sym=abs1(#k="U", #nr=`@nr`)); 
		   if [not(position()=last())] { ", "; } }
       " #)"; }
    else { "( ";  arglist(#separ=",", #elems=`ArgTypes/Typ`); ")"; }
    if [(@kind = 'M') or (@kind = 'K') or (@kind= 'G') 
        or (@kind= 'U') or (@kind= 'L')] { <b {" -> ";}
	   list(#separ=",",#elems=`Typ`); } 
    ";"; <br;     if [not($nat="1")]  { <br; }}

// ignore Patterns now
tpl [Pattern] {}

// Default
tpl [/] { <html { 

// output the css defaults for div and p (for indenting)
        <style { @type="text/css";  "
div { padding: 0 0 0 0; margin: 0 0 0 0; } 
div.add { padding-left: 3mm; padding-bottom: 0mm;  margin: 0 0 0 0; } 
p { margin: 0 0 0 0; } 
a {text-decoration:none} a:hover { color: red; } 
a.ref { font-size:x-small; }
a.ref:link { color:green; } 
a.ref:hover { color: red; } 
span.p1:hover { color : inherit; background-color : #BAFFFF; } 
span.p2:hover { color : inherit; background-color : #FFCACA; }
span.p3:hover { color : inherit; background-color : #FFFFBA; }
span.p4:hover { color : inherit; background-color : #CACAFF; }
span.p5:hover { color : inherit; background-color : #CAFFCA; }
span.p0:hover { color : inherit; background-color : #FFBAFF; }
.default { background-color: white; color: black; } 
.default:hover { background-color: white; color: black; }
";
	                } 
        <head {  <base { 
if [$linking = "s"] { @target="_self"; } else { @target="mmlquery";} } 
// <script { @type="text/javascript";
// "
// <!-- 
// var browse_url = \"http://merak.pb.bialystok.pl/mmlquery/fillin.php?entry=\"
// function l1(c) { location = browse_url + c }
// // End -->
// "; }
}
        <body {  

// first read the keys for imported stuff
//          apply[document($constrs,/)/Constructors/Constructor]; 
//          apply[document($thms,/)/Theorems/Theorem]; 
//          apply[document($schms,/)/Schemes/Scheme];
 
// then process the whole document
          apply; }} }
  
// tpl [*] { copy { apply [@*]; apply; } }
// tpl [@*] { copy-of `.`; }


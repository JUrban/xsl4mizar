stylesheet 1.0;

// XSLTXT (https://xsltxt.dev.java.net/) stylesheet taking 
// XML terms, formulas and types to less verbose format.

// To produce standard XSLT from this do e.g.: 
// java -jar xsltxt.jar toXSL miz.xsltxt >miz.xsl

// Then e.g.: xalan -XSL miz.xsl <ordinal2.pre >ordinal2.pre1

// TODO: number B vars in 'for' and fraenkel
//       number C vars in 'Let', 'Given', TakeAsVar, (Re)Consider,
//                        'Set',
//       numbers for Deffunc, Defpred
//       article numbering in Ref?
//       absolute definiens numbers for thesisExpansions?
//       add @name to Article
//       do not display BlockThesis for Proof?
//       add @nr to canceled
//       Reservartion -> Reservation; displaying?
//       Constructor should know its serial number! - needed in defs
//       possibly also article?
//       change globally 'G' to 'L' for types? -> then change the
//       hacks here and in emacs.el
//       display definiens?

output method=html;

// Indenting step
$add= { "&#160;&#160;&#160;"; }

$lcletters= { "abcdefghijklmnopqrstuvwxyz"; }
$ucletters= { "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; } 

// Formulas
tpl [For](#i) { $j=`concat($i,$add)`; 
                "for B being"; apply[*[1]](#i=$i); 	
                 " holds "; <br; $j; apply[*[2]](#i=$j); } 
tpl [Not](#i) { "not "; apply[*[1]](#i=$i); }
tpl [And](#i) { "( "; list(#separ=" & ", #elems=`*`, #i=$i); " )"; }
tpl [Pred](#i) { `@kind`; `@nr`; "[ "; 
                 list(#separ=",", #elems=`*`, #i=$i); "]";}
tpl [PrivPred](#i) { "S"; `@nr`; "[ "; 
                     list(#separ=",", #elems=`*`, #i=$i); "]";}
tpl [Is](#i) { apply[*[1]](#i=$i); " is "; apply[*[2]](#i=$i); } 
tpl [Verum](#i) { "verum"; }
tpl [ErrorFrm](#i) { "errorfrm"; }

// Terms
tpl [Var](#i) { "B"; `@nr`; }
tpl [LocusVar](#i) { "A"; `@nr`; }
tpl [FreeVar](#i) { "X"; `@nr`; }
tpl [Const](#i) { "C"; `@nr`; }
tpl [InfConst](#i) { "D"; `@nr`; }
tpl [Num](#i) { "N"; `@nr`; }
tpl [Func](#i) { `@kind`; `@nr`; "( "; 
                 list(#separ=",", #elems=`*`, #i=$i); ")";}
tpl [PrivFunc](#i) { "H"; `@nr`; "( "; 
                     list(#separ=",", #elems=`*`, #i=$i); ")";}
tpl [ErrorTrm](#i) { "errortrm"; }
tpl [Fraenkel](#i) { "{ "; 
     apply[*[position() = last() - 1]](#i=$i); 
     if  [count(*)>2] { " where B is ";
      list(#separ=", B is ", #elems=`*[position() < last() - 1]`, #i=$i); }
     " : "; apply[*[position() = last()]](#i=$i); " } "; }

// Types
tpl [Typ](#i) { 
   " ";
   if [count(*)>0] { apply[*[1]](#i=$i); }
   if [@kind="G"] { "L"; } else { `@kind`;} `@nr`; 
   if [count(*)>2] { " of "; list(#separ=",", #elems=`*[position()>2]`, #i=$i); }
}

// Clusters
tpl [Cluster](#i) { list(#separ=" ", #elems=`*`, #i=$i); " "; }

// Adjective
tpl [Adjective](#i) { if [@value="false"] { "non "; } "V"; `@nr`;
	         if [count(*)>0] { "("; list(#separ=",", #elems=`*`, #i=$i); ")"; }}

// indents unless inside one-line item
tpl [Proposition](#i) { $i; if [@nr>0] { "E"; `@nr`; ": ";} apply(#i=$i); " ";}
tpl [Assume/Proposition|Given/Proposition|Conclusion/Proposition](#i) 
    { if [@nr>0] { "E"; `@nr`; ": "; } apply(#i=$i); " "; }
tpl [Consider/Proposition[position() > 1]](#i)
    { if [@nr>0] { "E"; `@nr`; ": "; } apply(#i=$i); " "; }

// Justifications
tpl [By](#i) { if [(@linked="true") or (count(*)>0)] { "by "; }  
           if [@linked="true"] { "previous"; } 
           if [count(*)>0] { if [@linked="true"] { ","; }
                             list(#separ=",", #elems=`*`, #i=$i); }
           ";"; <br; }
tpl [IterStep/By](#i) { if [(@linked="true") or (count(*)>0)] { "by "; }  
           if [@linked="true"] { "previous"; } 
           if [count(*)>0] { if [@linked="true"] { ","; }
                             list(#separ=",", #elems=`*`, #i=$i); } }

tpl [From](#i) { "from s"; `@nr`; if [@articlenr] { ":"; `@articlenr`; } "(";
             list(#separ=",", #elems=`*`, #i=$i); ")"; ";"; <br; }
tpl [IterStep/From](#i) { 
        "from s"; `@nr`; if [@articlenr] { ":"; `@articlenr`; } "(";
        list(#separ=",", #elems=`*`, #i=$i); ")"; }

tpl [Ref](#i) { if [not(@articlenr)] { "E"; } `@kind`; `@nr`; 
            if [@articlenr] { ":"; `@articlenr`;} }
tpl [ErrorInf](#i) { "errorinference;"; <br; }
tpl [IterStep/ErrorInf](#i) { "errorinference"; }
tpl [SkippedProof](#i) { "skippedproof;"; <br; }
tpl [IterStep/SkippedProof](#i) { "skippedproof"; }

//   Term, elIterStep+
tpl [IterEquality](#i) {
   $i; if [@nr>0] { "E"; `@nr`; ": ";}
   apply[*[1]](#i=$i); " = ";
   nlist(#separ=`concat($i, ".= ")`, #elems=`IterStep`, #i=$i); ";"; <br; }
tpl [IterStep](#i) { apply(#i=$i);  }

// Skeleton steps
tpl [Let](#i) { $i; "let C be "; 
            list(#separ=", C be ", #elems=`*`, #i=$i); ";"; <br; }
tpl [Assume](#i) { $i; "assume ";  if [count(*)>1] { "that "; }
	       nlist(#separ=`concat($i,"and ")`, #elems=`*`, #i=$i);
               ";"; <br; }
tpl [Given](#i) { $i; "given C being "; 
              list(#separ=", C being ", #elems=`Typ`, #i=$i); 
	      " such that ";
              nlist(#separ=`concat($i,"and ")`,#elems=`Proposition`,#i=$i); 
              ";"; <br; }
tpl [Take](#i) { $i; "take "; apply(#i=$i); ";"; <br; }
tpl [TakeAsVar](#i) { $i; "take C = ";   apply[*[2]](#i=$i); ";"; <br; }
tpl [Conclusion](#i) { $i; "thus "; apply(#i=$i); }
tpl [Case](#i) { $i; "case "; if [count(*)>1] { "that ";}
             nlist(#separ=`concat($i,"and ")`, #elems=`*`, #i=$i); ";"; <br; }
tpl [Suppose](#i) { $i; "suppose "; if [count(*)>1] { "that ";} 
             nlist(#separ=`concat($i,"and ")`, #elems=`*`, #i=$i); ";"; <br; }
tpl [PerCases](#i) { $i; "per cases "; apply(#i=$i); ";"; <br; }

// Auxiliary items
tpl [Consider](#i) { $i; "consider C being "; 
                 list(#separ=", C being ", #elems=`Typ`, #i=$i);
	         if [count(Proposition) > 1] { 
                   " such that "; <br; $i;
		   nlist(#separ=`concat($i,"and ")`,
                        #elems=`Proposition[position() > 1]`, #i=$i); } 
                 apply[*[2]](#i=$i); }

tpl [Reconsider](#i) { 
    $i; "reconsider C = "; 
    list(#separ=", C = ", #elems=`*[(position() > 1) 
                        and (position() < (last() - 1))]`, #i=$i);
    " as "; apply[*[1]](#i=$i); " "; 
    apply[*[last()]](#i=$i); } 

tpl [Set](#i) { $i; "set C = "; apply[*[1]](#i=$i); ";"; <br; }
tpl [DefFunc](#i) { $i; "deffunc H(";  
                list(#separ=",", #elems=`ArgTypes/Typ`, #i=$i); ") -> ";
                apply[*[3]](#i=$i); " = ";
	        apply[*[2]](#i=$i); ";"; <br; }
tpl [DefPred](#i) { $i; "defpred S["; 
                list(#separ=",", #elems=`ArgTypes/Typ`, #i=$i); "] means ";
	        apply[*[2]](#i=$i); ";"; <br; }

// Thesis after skeleton item, with definiens numbers
tpl [Thesis](#i) { } // $i; "thesis: "; apply[*[1]](#i=$i); " defs("; 
               // list(#separ=",", #elems=`ThesisExpansions/Pair[@x]`, #i=$i);
	       // ");"; <br; }

// Registrations
tpl [RCluster](#i) { $i; "cluster ";
                 if [ErrorCluster] { "errorcluster"; }
	         else { apply[*[3]](#i=$i); " "; apply[*[2]](#i=$i); }
                 ";"; <br; }
tpl [CCluster](#i) { $i; "cluster ";
                 if [ErrorCluster] { "errorcluster"; }
	         else { apply[*[2]](#i=$i); " -> "; apply[*[4]](#i=$i); " "; 
                        apply[*[3]](#i=$i); }
                 ";"; <br; }
tpl [FCluster](#i) { $i; "cluster ";
                 if [ErrorCluster] { "errorcluster"; }
	         else { apply[*[2]](#i=$i); " -> "; apply[*[3]](#i=$i); }
                 ";"; <br; }
// Blocks
tpl [BlockThesis](#i) { } // $i; "blockthesis: "; apply(#i=$i); ";"; <br; }

//   (  ( elBlockThesis, elCase, elThesis, Reasoning )
//   |  ( elCase, Reasoning, elBlockThesis ) )
tpl [CaseBlock](#i) { 
    $j=`concat($i,$add)`;
    apply[Case](#i=$i);
    apply[*[not(name()='Case')]](#i=$j); 
    $i; "end;"; <br; }

tpl [SupposeBlock](#i) {
    $j=`concat($i,$add)`;
    apply[Suppose](#i=$i);
    apply[*[not(name()='Suppose')]](#i=$j); 
    $i; "end;"; <br; }

//   (  ( elBlockThesis, ( elCaseBlock+ | elSupposeBlock+ ),
//        elPerCases, elThesis, elEndPosition  )
//   |  ( ( elCaseBlock+ | elSupposeBlock+ ),
//        elPerCases, elEndPosition, elBlockThesis ) )
tpl [PerCasesReasoning](#i) {
    $j=`concat($i,$add)`;
    apply[PerCases](#i=$i);
    apply[BlockThesis](#i=$j);
    apply[Thesis](#i=$j);
    apply[CaseBlock | SupposeBlock](#i=$j);
    $i; "end;"; <br; }

//   elBlockThesis, Reasoning 
tpl [Proof](#i) {
    $j=`concat($i,$add)`;
    <br; $i; "proof "; <br; apply(#i=$j);
    $i; "end;"; <br; } 

//   Reasoning, elBlockThesis 
tpl [Now](#i) {
    $j=`concat($i,$add)`;
    $i; "now "; <br; 
    apply[BlockThesis](#i=$j);
    apply[*[not(name()='BlockThesis')]](#i=$j); 
    $i; "end;"; <br; } 


// ignore them
tpl [Reservartion/Typ](#i) { ""; }
tpl [Definiens/*](#i) { ""; }

tpl [JustifiedTheorem](#i) { $i; "theorem"; <br; apply(#i=$i); }
tpl [DefTheorem](#i) { "deftheorem"; <br; apply(#i=$i);  ";"; <br; }


//   Property, elProposition, Justification
tpl [JustifiedProperty](#i) {
    $i; `translate(name(*[1]), $ucletters, $lcletters)`; <br; 
    apply[*[position()>1]](#i=$i); }

//  Formula | ( elProposition, Justification )
tpl [UnknownCorrCond|Coherence|Compatibility|Consistency|Existence|Uniqueness] 
    (#i) { $i; `translate(name(), $ucletters, $lcletters)`;
           <br; apply(#i=$i); }

// CorrectnessCondition*, elProposition, Justification
tpl [Correctness](#i) { $i; "correctness: "; <br; apply(#i=$i); }

tpl [Canceled](#i) { $i; "canceled;"; <br; }

tpl [SchemeFuncDecl](#i) { 
    "F"; `@nr`; "(";
     list(#separ=",", #elems=`ArgTypes/Typ`, #i=$i); ") -> ";
     apply[*[2]](#i=$i); }

tpl [SchemePredDecl](#i) { 
    "P"; `@nr`; "[";
     list(#separ=",", #elems=`ArgTypes/Typ`, #i=$i); "]"; }

//   ( elSchemeFuncDecl | elSchemePredDecl )*,
//   element elSchemePremises { elProposition* },
//   elProposition, Justification, elEndPosition
tpl [SchemeBlock](#i) {
    $j=`concat($i,$add)`;
    $i; "scheme s"; `@schemenr`; "{ ";
    list(#separ=", ", #elems=`SchemeFuncDecl|SchemePredDecl`, #i=$i); 
    " } :"; <br;
    apply[Proposition](#i=$j); <br; $i; "provided"; <br;
    list(#separ=" and ", #elems=`SchemePremises/Proposition`, #i=$j);
    apply[*[position() = last() - 1]](#i=$i);  }


//   ( ( CorrectnessCondition*, elCorrectness?,
//       elJustifiedProperty*, elConstructor? )
//   | ( elConstructor, elConstructor, elConstructor+,
//       CorrectnessCondition*, elCorrectness? ))
tpl [Definition](#i) {     $i;
   if [@kind = 'G'] { 
      "struct G(# ";
      for-each [Constructor[@kind="L"]/Fields/Int] { 
       "U"; `@x`; if [not(position()=last())] { ", "; } }
      " #) -> "; apply[Constructor[@kind="G"]/Typ](#i=$i); ";"; <br; 
      $i; "structmode L( ";
      arglist(#separ=",", #letter="A", 
              #elems=`Constructor[@kind="L"]/ArgTypes/Typ`);
      ") -> ( "; 
      list(#separ=", ", #elems=`Constructor/Typ`, #i=$i);
      " );"; <br;
      for-each [Constructor[@kind="U"]] {
        $i; "selector U(";
        arglist(#separ=",", #letter="A", #elems=`ArgTypes/Typ`); 
        ") -> "; apply[Typ](#i=$i); <br; } 
      $i; "attr strict V(";
      arglist(#separ=",", #letter="A", 
              #elems=`Constructor[@kind="V"]/ArgTypes/Typ`); 
      ")"; <br;
   }
   else { 
    if [@expandable="true"] { "expandable mode;"; <br; }
    else {
     if [@redefinition="true"] { "redefine "; }
     choose { 
      when [@kind = 'M'] { "mode M";}
      when [@kind = 'V'] { "attr V";}
      when [@kind = 'R'] { "pred R";}
      when [@kind = 'K'] { "func K";} }
     if [@redefinition="true"] { `Constructor/@redefnr`; " as "; `@kind`; }
     "("; 
      arglist(#separ=",", #letter="A", 
              #elems=`Constructor/ArgTypes/Typ`); 
      ")";
      if [(@kind = 'M') or (@kind = 'K')] { 
         " -> "; apply[Constructor/Typ](#i=$i); }
      ";"; <br; 
      apply[*[not(name()='Constructor')]](#i=$i);
}}}

//   ( elLet | elAssume | elGiven | AuxiliaryItem |
//     elCanceled | elDefinition )*, elEndPosition
tpl [DefinitionBlock](#i) {
   $j=`concat($i,$add)`;
   $i; "definition"; <br;
   apply[*[not(name()='EndPosition')]](#i=$j);
   $i; "end;"; <br;  } 

//   ( elRCluster | elFCluster | elCCluster ),
//   CorrectnessCondition*, elCorrectness?
tpl [Registration](#i) { apply(#i=$i); }

//   ( elLet | AuxiliaryItem | elRegistration | elCanceled )+, elEndPosition
tpl [RegistrationBlock](#i) {
    $j=`concat($i,$add)`;
    $i; "registration"; <br;     
    apply[*[not(name()='EndPosition')]](#i=$j);
    $i; "end;"; <br;  } 

tpl [NotationBlock] {
    $j=`concat($i,$add)`;
    $i; "notation"; <br;     
    apply[*[not(name()='EndPosition')]](#i=$j);
    $i; "end;"; <br;  } 

// List utility
tpl list(#separ,#elems,#i) { 
 for-each [$elems] {
  apply[.](#i=$i); if [not(position()=last())] { $separ; } }
}

// newlined list
tpl nlist(#separ,#elems,#i) { 
 for-each [$elems] {
  apply[.](#i=$i); if [not(position()=last())] { <br; $separ; } }
}


// argument list
tpl arglist(#separ,#letter,#elems) { 
 for-each [$elems] {
  $letter; `position()`; if [not(position()=last())] { $separ; } }
}

// separate top-level items by additional newline
tpl [Article](#i) { for-each [*] { apply[.](#i=$i); <br;} }

// Default
tpl [/] { <html { <body {  apply(#i=""); }} }  
// tpl [*](#i) { copy { apply [@*](#i=$i); apply(#i=$i); } }
// tpl [@*](#i) { copy-of `.`; }


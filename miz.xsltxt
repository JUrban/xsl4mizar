stylesheet 1.0;

// XSLTXT (https://xsltxt.dev.java.net/) stylesheet taking 
// XML terms, formulas and types to less verbose format.

// To produce standard XSLT from this do e.g.: 
// java -jar xsltxt.jar toXSL miz.xsltxt >miz.xsl

// Then e.g.: xalan -XSL miz.xsl <ordinal2.pre >ordinal2.pre1

// TODO: number B vars in 'for' and fraenkel
//       number C vars in 'Let', 'Given', TakeAsVar, (Re)Consider,
//                        'Set',
//       numbers for Deffunc, Defpred
//       article numbering in Ref?
//       absolute definiens numbers for thesisExpansions?
//       add @name to Article
//       do not display BlockThesis for Proof?
//       add @nr to canceled
//       Reservartion -> Reservation; displaying?
//       Constructor should know its serial number! - needed in defs
//       possibly also article?
//       change globally 'G' to 'L' for types? -> then change the
//       hacks here and in emacs.el
//       display definiens?

output method=html;

key "type" [Typ] `@nr` ;
key "M" [Constructor[@kind='M']] `@relnr` ;
key "L" [Constructor[@kind='L']] `@relnr` ;
key "V" [Constructor[@kind='V']] `@relnr` ;
key "R" [Constructor[@kind='R']] `@relnr` ;
key "K" [Constructor[@kind='K']] `@relnr` ;
key "U" [Constructor[@kind='U']] `@relnr` ;
key "G" [Constructor[@kind='G']] `@relnr` ;

$lcletters= { "abcdefghijklmnopqrstuvwxyz"; }
$ucletters= { "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; } 

// .atr file with constructors
$constrs=  { `concat(translate(string(/Article/@name), 
	                       $ucletters, $lcletters), '.atr')`; }

// mmlquery address
$mmlq= { "http://merak.pb.bialystok.pl/mmlquery/fillin.php?"; }

// tells whether relative or absolute names are shown
$relnames= { "1"; }

// Formulas
tpl [For] { "for B being"; apply[*[1]]; 	
                " holds "; <br;  apply[*[2]];   }
// tpl [And/For] { <div {"for B being"; apply[*[1]]; 	
//                " holds "; <div { @class="add";  apply[*[2]]; } } }
tpl [Not] { "not "; apply[*[1]]; }
// tpl [And/Not] { if [For] { <div { "not "; apply[*[1]]; } }
//                else { "not "; apply[*[1]]; } }
tpl [And] { "( "; list(#separ=" & ", #elems=`*`); " )"; }
tpl [Pred] { 
// `@kind`; `@nr`; 
// absref(#elems=`key('pred',@nr)`);
abs(#k=`@kind`, #nr=`@nr`);
 "[ "; list(#separ=",", #elems=`*`); "]"; }
tpl [PrivPred] { "S"; `@nr`; "[ "; list(#separ=",", #elems=`*`); "]"; }
tpl [Is] { apply[*[1]]; " is "; apply[*[2]]; } 
tpl [Verum] { "verum"; }
tpl [ErrorFrm] { "errorfrm"; }

// Terms
tpl [Var] { "B"; `@nr`; }
tpl [LocusVar] { "A"; `@nr`; }
tpl [FreeVar] { "X"; `@nr`; }
tpl [Const] { "C"; `@nr`; }
tpl [InfConst] { "D"; `@nr`; }
tpl [Num] { "N"; `@nr`; }
tpl [Func] { 
// `@kind`; `@nr`; 
abs(#k=`@kind`, #nr=`@nr`);
"( "; list(#separ=",", #elems=`*`); ")"; }
tpl [PrivFunc] { "H"; `@nr`; "( "; list(#separ=",", #elems=`*`); ")"; }
tpl [ErrorTrm] { "errortrm"; }
tpl [Fraenkel] { "{ "; 
     apply[*[position() = last() - 1]]; 
     if  [count(*)>2] { " where B is ";
      list(#separ=", B is ", #elems=`*[position() < last() - 1]`); }
     " : "; apply[*[position() = last()]]; " } "; }

// Types
tpl [Typ] { 
   " ";
   if [count(*)>0] { apply[*[1]]; }
   if [@kind="M"] { abs(#k="M", #nr=`@nr`); }
   else { if [@kind="G"] { abs(#k="L", #nr=`@nr`); }
     else { `@kind`; }}
//   if [@kind="G"] { "L"; } else { `@kind`;} `key('pred',@nr)`;
//  `@nr`; 
   if [count(*)>2] { " of "; list(#separ=",", #elems=`*[position()>2]`); }
}

// Clusters
tpl [Cluster] { list(#separ=" ", #elems=`*`); " "; }

// Adjective
tpl [Adjective] { if [@value="false"] { "non "; } 
// "V"; `@nr`;
abs(#k="V", #nr=`@nr`);
	         if [count(*)>0] { "("; list(#separ=",", #elems=`*`); ")"; }}

tpl [Proposition] { if [@nr>0] { "E"; `@nr`; ": ";} apply; " ";}

// Justifications
tpl [By] { if [(@linked="true") or (count(*)>0)] { "by "; }  
           if [@linked="true"] { "previous"; } 
           if [count(*)>0] { if [@linked="true"] { ","; }
                             list(#separ=",", #elems=`*`); }
           ";"; <br; }
tpl [IterStep/By] { if [(@linked="true") or (count(*)>0)] { "by "; }  
           if [@linked="true"] { "previous"; } 
           if [count(*)>0] { if [@linked="true"] { ","; }
                             list(#separ=",", #elems=`*`); } }

tpl [From] { "from s"; `@nr`; if [@articlenr] { ":"; `@articlenr`; } "(";
             list(#separ=",", #elems=`*`); ")"; ";"; <br; }
tpl [IterStep/From] { 
        "from s"; `@nr`; if [@articlenr] { ":"; `@articlenr`; } "(";
        list(#separ=",", #elems=`*`); ")"; }

tpl [Ref] { if [not(@articlenr)] { "E"; } `@kind`; `@nr`; 
            if [@articlenr] { ":"; `@articlenr`;} }
tpl [ErrorInf] { "errorinference;"; <br; }
tpl [IterStep/ErrorInf] { "errorinference"; }
tpl [SkippedProof] { "skippedproof;"; <br; }
tpl [IterStep/SkippedProof] { "skippedproof"; }

//   Term, elIterStep+
tpl [IterEquality] {
   if [@nr>0] { "E"; `@nr`; ": ";}
   apply[*[1]]; " = ";
   nlist(#separ=".= ", #elems=`IterStep`); ";"; <br; }
tpl [IterStep] { apply;  }

// Skeleton steps
tpl [Let] { "let C be "; 
            list(#separ=", C be ", #elems=`*`); ";"; <br; }
tpl [Assume] { "assume ";  if [count(*)>1] { "that "; }
	       nlist(#separ="and ", #elems=`*`);
               ";"; <br; }
tpl [Given] { "given C being "; 
              list(#separ=", C being ", #elems=`Typ`); 
	      " such that ";
              nlist(#separ="and ",#elems=`Proposition`); 
              ";"; <br; }
tpl [Take] { "take "; apply; ";"; <br; }
tpl [TakeAsVar] { "take C = ";   apply[*[2]]; ";"; <br; }
tpl [Conclusion] { "thus "; apply; }
tpl [Case] { "case "; if [count(*)>1] { "that ";}
             nlist(#separ="and ", #elems=`*`); ";"; <br; }
tpl [Suppose] { "suppose "; if [count(*)>1] { "that ";} 
             nlist(#separ="and ", #elems=`*`); ";"; <br; }
tpl [PerCases] { "per cases "; apply; }

// Auxiliary items
tpl [Consider] { "consider C being "; 
                 list(#separ=", C being ", #elems=`Typ`);
	         if [count(Proposition) > 1] { 
                   " such that "; <br; 
		   nlist(#separ="and ",
                        #elems=`Proposition[position() > 1]`); } 
                 apply[*[2]]; }

tpl [Reconsider] { 
    "reconsider C = "; 
    list(#separ=", C = ", #elems=`*[(position() > 1) 
                        and (position() < (last() - 1))]`);
    " as "; apply[*[1]]; " "; 
    apply[*[last()]]; } 

tpl [Set] { "set C = "; apply[*[1]]; ";"; <br; }
tpl [DefFunc] { "deffunc H(";  
                list(#separ=",", #elems=`ArgTypes/Typ`); ") -> ";
                apply[*[3]]; " = ";
	        apply[*[2]]; ";"; <br; }
tpl [DefPred] { "defpred S["; 
                list(#separ=",", #elems=`ArgTypes/Typ`); "] means ";
	        apply[*[2]]; ";"; <br; }

// Thesis after skeleton item, with definiens numbers
tpl [Thesis] { } // "thesis: "; apply[*[1]]; " defs("; 
               // list(#separ=",", #elems=`ThesisExpansions/Pair[@x]`);
	       // ");"; <br; }

// Registrations
tpl [RCluster] { "cluster ";
                 if [ErrorCluster] { "errorcluster"; }
	         else { apply[*[3]]; " "; apply[*[2]]; }
                 ";"; <br; }
tpl [CCluster] { "cluster ";
                 if [ErrorCluster] { "errorcluster"; }
	         else { apply[*[2]]; " -> "; apply[*[4]]; " "; 
                        apply[*[3]]; }
                 ";"; <br; }
tpl [FCluster] { "cluster ";
                 if [ErrorCluster] { "errorcluster"; }
	         else { apply[*[2]]; " -> "; apply[*[3]]; }
                 ";"; <br; }
// Blocks
tpl [BlockThesis] { } // "blockthesis: "; apply; ";"; <br; }

//   (  ( elBlockThesis, elCase, elThesis, Reasoning )
//   |  ( elCase, Reasoning, elBlockThesis ) )
tpl [CaseBlock] { 
    <div { apply[Case];
    <div { @class="add"; apply[*[not(name()='Case')]]; }
    "end;"; } }

tpl [SupposeBlock] {
    <div { apply[Suppose];
    <div { @class="add"; apply[*[not(name()='Suppose')]]; }
    "end;"; } }

//   (  ( elBlockThesis, ( elCaseBlock+ | elSupposeBlock+ ),
//        elPerCases, elThesis, elEndPosition  )
//   |  ( ( elCaseBlock+ | elSupposeBlock+ ),
//        elPerCases, elEndPosition, elBlockThesis ) )
tpl [PerCasesReasoning] {
    <div { apply[PerCases];
    <div { @class="add"; apply[BlockThesis];
           apply[Thesis];
           apply[CaseBlock | SupposeBlock]; }
    "end;"; } }

//   elBlockThesis, Reasoning 
tpl [Proof] {
    <div { "proof "; 
    <div { @class="add"; apply; }
    "end;"; } } 

//   Reasoning, elBlockThesis 
tpl [Now] {
    <div { "now ";
    <div { @class="add"; apply[BlockThesis];
           apply[*[not(name()='BlockThesis')]]; } 
    "end;"; } } 


// ignore them
tpl [Reservartion/Typ] { ""; }
tpl [Definiens/*] { ""; }

tpl [JustifiedTheorem] { "theorem"; <br; apply; }
tpl [DefTheorem] { "deftheorem"; <br; apply;  ";"; <br; }


//   Property, elProposition, Justification
tpl [JustifiedProperty] {
    `translate(name(*[1]), $ucletters, $lcletters)`; <br; 
    apply[*[position()>1]]; }

//  Formula | ( elProposition, Justification )
tpl [UnknownCorrCond|Coherence|Compatibility|Consistency|Existence|Uniqueness] 
    { `translate(name(), $ucletters, $lcletters)`;
           <br; apply; }

// CorrectnessCondition*, elProposition, Justification
tpl [Correctness] { "correctness: "; <br; apply; }

tpl [Canceled] { "canceled;"; <br; }

tpl [SchemeFuncDecl] { 
    "F"; `@nr`; "(";
     list(#separ=",", #elems=`ArgTypes/Typ`); ") -> ";
     apply[*[2]]; }

tpl [SchemePredDecl] { 
    "P"; `@nr`; "[";
     list(#separ=",", #elems=`ArgTypes/Typ`); "]"; }

//   ( elSchemeFuncDecl | elSchemePredDecl )*,
//   element elSchemePremises { elProposition* },
//   elProposition, Justification, elEndPosition
tpl [SchemeBlock] {
    <div { "scheme s"; `@schemenr`; "{ ";
    list(#separ=", ", #elems=`SchemeFuncDecl|SchemePredDecl`); 
    " } :"; <br;
    <div { @class="add"; apply[Proposition]; } "provided";
    <div { @class="add"; list(#separ=" and ", #elems=`SchemePremises/Proposition`); }
    apply[*[position() = last() - 1]];  }}


//   ( ( CorrectnessCondition*, elCorrectness?,
//       elJustifiedProperty*, elConstructor? )
//   | ( elConstructor, elConstructor, elConstructor+,
//       CorrectnessCondition*, elCorrectness? ))
tpl [Definition] {     
   if [@kind = 'G'] { 
      "struct G(# ";
      for-each [Constructor[@kind="L"]/Fields/Int] { 
       "U"; `@x`; if [not(position()=last())] { ", "; } }
      " #) -> "; apply[Constructor[@kind="G"]/Typ]; ";"; <br; 
      "structmode L( ";
      arglist(#separ=",", #letter="A", 
              #elems=`Constructor[@kind="L"]/ArgTypes/Typ`);
      ") -> ( "; 
      list(#separ=", ", #elems=`Constructor/Typ`);
      " );"; <br;
      for-each [Constructor[@kind="U"]] {
        "selector U(";
        arglist(#separ=",", #letter="A", #elems=`ArgTypes/Typ`); 
        ") -> "; apply[Typ]; <br; } 
      "attr strict V(";
      arglist(#separ=",", #letter="A", 
              #elems=`Constructor[@kind="V"]/ArgTypes/Typ`); 
      ")"; <br;
   }
   else { 
    if [@expandable="true"] { "expandable mode;"; <br; }
    else {
     if [@redefinition="true"] { "redefine "; }
     mkind(#kind=`@kind`); " "; `@kind`;
     if [@redefinition="true"] { `Constructor/@redefnr`; " as "; `@kind`; }
     "("; 
      arglist(#separ=",", #letter="A", 
              #elems=`Constructor/ArgTypes/Typ`); 
      ")";
      if [(@kind = 'M') or (@kind = 'K')] { 
         " -> "; apply[Constructor/Typ]; }
      ";"; <br; 
      apply[*[not(name()='Constructor')]];
}}}

//   ( elLet | elAssume | elGiven | AuxiliaryItem |
//     elCanceled | elDefinition )*, elEndPosition
tpl [DefinitionBlock] {
   <div { "definition";
   <div { @class="add"; apply[*[not(name()='EndPosition')]]; }
   "end;"; }  } 

//   ( elRCluster | elFCluster | elCCluster ),
//   CorrectnessCondition*, elCorrectness?
tpl [Registration] { apply; }

//   ( elLet | AuxiliaryItem | elRegistration | elCanceled )+, elEndPosition
tpl [RegistrationBlock] {
    <div {"registration"; 
    <div { @class="add"; apply[*[not(name()='EndPosition')]]; }
    "end;"; }  } 

tpl [NotationBlock] {
    <div { "notation";
    <div { @class="add"; apply[*[not(name()='EndPosition')]]; }
    "end;"; }  } 

// List utility
tpl list(#separ,#elems) { 
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { $separ; } }
}

// newlined list
tpl nlist(#separ,#elems) { 
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { <br; $separ; } }
}

tpl dlist(#separ,#elems) { 
 for-each [$elems] {
  <div { apply[.]; if [not(position()=last())] { $separ; } } }
}


// argument list
tpl arglist(#separ,#letter,#elems) { 
 for-each [$elems] {
  $letter; `position()`; if [not(position()=last())] { $separ; } }
}

// add the constructor href
tpl absref(#elems) { for-each [$elems] { 
$mk=mkind(#kind=`@kind`);
<a { @href=`concat("fillin.php?entry=",@aid,":",$mk,".",@nr)`;

if [$relnames>0] { `@kind`; `@relnr`; }
else { `@kind`; `@nr`; "_"; `@aid`;  } } }}

tpl abs(#k,#nr) { 
   if [key($k,$nr)] { absref(#elems=`key($k,$nr)`); }
   else { 
      for-each [document($constrs)] { 
      absref(#elems=`key($k,$nr)`); } } }

// translate constructor kinds to their mizar/mmlquery names
tpl mkind(#kind) {
choose { 
      when [$kind = 'M'] { "mode";}
      when [$kind = 'V'] { "attr";}
      when [$kind = 'R'] { "pred";}
      when [$kind = 'K'] { "func";}
      when [$kind = 'G'] { "aggr";}
      when [$kind = 'L'] { "struct";}
      when [$kind = 'U'] { "sle";}
 }}


// separate top-level items by additional newline
tpl [Article] { for-each [*] { apply[.]; <br;} }


// prevent processing of .atr 
tpl [/Constructors/Constructor] {}

// Default
tpl [/] { <html { 

// output the css defaults for div and p (for indenting)
        <style { @type="text/css"; 
                 "div { padding: 0 0 0 0; margin: 0 0 0 0; } div.add { padding-left: 3mm; padding-bottom: 0mm;  margin: 0 0 0 0; } p { margin: 0 0 0 0; }";
	                } 
        <head {  <base { @href=$mmlq; @target="mmlquery"; } }
        <body {  

// first read the absolute constructor names from .atr
          apply[document($constrs)/Constructors/Constructor]; 

// then process the whole document
          apply; }} }
  
// tpl [*] { copy { apply [@*]; apply; } }
// tpl [@*] { copy-of `.`; }

